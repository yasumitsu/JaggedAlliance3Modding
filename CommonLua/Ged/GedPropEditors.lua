----- Handling T values for Ged <-- search for this for more information

-- value from the game => a T for an edit control
---
--- Converts a value to a table with a T metatable.
---
--- If the input `value` is a table, it creates a new table with the same contents and sets the metatable to `TMeta`. If the input `value` is not a table, it returns an empty string.
---
--- @param value any The value to convert to a T table.
--- @return table|string The converted value with a T metatable, or an empty string if the input was not a table.
---
function GedPropValueToT(value)
	return type(value) == "table" and setmetatable(table.copy(value), TMeta) or ""
end

-- a T from an edit control => value for the game
---
--- Converts a T table value to a value suitable for the game.
---
--- If the input `value` is a table with a T metatable, it creates a new table with the same contents and removes the T metatable. If the input `value` is an empty string, it returns the `default` value if provided, or an empty string. If the input `value` is a table with a loc ID, it checks if the text matches the default value, and if so, returns the default value. Otherwise, it generates a new random loc ID and returns a new table with the new ID and the original text.
---
--- @param value table|string The value to convert from a T table.
--- @param default table|string The default value to use if the input `value` is an empty string.
--- @return table|string The converted value, with the T metatable removed if present.
---
function GedTToPropValue(value, default)
	assert(not default or default == "" or not IsT(default))
	if value == "" then
		return type(default) == "table" and "" or default
	end
	
	assert(#value == 2) -- must have a loc ID generated by the edit field
	value[2] = ReplaceNonStandardCharacters(value[2])
	
	if type(default) == "table" and #default == 2 and type(default[1]) == "number" then -- is the default a T value with an ID?
		-- use the loc ID of the default if the text is the same as the default
		if value[2] == default[2] then
			return table.raw_copy(default)
		end
		
		-- change the loc ID if editing the default value
		if value[1] == default[1] then
			return { RandomLocId(), value[2] }
		end
	end
	
	return table.raw_copy(value) -- strip T metatables (they can't pass through sockets and cause an assert)
end


----- GedPropEditor - prop editors base class

GedPropEditors = {}
GedPropEditors["buttons"] = "GedPropEditor"

DefineClass.GedPropEditor = {
	__parents = { "XContextControl" },
	
	IdNode = true,
	LayoutHSpacing = 2,
	LayoutVSpacing = 2,
	FoldWhenHidden = true,
	RolloverAnchor = "left",
	RolloverTemplate = "GedPropRollover",
	SelectionBackground = RGB(204, 232, 255),
	BorderColor = RGBA(0, 0, 0, 0),
	BorderWidth = 2,
	
	prop_meta = false,
	parent_obj_id = false,
	panel = false,
	obj = false,
	last_set_value = false,
	selectable = true,
	selected = false,
	highlight_search_match = false,
	accept_os_clipboard_paste = false,
}

---
--- Reassigns the focus orders for the GedPropEditor.
---
--- @param x number The x-coordinate of the focus order.
--- @param y number The y-coordinate of the focus order.
--- @return number The updated y-coordinate of the focus order.
---
function GedPropEditor:ReassignFocusOrders(x, y)
	return y + 1
end

---
--- Queues the reassignment of focus orders for the GedPropEditor's parent GedPropPanel.
---
--- This function is used to ensure that the focus order of the controls within the GedPropPanel
--- are properly reassigned when the GedPropEditor's state changes.
---
--- @return nil
---
function GedPropEditor:QueueReassignFocusOrders()
	local obj = GetParentOfKind(self, "GedPropPanel")
	if obj then
		obj:QueueReassignFocusOrders()
	end
end

---
--- Sets the selected state of the GedPropEditor.
---
--- When the GedPropEditor is selected, this function will set the `selected` property
--- and invalidate the control to trigger a redraw.
---
--- @param selected boolean Whether the GedPropEditor should be selected or not.
--- @return nil
---
function GedPropEditor:SetSelected(selected)
	self.selected = selected
	self:Invalidate()
end

---
--- Calculates the background color for the GedPropEditor control.
---
--- If the GedPropEditor is enabled and selected, the `SelectionBackground` color is used.
--- Otherwise, the background is calculated using the base `XContextControl.CalcBackground` function.
---
--- @return table The calculated background color
---
function GedPropEditor:CalcBackground()
	if self.enabled and self.selected then 
		return self.SelectionBackground
	end
	return XContextControl.CalcBackground(self)
end

---
--- Sets whether the GedPropEditor should highlight the search match.
---
--- When the `highlight_search_match` property is set to `true`, the property name
--- displayed in the GedPropEditor will be highlighted to indicate that it matches
--- the current search.
---
--- @param value boolean Whether to highlight the search match or not.
--- @return nil
---
function GedPropEditor:SetHighlightSearchMatch(value)
	self.highlight_search_match = value
end

---
--- Updates the property names displayed in the GedPropEditor.
---
--- This function is responsible for formatting the property name that is displayed
--- in the GedPropEditor. It applies any necessary prefixes or suffixes, and handles
--- highlighting the property name if it matches the current search.
---
--- @param internal boolean Whether the property name is an internal ID or a display name.
--- @param prop_name string The property name to display.
--- @return nil
---
function GedPropEditor:UpdatePropertyNames(internal, prop_name)
	local prop_meta = self.prop_meta
	local prop_name = prop_name or (internal and prop_meta.id or (prop_meta.name or prop_meta.id))
	local prefix, suffix = "", ""
	if prop_meta.dlc_name then
		prefix = "<style GedHighlight>["..prop_meta.dlc_name.."]</style> "
	end
	if prop_meta.scale_name then
		suffix = " ("..prop_meta.scale_name..")"
	end
	if self.highlight_search_match then
		prop_name = GedPanelBase.MatchMark .. prop_name
	end
	
	local rollover
	local editor = prop_meta.editor
	if self.panel.ShowUnusedPropertyWarnings and not PlaceholderProperties[editor] then
		local prop_stats = self.panel:Obj("root|prop_stats")
		if prop_stats and prop_stats[prop_meta.id] then
			local used_in = prop_stats[prop_meta.id]
			if used_in == 0 then
				prefix = "<image CommonAssets/UI/Ged/warning.tga 900 127 127 127> " .. prefix
				rollover = "<style GedHighlight>Property is default for all presets."
			else -- only used one time, see GedPresetPropertyUsageStats
				prefix = "<image CommonAssets/UI/Ged/warning.tga 900 127 180 127> " .. prefix
				rollover = "<style GedHighlight>Property is only set in " .. used_in .. "."
			end
		end
	end
	self.idLabel:SetText(prefix..prop_name..suffix)
	if editor == "buttons" or not PlaceholderProperties[editor] then
		self:SetRolloverText(prop_meta.help and rollover and prop_meta.help.."\n\n"..rollover or prop_meta.help or rollover or false)
	end
end

---
--- Determines whether a button should be shown for the given function name.
---
--- @param func_name string The name of the function to check.
--- @return boolean Whether a button should be shown for the given function.
---
function GedPropEditor:ShouldShowButtonForFunc(func_name)
	return self.panel:ShouldShowButtonForFunc(func_name)
end

---
--- Initializes a GedPropEditor instance.
---
--- @param parent table The parent window for the GedPropEditor.
--- @param context table The context for the GedPropEditor.
--- @param prop_meta table The property metadata for the GedPropEditor.
--- @return nil
---
function GedPropEditor:Init(parent, context, prop_meta)
	self.prop_meta = prop_meta
	self.RolloverText = prop_meta.help or nil
	self.RolloverAnchor = "smart"
	
	local win = XWindow:new({
		Id = "idLabelHost",
		Dock = prop_meta.name_on_top and "top" or "left",
		FoldWhenHidden = true,
	}, self)
	XText:new({
		Id = "idLabel", 
		Dock = "left",
		VAlign = "center",
		MinWidth = 150,
	}, win)
	XTextButton:new({
		Id = "idResetToDefault",
		Dock = "right",
		VAlign = "center",
		Text = "x",
		MaxWidth = 20,
		MaxHeight = 16,
		LayoutHSpacing = 0,
		Padding = box(1, 1, 1, 1),
		Background = RGBA(0, 0, 0, 0),
		RolloverBackground = RGB(204, 232, 255),
		PressedBackground = RGB(121, 189, 241),
		OnPress = function()
			self.panel:SetPanelFocused() -- focused prop editors may deny value updates
			self:SetProp(nil, "force")
		end
	}, win)
	win:SetVisibleInstant(not prop_meta.hide_name)
	
	local editor = prop_meta.editor
	if editor == "buttons" then
		win:SetDock("ignore")
		win:SetVisible(false)
	end
	
	if self.prop_meta.buttons then
		local buttons_host = XWindow:new({
			Id = "idButtonsHost",
			Dock = PlaceholderProperties[editor] and "bottom" or "right",
			HAlign = "center",
			LayoutMethod = "HWrap",
			LayoutHSpacing = 2,
			Padding = box(2, 1, 0, 0),
		}, self)
		for _, data in ipairs(prop_meta.buttons or empty_table) do
			if self:ShouldShowButtonForFunc(data.func) then
				local button
				if data.toggle then
					button = XTemplateSpawn("GedToolbarToggleButtonSmall", buttons_host)
					button:SetIcon(data.icon)
					button:SetToggled(data.toggled)
				elseif data.icon then
					button = XTemplateSpawn("GedToolbarButtonSmall", buttons_host)
					button:SetIcon(data.icon)
				else
					button = XTemplateSpawn("GedPropertyButton", buttons_host)
					button:SetText(data.name)
				end
				if data.icon_scale then
					local scale = data.icon_scale * 10
					button:SetIconScale(point(scale, scale))
				end
				button.OnPress = function(button)
					button:SetFocus()
					self.panel:Op("GedPropEditorButton", self.panel.context, self.panel.RootObjectBindName or "root",
						prop_meta.id, data.name, data.func, data.param)
					button:SetFocus(false)
				end
				button:SetRolloverText(data.rollover or "")
				button:SetDock(false)
			end
		end
	end
end

--- Gets the value of the property associated with the GedPropEditor.
---
--- @param self GedPropEditor The GedPropEditor instance.
--- @return any The value of the property associated with the GedPropEditor.
function GedPropEditor:GetProp()
	local obj = self.panel:Obj(self.obj)
	local value = obj and obj[self.prop_meta.id]
	if value == nil then
		value = self.prop_meta.default
	end
	return value
end

---
--- Sets the value of the property associated with the GedPropEditor.
---
--- @param self GedPropEditor The GedPropEditor instance.
--- @param value any The new value to set for the property.
--- @param force boolean (optional) If true, the value will be set even if it is the same as the last set value.
--- @param slider_drag_id any (optional) An identifier for the slider drag operation, if applicable.
---
--- @return nil
function GedPropEditor:SetProp(value, force, slider_drag_id)
	if self.prop_meta.read_only or self.panel.prop_update_in_progress then return end
	if value == Undefined() then return end
	if value == nil and not force then return end
	
	-- fixes double-set scenarios when editing SortKey with multiple selection, and Preset.OnEditorSetProperty
	-- changes the selection after sorting presets, resulting in setting the same value to totally different objects
	local lua_value = ValueToLuaCode(value)
	if self.last_set_value == lua_value then return end
	self.last_set_value = lua_value
	
	LaunchRealTimeThread(function(self, value)
		local err = self.panel:RemoteSetProperty(self.obj, self.prop_meta.id, value, self.parent_obj_id, slider_drag_id)
		if rawget(self, "idResetToDefault") then
			if err then
				self.idResetToDefault:SetVisible(true)
				self.idResetToDefault:SetTextStyle("GedError")
			else
				self.idResetToDefault:SetVisible(value ~= nil and self.prop_meta.default ~= nil and value ~= self.prop_meta.default and not self.prop_meta.read_only)
			end
		end
		self:SetPropResult(err)
	end, self, value)
end

--- Called when the GedPropEditor loses focus.
---
--- If the property associated with the GedPropEditor is not read-only, this function sends the current value of the property to the game.
function GedPropEditor:OnKillFocus()
	if not self.prop_meta.read_only then
		self:SendValueToGame()
	end
end

---
--- Sends the current value of the property associated with the GedPropEditor to the game.
---
--- This function is called when the GedPropEditor loses focus. If the property is not read-only, this function sends the current value to the game.
---
function GedPropEditor:SendValueToGame()
end

--- Updates the value of the GedPropEditor.
---
--- This function is called to update the value of the GedPropEditor. It retrieves the current value of the property, sets the visibility of the "Reset to Default" button based on the property's read-only status and whether the current value matches the default value, and updates the `last_set_value` field with the current value converted to Lua code. Finally, it sends a "GedPropertyUpdated" message.
---
--- @param self GedPropEditor The GedPropEditor instance.
---
--- @return nil
function GedPropEditor:UpdateValue()
	local value = self:GetProp()
	
	if self:HasMember("idResetToDefault") then
		self.idResetToDefault:SetVisible(value ~= nil and self.prop_meta.default ~= nil and value ~= self.prop_meta.default and not self.prop_meta.read_only)
	end
	
	self.last_set_value = ValueToLuaCode(value)
	Msg("GedPropertyUpdated", self)
end

---
--- Sets the result of a property update operation.
---
--- This function is called after a property update operation is performed. If there was an error during the update, it creates a new `XLabel` control with the error message and adds it to the bottom of the `GedPropEditor` control. If there was no error, it hides any existing error label.
---
--- @param self GedPropEditor The `GedPropEditor` instance.
--- @param err string The error message, if any, from the property update operation.
--- @return nil
function GedPropEditor:SetPropResult(err)
	if self.window_state == "destroying" then return end -- can be invoked from OnKillFocus when a prop editor is being destroyed
	
	if rawget(self, "idError") then
		self.idError:Close()
	end
	if err and err ~= "" then
		XLabel:new({
			Id = "idError",
			Dock = "bottom",
			ZOrder = -1,
			TextStyle = "GedError",
		}, self):Open()
		self.idError:SetText(err)
	end
end

local function search_display_text(text, filter)
	assert(text == "" or not IsT(text))
	text = tostring(text):gsub("<[^>]+>", "")
	text = string.lower(text)
	return text:find(filter, 1, true)
end

local function get_children_of_classes(win, results, ...)
	if not results then 
		results = {}
	end
	for _, child in ipairs(win) do
		if IsKindOfClasses(child, ...) then 
			table.insert(results, child)
		end
		get_children_of_classes(child, results, ...)
	end
	return results
end

---
--- Searches for the given `search_text` in all child controls of type `XText` or `XEditableText`, and highlights the `highlight_text` in those controls.
---
--- @param self GedPropEditor The `GedPropEditor` instance.
--- @param search_text string The text to search for.
--- @param highlight_text string The text to highlight in the matching controls.
--- @return boolean True if the search text was found, false otherwise.
function GedPropEditor:FindText(search_text, highlight_text)
	-- looks in all child controls of type XText or XEditableText
	local text_controls = get_children_of_classes(self, nil, "XText", "XEditableText")
	if #text_controls == 0 then
		return true
	end
	
	local found
	for _, win in ipairs(text_controls) do
		if search_display_text(win.text, search_text) then
			found = true
		end
		if IsKindOf(win, "XTextEditor") then
			local plugin = win:FindPluginOfKind("XHighlightTextPlugin")
			if not plugin then
				plugin = XHighlightTextPlugin:new()
				win:AddPlugin(plugin)
			end
			plugin.highlighted_text = highlight_text
			plugin.ignore_case = true
			win:Invalidate()
		end
	end
	return found
end

---
--- Highlights and selects the first occurrence of the given text in the first child edit control of the GedPropEditor.
---
--- @param self GedPropEditor The `GedPropEditor` instance.
--- @param text string The text to highlight and select.
--- @return any The focused control.
function GedPropEditor:HighlightAndSelect(text)
	local focus = self:GetRelativeFocus(point(0, 0), "next") or self
	if focus then
		-- select the highlighted text in the first child edit control
		local text_controls = get_children_of_classes(self, nil, "XEditableText")
		if #text_controls == 0 then
			if text then
				focus:SetFocus()
			end
			return focus
		end
		
		-- this needs to be called after desktop layout (the edit control isn't properly initialized before that)
		CreateRealTimeThread(function(text_controls, focus)
			if self.window_state == "destroying" then return end
			for _, ctrl in ipairs(text_controls) do
				if text and ctrl:SelectFirstOccurence(text, "ignore_case") then
					ctrl:SetFocus()
					return
				end
				ctrl:ClearSelection()
			end
			if text then
				focus:SetFocus()
			end
		end, text_controls, focus)
	end
	return focus
end

---
--- Detaches the `GedPropEditor` instance from its parent and resets the `last_set_value` flag.
---
--- This function is typically called when the `GedPropEditor` instance is being reused, to ensure it is in a clean state before being reused.
---
--- @param self GedPropEditor The `GedPropEditor` instance.
---
function GedPropEditor:DetachForReuse()
	self:SetParent(false)
	self.last_set_value = false
end

---
--- Handles keyboard shortcuts for the `GedPropEditor` instance.
---
--- If the "Escape" shortcut is pressed and the property is not read-only, this function reverts the changes from the UI, but temporarily sets the new value so the user can use "undo" to get the discarded value back.
---
--- @param self GedPropEditor The `GedPropEditor` instance.
--- @param shortcut string The keyboard shortcut that was pressed.
--- @param source any The source of the shortcut.
--- @param ... any Additional arguments.
--- @return string "break" to indicate the shortcut has been handled.
---
function GedPropEditor:OnShortcut(shortcut, source, ...)
	if shortcut == "Escape" and not self.prop_meta.read_only and self.SendValueToGame ~= GedPropEditor.SendValueToGame then
		-- reverts the changes from the UI, but temporarily sets the new value so the user can use "undo" to get the discarded value back
		self.panel:SetFocus()
		local value = self:GetProp()
		self:SendValueToGame()
		self:SetProp(value, "force")
		return "break"
	end
end


----- GedPropScript

GedPropEditors["script"] = "GedPropScript"

DefineClass.GedPropScript = {
	__parents = { "GedPropEmbeddedObject" },
}

---
--- Initializes the `GedPropScript` instance.
---
--- This function sets up the UI elements for the script property editor, including buttons for creating/editing the script, copying the script, and pasting a script. It also creates a scrollable text area to display the script.
---
--- @param self GedPropScript The `GedPropScript` instance.
--- @param parent any The parent UI element.
--- @param context any The context for the property editor.
--- @param prop_meta table The metadata for the property being edited.
---
function GedPropScript:Init(parent, context, prop_meta)
	local edit_button = self.idCreateItemButton
	edit_button:SetParent(self.idLabelHost)
	edit_button:SetIcon("CommonAssets/UI/Ged/explorer.tga")
	edit_button:SetRolloverText("Edit script")
	edit_button:SetZOrder(-2)
	edit_button.OnPress = function()
		self.panel.app:Op("GedCreateOrEditScript", self.panel.context, self.prop_meta.id, self.prop_meta.class)
	end
	
	self.idCopyButton:SetParent(self.idLabelHost)
	self.idCopyButton:SetZOrder(0)
	self.idCopyButton.OnPress = function(button)
		self.panel.app:Op("GedNestedObjCopy", self.panel.context, self.prop_meta.id, self.prop_meta.class)
	end
	self.idPasteButton:SetParent(self.idLabelHost)
	self.idPasteButton:SetZOrder(-1)
	self.idPasteButton.OnPress = function(button)
		self.panel.app:Op("GedNestedObjPaste", self.panel.context, self.prop_meta.id, self.prop_meta.class)
		self.panel.app:Op("GedCreateOrEditScript", self.panel.context, self.prop_meta.id, self.prop_meta.class)
	end
	
	self.idLabelHost:SetDock("top")
	XScrollArea:new({
		Id = "idEditHost",
		IdNode = false,
		VScroll = "idScroll",
		MaxHeight = 160,
		BorderWidth = 1,
		CalcBackground = function() return self.idScript:CalcBackground() end,
	}, self)
	XText:new({
		Id = "idScript",
		WordWrap = false,
		BorderWidth = 0,
		TextStyle = "GedScript",
	}, self.idEditHost)
	XSleekScroll:new({
		Id = "idScroll",
		Target = "idEditHost",
		Dock = "right",
		Margins = box(2, 0, 0, 0),
		AutoHide = true,
	}, self.idEditHost)
	self.idScroll:SetHorizontal(false)
end

---
--- Updates the value of the script property editor.
---
--- If the property is undefined, the script text is set to "Undefined" and the editor is disabled. The copy button is also hidden.
---
--- Otherwise, the script text is set to the property value. The editor is enabled if the property does not start with "empty", and the copy button is visible if the property does not start with "empty".
---
--- Finally, the base class's UpdateValue method is called.
---
--- @param self GedPropScript The script property editor instance.
function GedPropScript:UpdateValue()
	local prop = self:GetProp()
	if prop == Undefined() then
		self.idScript:SetText("Undefined")
		self.idScript:SetEnabled(false)
		self.idCopyButton:SetVisible(false)
		GedPropEditor.UpdateValue(self)
		return
	end
	self.idScript:SetText(prop)
	self.idScript:SetEnabled(not prop:starts_with("empty"))
	self.idCopyButton:SetVisible(not prop:starts_with("empty"))
	GedPropEditor.UpdateValue(self)
end


----- GedPropHelp

GedPropEditors["help"] = "GedPropHelp"
GedPropEditors["documentation"] = "GedPropHelp"
DefineClass.GedPropHelp = {
	__parents = { "GedPropEditor" },
}

---
--- Initializes the GedPropHelp property editor.
---
--- If the `help` property is defined and not empty, a text element is created and its text is set to the `help` property value.
--- The label host is set to be invisible and docked to "ignore".
---
--- @param self GedPropHelp The GedPropHelp instance.
--- @param parent table The parent object.
--- @param context table The context object.
--- @param prop_meta table The property metadata.
function GedPropHelp:Init(parent, context, prop_meta)
	self.idLabelHost:SetDock("ignore")
	self.idLabelHost:SetVisible(false)
	if prop_meta.help ~= Undefined() and (prop_meta.help or "") ~= "" then
		XText:new({
			Dock = "top",
			Id = "idHelp",
			Padding = box(2, 2, 2, 0),
		}, self)
		self.idHelp:SetText(prop_meta.help)
		XWindow:new({
			Dock = "top",
			MaxHeight = 1,
			MinHeight = 1,
			Margins = box(7, 0, 7, 3),
			Background = RGB(128, 128, 128),
		}, self)
	end
	self.RolloverText = nil
end


----- GedPropText

GedPropEditors["text"] = "GedPropText"
GedPropEditors["prop_table"] = "GedPropText"
DefineClass.GedPropText = {
	__parents = { "GedPropEditor" },
	text_value = false,
	update_thread = false,
	single_line_edit_template = "XEdit",
}

---
--- Initializes the GedPropText property editor.
---
--- This function sets up the UI elements for the GedPropText editor, which can be either a single-line or multi-line text input. The specific configuration is determined by the `lines` property in the `prop_meta` table.
---
--- If `lines` is set, a multi-line editor is created with a vertical scroll bar. Otherwise, a single-line editor is created using the `CreateSingleLineEditor` function.
---
--- The editor is configured with various properties from the `prop_meta` table, such as `max_len`, `wordwrap`, `text_style`, and `allowed_chars`. Plugins can also be added to the editor, such as a spellcheck plugin or a code editor plugin.
---
--- The editor is also set to be read-only or have auto-select-all behavior based on the `prop_meta` settings.
---
--- If `realtime_update` is set and the editor is not read-only, a separate update thread is created to continuously check for changes in the editor and send the updated value to the game.
---
--- @param self GedPropText The GedPropText instance.
--- @param parent table The parent object.
--- @param context table The context object.
--- @param prop_meta table The property metadata.
function GedPropText:Init(parent, context, prop_meta)
	local lines = prop_meta.lines or self.lines
	if lines then
		self.idLabelHost:SetDock("top")
		XWindow:new({
			Id = "idEditHost",
			BorderWidth = 1,
			CalcBackground = function() return self.idEdit:CalcBackground() end,
		}, self)
		XMultiLineEdit:new({
			Id = "idEdit",
			VScroll = "idScroll",
			MinVisibleLines = lines,
			MaxVisibleLines = Max(prop_meta.max_lines or self.max_lines or 10, lines),
			MaxLen = prop_meta.max_len,
			WordWrap = prop_meta.wordwrap,
			TextStyle = prop_meta.text_style,
			Filter = prop_meta.allowed_chars or ".",
			NewLine = "\n",
			BorderWidth = 0,
		}, self.idEditHost)
		XSleekScroll:new({
			Id = "idScroll",
			Target = "idEdit",
			Dock = "right",
			Margins = box(2, 0, 0, 0),
			AutoHide = true,
		}, self.idEditHost)
		self.idScroll:SetHorizontal(false)
	else
		self:CreateSingleLineEditor(prop_meta)
	end
	local plugins = {}
	if prop_meta.translate then
		plugins[#plugins + 1] = "XSpellcheckPlugin"
	end
	if prop_meta.code then
		plugins[#plugins + 1] = "XCodeEditorPlugin"
	end
	self.idEdit:SetTranslate(prop_meta.translate or false)
	self.idEdit:SetPlugins(plugins)
	self.idEdit:SetEnabled(not prop_meta.read_only)
	self.idEdit:SetAutoSelectAll((prop_meta.read_only or prop_meta.auto_select_all) and not prop_meta.no_auto_select)
	if prop_meta.realtime_update and not prop_meta.read_only then
		self.update_thread = self:CreateThread("update_thread", self.UpdateThread, self)
	end
end

--- Creates a single line editor for a property in the GED (Game Editor) UI.
---
--- @param prop_meta table The property metadata.
--- @return XEdit The created single line editor.
function GedPropText:CreateSingleLineEditor(prop_meta)
	return XEdit:new({
		Id = "idEdit",
		VAlign = "center",
		TextStyle = prop_meta.text_style,
		Filter = prop_meta.allowed_chars or ".",
	}, self)
end

---
--- Reassigns the focus order of the idEdit element to the specified x and y coordinates.
---
--- @param x number The x coordinate to set the focus order to.
--- @param y number The y coordinate to set the focus order to.
--- @return number The next y coordinate to use for focus order.
function GedPropText:ReassignFocusOrders(x, y)
	self.idEdit:SetFocusOrder(point(x, y))
	return y + 1
end

---
--- Runs a thread that periodically checks if the idEdit element has focus and its text differs from the current text_value.
--- If so, it sends the current text value to the game.
---
--- This thread runs continuously until the GedPropText object is destroyed.
---
--- @function GedPropText:UpdateThread
--- @return nil
function GedPropText:UpdateThread()
	while true do
		Sleep(250)
		if (self.idEdit:IsFocused() and self.idEdit:GetText() ~= self.text_value) then
			self:SendValueToGame()
		end
	end
end

---
--- Updates the value of the GedPropText editor.
---
--- If the editor is not focused and the text value has not changed, this function will:
--- - Get the current property value
--- - Convert the property value to text using the `ConvertToText` function
--- - Set the text value and hint in the editor
--- - Update the `text_value` field
---
--- If the editor is focused and the text value has changed, this function will not update the value.
---
--- This function also calls the `UpdateValue` function of the parent `GedPropEditor` class.
---
--- @function GedPropText:UpdateValue
--- @return nil
function GedPropText:UpdateValue()
	if not (self.idEdit:IsFocused() and self.idEdit:GetText() ~= self.text_value) then
		local prop = self:GetProp()
		local translate = self.prop_meta.translate
		local text
		if prop == Undefined() then
			text = ""
			self.idEdit:SetHint(translate and Untranslated("Undefined") or "Undefined")
		elseif prop == false then
			text = ""
			self.idEdit:SetHint(translate and Untranslated("false") or "false")
		else
			text = self:ConvertToText(prop) or ""
			self.idEdit:SetHint("")
		end
		self.text_value = text
		self.idEdit:SetText(text)
	end
	GedPropEditor.UpdateValue(self)
end

---
--- Handles keyboard shortcuts for the GedPropText editor.
---
--- If the "Enter" or "Ctrl-Enter" shortcut is pressed and the property is not read-only, this function will send the current value of the editor to the game.
---
--- Otherwise, this function will call the `OnShortcut` function of the parent `GedPropEditor` class.
---
--- @param shortcut string The name of the keyboard shortcut that was pressed.
--- @param source any The source of the keyboard shortcut.
--- @param ... any Additional arguments passed to the shortcut handler.
--- @return string|nil If "break" is returned, the shortcut handling is stopped. Otherwise, the result of the parent `GedPropEditor:OnShortcut` call is returned.
function GedPropText:OnShortcut(shortcut, source, ...)
	if (shortcut == "Enter" or shortcut == "Ctrl-Enter") and not self.prop_meta.read_only then -- set
		self:SendValueToGame()
		return "break"
	end
	return GedPropEditor.OnShortcut(self, shortcut, source, ...)
end

--- Sends the current value of the GedPropText editor to the game.
---
--- This function first calls the `SetValueFromText` function to update the property value based on the text in the editor. It then sends the updated value to the game.
---
--- @function GedPropText:SendValueToGame
--- @return nil
function GedPropText:SendValueToGame()
	self:SetValueFromText()
end

---
--- Sets the value of the GedPropText editor based on the text in the input field.
---
--- This function first trims any leading or trailing spaces from the input text, if the `trim_spaces` property is not set to `false`. It then converts the input text to the appropriate value for the property, using the `ConvertFromText` function.
---
--- If the converted value is valid, it is set as the property value using the `SetProp` function. The `text_value` field is also updated with the converted text.
---
--- If the converted value is invalid (e.g. a function doesn't compile), the function returns without updating the value or text.
---
--- If the `no_text_update` parameter is falsy, the function will also update the text in the input field to match the converted value, using the `ConvertToText` function.
---
--- @param no_text_update boolean (optional) If true, the function will not update the text in the input field.
--- @return nil
function GedPropText:SetValueFromText(no_text_update)
	local text = self.idEdit:GetText()
	if type(text) == "string" and self.prop_meta.trim_spaces ~= false and string.trim_spaces(text) ~= text then
		text = string.trim_spaces(text)
		if rawget(self, "idEdit") and not no_text_update then
			self.idEdit:SetText(text)
		end
	end
	
	if text ~= self.text_value then
		local value, is_invalid, recalc_text = self:ConvertFromText(text)
		if is_invalid then
			return -- e.g. when a function doesn't compile, we neither update nor revert the value
		end
		
		if value ~= nil then
			if recalc_text then
				text = self:ConvertToText(value)
			end
			self.text_value = text
			self:SetProp(value)
		end
		if (value == nil or recalc_text) and rawget(self, "idEdit") and not no_text_update then
			self.idEdit:SetText(self.text_value)
		end
	end
end

---
--- Converts the given value to a string representation based on the property metadata.
---
--- If the `translate` property is set in the `prop_meta`, this function will use the `GedPropValueToT` function to convert the value to a string. Otherwise, it will convert the value to a string directly, or return an empty string if the value is not a string.
---
--- @param value any The value to be converted to a string.
--- @param prop_meta table (optional) The property metadata. If not provided, the `self.prop_meta` will be used.
--- @return string The string representation of the value.
function GedPropText:ConvertToText(value, prop_meta)
	prop_meta = prop_meta or self.prop_meta
	return prop_meta.translate and GedPropValueToT(value) or type(value) == "string" and value or ""
end

---
--- Converts the given value to a property value based on the property metadata.
---
--- If the `translate` property is set in the `prop_meta`, this function will use the `GedTToPropValue` function to convert the value. Otherwise, it will return the value as-is.
---
--- @param value any The value to be converted to a property value.
--- @param prop_meta table (optional) The property metadata. If not provided, the `self.prop_meta` will be used.
--- @return any The converted property value.
function GedPropText:ConvertFromText(value, prop_meta)
	prop_meta = prop_meta or self.prop_meta
	return prop_meta.translate and GedTToPropValue(value, prop_meta.default) or value
end

---
--- Detaches the GedPropText instance for reuse, resetting the `text_value` field and calling the `DetachForReuse` method of the parent `GedPropEditor` class.
---
--- This method is typically called when the GedPropText instance is no longer needed, to prepare it for reuse in a different context.
---
--- @function GedPropText:DetachForReuse
--- @return nil
function GedPropText:DetachForReuse()
	self.text_value = false
	GedPropEditor.DetachForReuse(self)
end


----- GedPropNumber

GedPropEditors["number"] = "GedPropNumber"
GedPropEditors["radius"] = "GedPropNumber"
GedPropEditors["time"] = "GedPropNumber"
DefineClass.GedPropNumber = {
	__parents = { "GedPropEditor" },
	slider_drag_id = false,
}

---
--- Gets the display scale for the given property metadata.
---
--- If the `scale` property is a string, it will look up the corresponding scale value in the `const.Scale` table. Otherwise, it will use the `scale` property directly, or 1 if it is not provided.
---
--- @param prop_meta table (optional) The property metadata. If not provided, the `self.prop_meta` will be used.
--- @return number The display scale for the property.
function GedPropNumber:GetDisplayScale(prop_meta)
	prop_meta = prop_meta or self.prop_meta
	if type(prop_meta.scale) == "string" then
		return const.Scale[prop_meta.scale] or 1
	else
		return prop_meta.scale or 1
	end
end

---
--- Initializes a GedPropNumber instance with the given parent, context, and property metadata.
---
--- This function sets up the number editor UI, including the text input field, up/down buttons, and optional slider. It also handles various events and behaviors related to the number editor.
---
--- @param parent table The parent UI element for the GedPropNumber instance.
--- @param context table The context in which the GedPropNumber instance is being used.
--- @param prop_meta table The property metadata for the number editor.
--- @return nil
function GedPropNumber:Init(parent, context, prop_meta)
	local step = prop_meta.buttons_step or prop_meta.step or self:GetDisplayScale(prop_meta)
	local add_func = function(multiplier) if type(self:GetProp()) == "number" then self:TrySetProp(self:GetProp() + step * multiplier, "update_scrollbar") end end
	local edit, top, bottom = CreateNumberEditor(self, "idEdit", add_func,
		function(multiplier) if type(self:GetProp()) == "number" then self:TrySetProp(self:GetProp() - step * multiplier, "update_scrollbar") end end,
		prop_meta.slider and "no_buttons"
	)
	if not prop_meta.slider then
		top:SetEnabled(not prop_meta.read_only)
		bottom:SetEnabled(not prop_meta.read_only)
	end
	
	if prop_meta.slider then
		self.idNumberEditor.parent:SetDock("left")
		self.idEdit:SetMinWidth(50)
		
		local function scroll(multiplier)
			if type(self:GetProp()) == "number" then self:TrySetProp(self:GetProp() + step * multiplier, "update_scrollbar") end
		end
		XSleekScroll:new({
			Id = "idScroll",
			Dock = "box",
			Margins = box(2, 2, 2, 2),
			Min = floatfloor((prop_meta.min or 0) / (prop_meta.float and prop_meta.step or 1)),
			Max = floatfloor((prop_meta.max or 0) / (prop_meta.float and prop_meta.step or 1)) + 1, -- compensate for PageSize = 1
			Horizontal = true,
			Target = "node",
			StepSize = floatfloor(not prop_meta.float and prop_meta.step or 1),
			StartScroll = function(...)
				-- Disable updating parent panels while dragging (self.slider_drag_id is a number)
				self.slider_drag_id = AsyncRand()
				return XSleekScroll.StartScroll(...)
			end,
			
			-- Called after letting go of the slider
			OnCaptureLost = function(...)
				self:DeleteThread("scroll_update_thread")
				-- GED -> Game - Update "prop value" in case this would change how the object is displayed in a parent UI panel
				-- Update parent panels (self.slider_drag_id is not a number)
				self.slider_drag_id = false
				self:TrySetProp(self:SliderToPropValue(self.idScroll:GetScroll()), not "update_scrollbar")

				XSleekScroll.OnCaptureLost(...)
			end,
			OnMouseWheelForward = function() if terminal.IsKeyPressed(const.vkControl) then scroll( 1) return "break" end end,
			OnMouseWheelBack    = function() if terminal.IsKeyPressed(const.vkControl) then scroll(-1) return "break" end end,
		}, self)
		self.idScroll:SetEnabled(not prop_meta.read_only)
	end
	if not prop_meta.read_only then
		GedCoordAdjuster:new({
			set_coord = add_func,
			consume_events = false,
			Dock = "box",
			owner = self,
		}, self.idLabel)
	end
	self.idEdit:SetAutoSelectAll((prop_meta.read_only or prop_meta.auto_select_all) and not prop_meta.no_auto_select)
	self.idEdit:SetEnabled(not prop_meta.read_only)
end

--- Reassigns the focus order of the idEdit element to the specified coordinates.
---
--- @param x number The x-coordinate of the new focus order.
--- @param y number The y-coordinate of the new focus order.
--- @return number The new y-coordinate, incremented by 1.
function GedPropNumber:ReassignFocusOrders(x, y)
	self.idEdit:SetFocusOrder(point(x, y))
	return y + 1
end

-- Called repeatedly while holding the slider to update the "prop value"
---
--- Called when the slider is scrolled to a new value.
---
--- This function creates a thread that waits 75 milliseconds before setting the property value to the new slider value.
--- This is done to avoid updating the property value too frequently while the slider is being dragged, which could cause performance issues.
---
--- @param value number The new slider value.
---
function GedPropNumber:OnScrollTo(value)
	if not self:IsThreadRunning("scroll_update_thread") then
		self:CreateThread("scroll_update_thread", function()
			Sleep(75)
			self:TrySetProp(self:SliderToPropValue(self.idScroll:GetScroll()), not "update_scrollbar")
		end)
	end
end

-- Game -> GED - Update the UI with the latest "prop value"
--- Updates the value of the GedPropNumber editor.
---
--- This function is called to update the value of the GedPropNumber editor. It checks if the textbox is focused or if the slider is being held, and if not, it sets the slider value and the edited value in the textbox to the current property value. It then calls the UpdateValue function of the base GedPropEditor class.
---
--- @return nil
function GedPropNumber:UpdateValue()
	-- If the slider is being held => don't update the "slider value"
	local has_slider = self.prop_meta.slider
	if not self.idEdit:IsFocused(true) and not (has_slider and self.desktop:GetMouseCapture() == self.idScroll) then
		local value = self:GetProp()
		self:SetSliderValue(value)
		self:SetEditedValue(value) -- update text in the textbox
	end
	GedPropEditor.UpdateValue(self)
end

-- Called on entering a number manually in the textbox and hitting Enter / Ctrl-Enter
--- Handles keyboard shortcuts for the GedPropNumber editor.
---
--- This function is called when a keyboard shortcut is detected for the GedPropNumber editor. If the shortcut is "Enter" or "Ctrl-Enter", it attempts to set the property value to the edited value and updates the scrollbar. Otherwise, it calls the OnShortcut function of the base GedPropEditor class.
---
--- @param shortcut string The detected keyboard shortcut.
--- @param source any The source of the shortcut.
--- @param ... any Additional arguments passed with the shortcut.
--- @return string|nil Returns "break" if the shortcut was handled, or nil if it was not handled.
function GedPropNumber:OnShortcut(shortcut, source, ...)
	if shortcut == "Enter" or shortcut == "Ctrl-Enter" then -- set
		self:TrySetProp(self:GetEditedValue(), "update_scrollbar")
		return "break"
	end
	return GedPropEditor.OnShortcut(self, shortcut, source, ...)
end

-- Called after the textbox loses focus and sends the edited text value to the game
--- Attempts to set the property value to the edited value and updates the scrollbar.
---
--- This function is called to set the property value to the edited value and update the scrollbar. It calls the `TrySetProp` function, passing the edited value and the string "update_scrollbar" as arguments.
---
--- @return nil
function GedPropNumber:SendValueToGame()
	self:TrySetProp(self:GetEditedValue(), "update_scrollbar")
end

-- Transforms "slider value" to "prop value"
--- Transforms the slider value to the corresponding property value.
---
--- This function is used to transform the slider value to the corresponding property value. If the property has an exponent, the function will apply the exponential transformation to the slider value before returning the final property value.
---
--- @param slider_value number The slider value to be transformed.
--- @return number The transformed property value.
function GedPropNumber:SliderToPropValue(slider_value)
	if not self.prop_meta.slider then
		return slider_value
	end
	
	-- Transform only when using a slider with an exponent
	if self.prop_meta.exponent then
		local exponential_value = LinearToExponential(slider_value, self.prop_meta.exponent, self.idScroll.Min, self.idScroll.Max - 1)
		-- Round to step to avoid extra digits that change the size of the textbox
		slider_value = exponential_value / self.idScroll.StepSize * self.idScroll.StepSize
	end
	
	return slider_value * (self.prop_meta.float and self.prop_meta.step or 1)
end

-- Transforms "prop value" to "slider value"
--- Transforms the property value to the corresponding slider value.
---
--- This function is used to transform the property value to the corresponding slider value. If the property has an exponent, the function will apply the exponential transformation to the property value before returning the final slider value.
---
--- @param prop_value number The property value to be transformed.
--- @return number The transformed slider value.
function GedPropNumber:PropToSliderValue(prop_value)
	-- If the value is undefined => default to min or zero
	if prop_value == Undefined() then
		prop_value = self.prop_meta.min or 0
	end
	
	if not self.prop_meta.slider then
		return prop_value
	end
	
	prop_value = floatfloor(prop_value / (self.prop_meta.float and self.prop_meta.step or 1))
	
	-- Transform only when using a slider with an exponent
	if self.prop_meta.exponent then
		prop_value = ExponentialToLinear(prop_value, self.prop_meta.exponent, self.idScroll.Min, self.idScroll.Max - 1)
	end
	
	return prop_value
end

-- GED -> Game - Performs checks and transformations and sets the "prop value" in the game
--- Attempts to set the property value and update the UI accordingly.
---
--- This function is responsible for setting the property value in the game, updating the text in the textbox, and optionally updating the slider value. It ensures that the property value is within the valid range defined by the `prop_meta` table.
---
--- @param prop_value number The new property value to be set.
--- @param update_scrollbar boolean If true, the slider value will be updated to match the new property value.
function GedPropNumber:TrySetProp(prop_value, update_scrollbar)
	if self.window_state == "destroying" or self.prop_meta.read_only then return end
	if not prop_value then return end
	
	if self.prop_meta.max and prop_value > self.prop_meta.max then
		prop_value = self.prop_meta.max
	end
	if self.prop_meta.min and prop_value < self.prop_meta.min then
		prop_value = self.prop_meta.min
	end

	-- Set the "prop value" in the game
	self:SetProp(prop_value, not "force", self.slider_drag_id)
	-- Set the text in the textbox
	self:SetEditedValue(prop_value)
	
	if update_scrollbar then
		self:SetSliderValue(prop_value)
	end
end

-- Set the "slider value" and update the slider
--- Sets the slider value to match the given property value.
---
--- This function is responsible for transforming the property value to the corresponding slider value, and then updating the slider to display the new value. It ensures that the slider value is within the valid range defined by the `prop_meta` table.
---
--- @param prop_value number The new property value to be set.
function GedPropNumber:SetSliderValue(prop_value)
	-- Note: We can't (reliably) get the prop_value with self:GetProp() 
	-- because the updating thread might not have finished the update yet
	
	if type(prop_value) ~= "number" then
		prop_value = self.prop_meta.min or 0
	end
	
	if self.prop_meta.slider then
		-- Transform "prop value" to "slider value"
		local slider_value = self:PropToSliderValue(prop_value)
		-- Update the slider
		self.idScroll:SetScroll(slider_value)
	end
end

--- Converts a property value to a string representation suitable for display in a number edit control.
---
--- This function takes a property value and an optional property metadata table, and returns a string representation of the value that can be displayed in a number edit control. If the value is `Undefined()`, it returns an empty string and a hint of "Undefined". If the value is not a number, it returns an empty string and the string representation of the value. If the property is a float, it returns the string representation of the number. Otherwise, it formats the number using the display scale specified in the property metadata.
---
--- @param value any The property value to be converted.
--- @param prop_meta table|nil The property metadata table. If not provided, the current property metadata will be used.
--- @return string The string representation of the property value.
--- @return string The hint text for the number edit control.
function GedPropNumber:ToNumberEdit(value, prop_meta)
	prop_meta = prop_meta or self.prop_meta
	if value == Undefined() then
		return "", "Undefined"
	end
	
	local number = tonumber(value)
	if not number then
		return "", tostring(value)
	elseif prop_meta.float then
		return tostring(number), ""
	else
		local display_scale = self:GetDisplayScale(prop_meta)
		return FormatNumberProp(number, display_scale), ""
	end
end

--- Converts a number from a number edit control to the corresponding property value.
---
--- This function takes a number from a number edit control and an optional property metadata table, and converts it to the corresponding property value. If the property is a float, it returns the number as-is. Otherwise, it scales the number using the display scale specified in the property metadata.
---
--- @param num number The number from the number edit control.
--- @param prop_meta table|nil The property metadata table. If not provided, the current property metadata will be used.
--- @return number The corresponding property value.
function GedPropNumber:FromNumberEdit(num, prop_meta)
	prop_meta = prop_meta or self.prop_meta
	num = num * self:GetDisplayScale(prop_meta)
	return prop_meta.float and num or floatfloor(num + 0.5)
end

-- Edit the value in the textbox
--- Sets the edited value of the number property.
---
--- This function takes a property value and updates the text and hint displayed in the number edit control. It converts the property value to a string representation suitable for display in the number edit control using the `ToNumberEdit()` function.
---
--- @param value any The new property value to be set.
function GedPropNumber:SetEditedValue(value)
	local text, hint = self:ToNumberEdit(value)
	self.idEdit:SetHint(hint)
	self.idEdit:SetText(text)
end

--- Gets the edited value of the number property.
---
--- This function retrieves the number value entered in the number edit control, converts it to the corresponding property value using the `FromNumberEdit()` function, and returns the result.
---
--- @return number|nil The edited property value, or `nil` if the input is not a valid number.
function GedPropNumber:GetEditedValue()
	local num = self.idEdit:GetNumber()
	if not num then return nil end
	return self:FromNumberEdit(num)
end

--- Converts a property value to a string representation suitable for display in a number edit control.
---
--- This function takes a property value and converts it to a string representation that can be displayed in a number edit control. It also generates a hint string that can be used to provide additional information about the property value.
---
--- @param value any The property value to be converted.
--- @param prop_meta table|nil The property metadata table. If not provided, the current property metadata will be used.
--- @return string, string The text representation of the property value and the hint string.

function GedPropNumber:ConvertToText(value, prop_meta)
	local text, hint = self:ToNumberEdit(value, prop_meta)
	return text
end

--- Converts a string representation of a number to the corresponding property value.
---
--- This function takes a string value and an optional property metadata table, and converts the string to the corresponding property value. It first converts the string to a number using `tonumber()`, and then passes that number to the `FromNumberEdit()` function to convert it to the final property value.
---
--- @param value string The string representation of the number.
--- @param prop_meta table|nil The property metadata table. If not provided, the current property metadata will be used.
--- @return number The corresponding property value.
function GedPropNumber:ConvertFromText(value, prop_meta)
	return self:FromNumberEdit(tonumber(value), prop_meta)
end

----- GedPropUIImage

GedPropEditors["ui_image"] = "GedPropUIImage"
DefineClass.GedPropUIImage = {
	__parents = { "GedPropBrowse" },
}

local function GetSegments(path)
	path = path:gsub("[\\/]+", '/')
	local segments = {}
	for segment in string.gmatch(path, '[^/]+') do
		table.insert(segments, segment)
	end
	return segments
end

local function GetRelativePath(path, base, game_path)
	path = GetSegments(path)
	base = GetSegments(base)
	game_path = GetSegments(game_path)

	for key, value in ipairs(base) do
		if value ~= path[key] then
			return false
		end
	end

	return table.concat(table.move(path, #base + 1, #path, #game_path + 1, game_path), '/')
end

--- Builds the UI for a given image path.
---
--- This function is responsible for checking if the source image exists in the "svnAssets/Source/" directory, but the built UI texture is missing in the output directory. If this condition is met, it will invoke the "Build UI" process to create the missing texture file.
---
--- The function first checks if the `dont_validate` flag is set in the property metadata, or if the code is running in the mod editor. If either of these conditions is true, the function will return without doing anything.
---
--- Next, it splits the given `path` into its directory, name, and extension components. It then checks if the source image file (with a `.png` extension) exists in the "svnAssets/Source/" directory, but the built texture file (with a `.dds` or `.tga` extension) does not exist in the output directory.
---
--- If this condition is met, the function will create a new thread called "BuildUIThread" and execute the "Build UI" process. This process will generate the missing texture file and open a commit dialog in TortoiseProc to allow the user to commit the changes.
---
--- @param path string The path of the image to be processed.
function GedPropUIImage:BuildUIForPath(path)
	if self.prop_meta.dont_validate or self.in_mod_editor then
		return
	end
	
	-- if the source image exists, but the built UI texture is missing, invoke the build tool to create it
	local dir, name, ext = SplitPath(path)
	if io.exists("svnAssets/Source/" .. dir .. name .. ".png") and                   -- EXISTS in the Source folder
	   not io.exists(dir .. name .. ".dds") and not io.exists(dir .. name .. ".tga") -- BUT NOT in the built files
	then
		local app = self.panel.app
		if not app:IsThreadRunning("BuildUIThread") then
			app:CreateThread("BuildUIThread", function()
				local assets_path = ConvertToOSPath("svnAssets/")
				local project_path = ConvertToOSPath("svnProject/")
				local err, exit_code = AsyncExec(string.format("cmd /c echo Running 'build UI' to include the selected UI image in the build. Please commit the resulting files! & %s/Build UI-win32", project_path))
				if err then assert("Failed to build UI textures" and false) return end
				err, exit_code = AsyncExec(string.format("cmd /c echo Please use the SVN dialog that popped to commit the built UI image files! & TortoiseProc /command:commit /path:%s", assets_path))
				if err then assert("Failed to open commit dialog" and false) end
			end)
		end
	end
end

--- Gets the current file path for the UI image property.
---
--- This function first tries to open the path of the current image, if it exists. If the current image path does not exist, it opens the first folder path. However, it always remaps any "UI/" path to the "svnAssets/Source/UI" folder.
---
--- @param path string The current file path.
--- @return string The remapped file path.
function GedPropUIImage:GetCurrentFilePath(path)
	-- try opening the path of the current image, if it exists; otherwise, open the first folder path
	-- however, always remap UI/ to the source art folder at svnAssets/Source/UI
	local prop = self:GetProp()
	if prop and prop ~= "" and prop ~= Undefined() then
		path = SplitPath(prop)
		path = Platform.developer and path:starts_with("UI/") and "svnAssets/Source/"..path or path
		if not io.exists(path) then
			path = folders[1].game_path
			path = Platform.developer and path:starts_with("UI/") and "svnAssets/Source/"..path or path
		end
		path = ConvertToOSPath(path)
	end
	return path
end

--- Gets the destination folder for UI images.
---
--- This function returns the folder name "Images" where UI image files should be stored.
---
--- @return string The destination folder name for UI images.
function GedPropUIImage:GetSubFolderDest()
	return "Images"
end

--- Initializes a GedPropUIImage editor.
---
--- This function creates a new GedPropUIImage editor with an optional image preview. The image preview is created as a separate XWindow docked to the bottom of the editor, with a maximum size specified by the `image_preview_size` property in the `prop_meta` table.
---
--- @param parent XWindow The parent window for the editor.
--- @param context table The context for the editor.
--- @param prop_meta table The metadata for the property being edited.
function GedPropUIImage:Init(parent, context, prop_meta)
	local image_preview_size = prop_meta.image_preview_size or 0
	local edit_container = self
	if image_preview_size > 0 then
		edit_container = XWindow:new({ Dock = "bottom", ZOrder = -1, Margins = box(0, 3, 0, 0), }, self)
	end
	
	XImage:new({
		Id = "idImage",
		ImageFit = "scale-down",
		MaxWidth = Max(image_preview_size, 28),
		MaxHeight = Max(image_preview_size, 28),
		HandleMouse = true,
		FoldWhenHidden = true,
	}, XWindow:new({
		Dock = "right"
	}, self))
 	self.idImage:SetVisible(false)
	self.idImage:SetRolloverTemplate("GedImageRollover")
end

--- Updates the value of the GedPropUIImage editor.
---
--- This function is called when the value of the property being edited by the GedPropUIImage editor changes. It updates the image preview displayed in the editor based on the new property value.
---
--- If the property value is nil, undefined, or an empty string, the image preview is hidden. Otherwise, the image preview is set to display the new property value and the rollover text is updated to show the full property value.
---
--- @method UpdateValue
--- @return nil
function GedPropUIImage:UpdateValue()
	GedPropBrowse.UpdateValue(self)
	local prop = self:GetProp()
	if not prop or prop == Undefined() or prop == "" then
		self.idImage:SetVisible(false)
	else
		self.idImage:SetImage(prop)
		self.idImage:SetRolloverText(prop)
		self.idImage:SetVisible(true)
	end
end

--- Sets the property value for the GedPropUIImage editor.
---
--- This function is called when the value of the property being edited by the GedPropUIImage editor changes. It updates the image preview displayed in the editor based on the new property value.
---
--- If the property value is not nil, it calls the `BuildUIForPath` function to update the UI for the new property value. If the property value is nil, it clears the property to its default value.
---
--- @param value any The new value for the property being edited.
--- @param ... any Additional arguments to pass to the `GedPropBrowse.SetProp` function.
--- @return nil
function GedPropUIImage:SetProp(value, ...)
	GedPropBrowse.SetProp(self, value, ...)
	if value then -- value is 'nil' if clearing a property to its default value
		self:BuildUIForPath(value)
	end
end

----- GedPropBrowse

GedPropEditors["browse"] = "GedPropBrowse"
DefineClass.GedPropBrowse = {
	__parents = { "GedPropEditor" },
	in_mod_editor = false,
}

local function NormalizeGamePath(path)
	path = path:gsub("\\", "/")
	local final_path = ""
	for segment in path:gmatch("[^/]+") do
		segment = segment:trim_spaces()
		if #segment > 0 then
			final_path = final_path .. segment .. "/"
		end
	end
	return final_path:lower()
end

local function MatchFolder(path, folders)
	path = path or ""
	folders = folders or ""
	if path == "" or #folders == 0 then
		return
	end
	for _, folder in ipairs(folders) do
		if folder.game_path then
			local normalized_path = NormalizeGamePath(path)
			local normalized_folder = NormalizeGamePath(folder.game_path)
			if normalized_path:starts_with(normalized_folder, true) then
				return folder
			end
		end
		if folder.os_path then
			local normalized_path = ConvertToOSPath(path)
			local normalized_folder = ConvertToOSPath(folder.os_path)
			if string.starts_with(normalized_path, normalized_folder, true) then
				return folder
			end
		end
	end
end

local function SelectGamePath(editor, prop_meta, folder, folders, initial)
	local path = editor:OpenBrowseDialog(folder.os_path, prop_meta.filter or "", not prop_meta.allow_missing, false, initial, folders)
	if path then
		local converted_path = ConvertFromOSPath(path, folder.game_path)
		-- 'converted_path' is nil if 'path' is not in 'folder.game_path'
		if path ~= converted_path then
			return converted_path
		else
			local relative = GetRelativePath(converted_path, folder.os_path, folder.game_path)
			if relative then
				return relative
			end
			for _, folder in ipairs(folders) do
				local relative = folder.game_path and GetRelativePath(converted_path, folder.os_path, folder.game_path)
				if relative then
					return relative
				end
			end
			if prop_meta.dont_validate then
				return path
			end
		end
	end
	return false
end

local function SelectOSPath(editor, prop_meta, folder, folders, initial)
	local path = editor:OpenBrowseDialog(folder.os_path, prop_meta.filter or "", not prop_meta.allow_missing, false, initial, folders)
	local path, err = ConvertToOSPath(path)
	local folder_os_path, err2 = ConvertToOSPath(folder.os_path)
	if not (err or err2) and (prop_meta.dont_validate or path and string.starts_with(path, folder_os_path, true)) then
		return path
	elseif not path then
		return false
	end
end

--- Initializes a GedPropBrowse object, which is a UI component for browsing and selecting files or folders in the Ged (Game Editor) application.
---
--- @param parent XWindow The parent window of the GedPropBrowse.
--- @param context table The context of the GedPropBrowse.
--- @param prop_meta table The metadata of the property being edited.
function GedPropBrowse:Init(parent, context, prop_meta)
	self.in_mod_editor = g_GedApp.AppId == "ModEditor"
	local folders = self:GetPropMetaFolder()
	if not prop_meta.read_only and (#folders > 0 or prop_meta.os_path) then
		local buttonswin = XWindow:new({
			Id = "idButtonsHost",
			Dock = "right",
			HAlign = "center",
			LayoutMethod = "HList",
			LayoutHSpacing = 2,
			Padding = box(2, 0, 0, 0),
		}, self)
		XTextButton:new({
			Id = "idButtonBrowse",
			Text = self.in_mod_editor and not prop_meta.os_path and "Import" or "...",
			Enabled = not prop_meta.read_only,
			Dock = "right",
			VAlign = "stretch",
			Margins = box(0, 1, 0, 1),
			MaxWidth = 50,
			BorderWidth = 1,
			BorderHeight = 1,
			Background = RGB(220, 220, 220),
			RolloverBackground = RGB(255, 255, 255),
			RolloverBorderColor = RGB(0, 0, 0),
			PressedBackground = RGB(220, 220, 255),
			PressedBorderColor = RGB(0, 0, 0),
			OnPress = function(button, gamepad)
				self.desktop:SetKeyboardFocus(false)
				local prop = self:GetProp() or ""
				if prop == Undefined() then
					prop = ""
				end
				
				local path, name, ext = SplitPath(prop)
				if prop_meta.os_path or self.in_mod_editor  then
					if (path or "") == "" then
						if type(prop_meta.os_path) == "string" then
							path = ConvertToOSPath(prop_meta.os_path)
						else
							path = ConvertToOSPath(".")
						end
					end
					path = self:OpenBrowseDialog(path, prop_meta.filter or "", not prop_meta.allow_missing)
					if path then
						self:SetProp(path)
					end
				else
					local folder = (path or "") ~= "" and MatchFolder(path, folders) or folders[1]
					local fn = folder.game_path and SelectGamePath or SelectOSPath
					path = fn(self, prop_meta, folder, folders, name .. ext)
					CreateRealTimeThread(function()
						Sleep(10) -- workaround for the SystemInactivate when the OS window is closed resetting the property value back
						if self.window_state ~= "destroying" then
							if path then
								self:SetProp(path)
							elseif path ~= false then
								self:SetPropResult("File is not in any of: " .. (folder.game_path or folder.os_path))
							end
						end
					end)
				end
			end,
			Clip = "self",
		}, buttonswin)
	end
	XEdit:new({
		Id = "idEdit",
		VAlign = "center",
		OnShortcut = function(edit, shortcut, ...)
			if (shortcut == "Enter" or shortcut == "Ctrl-Enter") and not self.prop_meta.read_only then
				self:SendValueToGame()
				return "break"
			end
			return XEdit.OnShortcut(edit, shortcut, ...)
		end,
	}, self):SetEnabled(not prop_meta.read_only)

	local image_preview_size = prop_meta.image_preview_size or 0
	local image_preview = image_preview_size > 0
	XImage:new({
		Id = "idImage",
		ImageFit = "smallest",
		MaxWidth = image_preview_size,
		MaxHeight = image_preview_size,
		Dock = image_preview and "right" or "ignore"
	}, XWindow:new({
		Dock = "bottom"
	}, self))
	self.idImage:SetVisible(image_preview)
end

---
--- Returns the current file path.
---
--- @param path string The current file path.
--- @return string The current file path.
function GedPropBrowse:GetCurrentFilePath(path)
	return path
end

---
--- Reassigns the focus order of the idEdit control to the specified position.
---
--- @param x number The x-coordinate of the focus order position.
--- @param y number The y-coordinate of the focus order position.
--- @return number The next y-coordinate for focus order.
function GedPropBrowse:ReassignFocusOrders(x, y)
	self.idEdit:SetFocusOrder(point(x, y))
	return y + 1
end

---
--- Returns the destination subfolder for the mod file.
---
--- @return string The destination subfolder for the mod file.
function GedPropBrowse:GetSubFolderDest()
	return self.prop_meta.mod_dst or ""
end

---
--- Opens a browse dialog to select a file path.
---
--- @param path string The initial file path to display in the dialog.
--- @param filter string The file filter to use in the dialog.
--- @param exists boolean Whether the selected file must already exist.
--- @param multiple boolean Whether multiple files can be selected.
--- @param initial_file string The initial file to select in the dialog.
--- @return string The selected file path, or an empty string if the dialog was canceled.
---
function GedPropBrowse:OpenBrowseDialog(path, filter, exists, multiple, initial_file)
	if (filter or "") == "" then
		filter = "All files|*.*"
	end
	if self.in_mod_editor and not io.exists(path or "") then
		path = g_GedApp.mod_os_path
	else
		path = self:GetCurrentFilePath(path)
	end
	local file_path = OpenBrowseDialog(path, filter, exists, multiple, initial_file)
	
	if file_path then
		if self.in_mod_editor and not self.prop_meta.os_path then
			local mod_path = ConvertToOSPath(g_GedApp.mod_os_path)
			file_path = ConvertToOSPath(file_path)
			local is_folder = IsFolder(file_path)
			if not file_path:starts_with(mod_path) and not is_folder then
				-- copy file inside the mod folder and use the new path
				local dir, file, ext = SplitPath(file_path)
				local org_file = file
				local dst_path = SlashTerminate(mod_path .. self:GetSubFolderDest())
				AsyncCreatePath(dst_path)
				--find unique file name
				local new_file_path, i
				while true do
					new_file_path = dst_path .. file .. ext
					if io.exists(new_file_path) then
						i = (i or 1) + 1
						file = string.format("%s %d", org_file, i)
					else
						break
					end
				end
				local err = AsyncCopyFile(file_path, new_file_path, "raw")
				if err then
					self:SetPropResult("Failed to import the file: " .. err)
					return ""
				end
				file_path = new_file_path
			end
			file_path = GetRelativePath(file_path, mod_path, g_GedApp.mod_content_path)
		end
	end
	return file_path
end

--- Updates the value of the property editor.
---
--- This function is responsible for updating the value displayed in the property editor's text input field.
--- If the property value is `Undefined()`, the text input field will be set to "Undefined".
--- If the property value is `false`, the text input field will be set to an empty string with the hint "false".
--- Otherwise, the property value will be set as the text of the input field.
---
--- @method UpdateValue
function GedPropBrowse:UpdateValue()
	GedPropEditor.UpdateValue(self)
	local prop = self:GetProp()
	if prop == Undefined() then
		self.idEdit:SetHint("Undefined")
		self.idEdit:SetText("")
	elseif not prop then
		self.idEdit:SetHint("false")
		self.idEdit:SetText("")
	else
		self.idEdit:SetText(prop)
	end
end

--- Returns the folder metadata associated with the property.
---
--- The folder metadata is stored in the `prop_meta.folder` field. If it is not set, an empty table is returned.
---
--- @return table The folder metadata associated with the property.
function GedPropBrowse:GetPropMetaFolder()
	return self.prop_meta.folder or empty_table
end

--- Sends the value of the property editor to the game.
---
--- This function is responsible for updating the value of the property in the game. It first retrieves the text from the property editor's text input field. If the text is empty, the function returns without doing anything.
---
--- Next, the function retrieves the folder metadata associated with the property. If the folder metadata is not empty and the `dont_validate` flag is not set, the function checks if the entered path matches any of the folders in the metadata. If the path does not match, the function sets the property result with an error message listing the valid folders.
---
--- If the path is valid, the function sets the property value using the `SetProp` method.
---
--- @method SendValueToGame
function GedPropBrowse:SendValueToGame()
	local path = self.idEdit:GetText()
	if (path or "") == "" then return end
	local folders = self:GetPropMetaFolder()
	if next(folders) and not self.prop_meta.dont_validate and not MatchFolder(path, folders) then
		local serialize_fn = function(folder) return folder.game_path or folder.os_path end
		local paths = table.concat(table.map(folders, serialize_fn), ", ")
		self:SetPropResult("File is not in any of: " .. paths)
	else
		self:SetProp(path)
	end
end

--- Sets the property value for the GedPropBrowse object.
---
--- If the `prop_meta.force_extension` field is set, this function will ensure the value has the correct file extension. It does this by splitting the value into the path and filename, then appending the extension.
---
--- The function then calls the `GedPropEditor.SetProp` method to actually set the property value.
---
--- @param value string The new value for the property.
--- @param ... any Additional arguments to pass to `GedPropEditor.SetProp`.
function GedPropBrowse:SetProp(value, ...)
	local ext = self.prop_meta.force_extension
	if value and ext then
		local path, filename = SplitPath(value)
		local name = path .. filename
		value = ext == "" and name or ext:starts_with(".") and name..ext or name.."."..ext
	end
	GedPropEditor.SetProp(self, value, ...)
end


----- GedPropPoint

DefineClass.XCoordAdjuster = {
	__parents = { "XWindow" },
	HandleKeyboard = true,
	HandleMouse = true,
	
	set_coord = empty_func,
	consume_events = "break",
	
	OnStartAdjustment = empty_func,

	is_adjusting = false,
	original_prop = false,
	last_cursor_pos = false,
	buffered_cursor_pos = false,
}

--- Cancels the current adjustment operation.
---
--- This function is called when the user is done adjusting the value and wants to cancel the operation. It resets the internal state of the `XCoordAdjuster` object and releases the mouse capture.
function XCoordAdjuster:Done()
	self:CancelAdjustment()
end

--- Handles the mouse button down event for the XCoordAdjuster object.
---
--- If the right mouse button is pressed while the adjustment is in progress, this function will cancel the adjustment operation and release the mouse capture.
---
--- If the left mouse button is pressed, this function will start the adjustment operation. It sets the `is_adjusting` flag, stores the initial cursor position, and captures the mouse. It then calls the `OnStartAdjustment` function to allow subclasses to perform any additional setup.
---
--- @param screen_point Vector2i The screen coordinates of the mouse cursor.
--- @param button string The mouse button that was pressed ("L" for left, "R" for right).
--- @return string The event handling result ("break" to consume the event, or nil to let it propagate).
function XCoordAdjuster:OnMouseButtonDown(screen_point, button)
	if button == "R" and self.is_adjusting then
		self:CancelAdjustment()
		return self.consume_events
	end
	if button == "L" then
		self.is_adjusting = true
		self.last_cursor_pos = screen_point
		self.desktop:SetMouseCapture(self)
		self:OnStartAdjustment()
		return self.consume_events
	end
	return XWindow.OnMouseButtonDown(self, screen_point, button)
end

--- Handles the mouse button up event for the XCoordAdjuster object.
---
--- If the adjustment is in progress (i.e. `is_adjusting` is true), this function will reset the internal state of the `XCoordAdjuster` object, release the mouse capture, and consume the event.
---
--- If the adjustment is not in progress, this function will call the `OnMouseButtonUp` function of the parent `XWindow` class.
---
--- @param screen_point Vector2i The screen coordinates of the mouse cursor.
--- @param button string The mouse button that was released ("L" for left, "R" for right).
--- @return string The event handling result ("break" to consume the event, or nil to let it propagate).
function XCoordAdjuster:OnMouseButtonUp(screen_point, button)
	if self.is_adjusting then
		self.is_adjusting = nil
		self.last_cursor_pos = nil
		self.buffered_cursor_pos = nil
		self.desktop:SetMouseCapture()
		return "break"
	end
	return XWindow.OnMouseButtonUp(self, screen_point, button)
end

---
--- Handles the mouse position event for the XCoordAdjuster object.
---
--- If the adjustment is in progress (i.e. `is_adjusting` is true), this function will:
--- - Check if the Escape key is pressed, and if so, cancel the adjustment operation.
--- - Store the current mouse cursor position in the `buffered_cursor_pos` variable.
--- - If the `adjust_update_thread` is not running, create a new thread that:
---   - Waits 75 milliseconds.
---   - Calculates the difference between the current and last cursor positions.
---   - Calls the `set_coord` function with the calculated difference.
---   - Updates the `last_cursor_pos` variable with the current cursor position.
---   - Clears the `buffered_cursor_pos` variable.
--- - Consume the event to prevent further propagation.
---
--- If the adjustment is not in progress, this function will call the `OnMousePos` function of the parent `XWindow` class.
---
--- @param screen_point Vector2i The screen coordinates of the mouse cursor.
--- @param button string The mouse button that was pressed ("L" for left, "R" for right).
--- @return string The event handling result ("break" to consume the event, or nil to let it propagate).
function XCoordAdjuster:OnMousePos(screen_point, button)
	if self.is_adjusting then
		if terminal.IsKeyPressed(const.vkEsc) then 
			self:CancelAdjustment()
			return self.consume_events
		end
		self.buffered_cursor_pos = screen_point
		if not self:IsThreadRunning("adjust_update_thread") then
			self:CreateThread("adjust_update_thread", function()
				Sleep(75)
				if not self.buffered_cursor_pos then return end
				local diff = self.buffered_cursor_pos:x() - self.last_cursor_pos:x() + self.buffered_cursor_pos:y() - self.last_cursor_pos:y()
				self.set_coord(diff)
				self.last_cursor_pos = self.buffered_cursor_pos
				self.buffered_cursor_pos = nil
			end)
		end
		return self.consume_events
	end
	return XWindow.OnMousePos(self, screen_point, button)
end

---
--- Handles the keyboard key down event for the XCoordAdjuster object.
---
--- If the adjustment is in progress (i.e. `is_adjusting` is true) and the Escape key is pressed, this function will:
--- - Call the `CancelAdjustment` function to cancel the adjustment operation.
--- - Consume the event to prevent further propagation.
---
--- If the adjustment is not in progress, this function will call the `OnKbdKeyDown` function of the parent `XWindow` class.
---
--- @param key integer The key code of the pressed key.
--- @param ... any Additional arguments passed to the event handler.
--- @return string The event handling result ("break" to consume the event, or nil to let it propagate).
function XCoordAdjuster:OnKbdKeyDown(key, ...)
	if self.is_adjusting and key == const.vkEsc then
		self:CancelAdjustment()
		return self.consume_events
	end
	return XWindow.OnKbdKeyDown(self, key, ...)
end

---
--- Cancels the adjustment operation for the `XCoordAdjuster` object.
---
--- If the adjustment is in progress (i.e. `is_adjusting` is true), this function will call the `OnMouseButtonUp` function with the `cursor_start_pos` and the 'L' (left) button.
---
--- @return any The result of calling `OnMouseButtonUp`.
function XCoordAdjuster:CancelAdjustment()
	if self.is_adjusting then
		return self:OnMouseButtonUp(self.cursor_start_pos, 'L')
	end
end

---
--- Handles the event when the XCoordAdjuster object loses capture.
---
--- If the adjustment is in progress (i.e. `is_adjusting` is true), this function will call the `CancelAdjustment` function to cancel the adjustment operation.
---
--- After handling the capture lost event, this function will call the `OnCaptureLost` function of the parent `XWindow` class.
---
--- @param ... any Additional arguments passed to the event handler.
--- @return any The result of calling `XWindow.OnCaptureLost`.
function XCoordAdjuster:OnCaptureLost(...)
	if self.is_adjusting then
		self:CancelAdjustment()
	end
	return XWindow.OnCaptureLost(self, ...)
end

DefineClass.GedCoordAdjuster = {
	__parents = { "XCoordAdjuster" },
	owner = false,
}

---
--- Starts the adjustment operation for the `GedCoordAdjuster` object.
---
--- If the `GedCoordAdjuster` has an `owner` object, this function will disable updating the parent panels while adjusting by setting the `slider_drag_id` property of the owner to a random number.
---
--- This function then calls the `OnStartAdjustment` function of the parent `XCoordAdjuster` class.
---
--- @param ... any Additional arguments passed to the event handler.
--- @return any The result of calling `XCoordAdjuster.OnStartAdjustment`.
function GedCoordAdjuster:OnStartAdjustment(...)
	if self.owner then
		-- Disable updating parent panels while adjusting (self.slider_drag_id is a number)
		self.owner.slider_drag_id = AsyncRand()
	end
	return XCoordAdjuster.OnStartAdjustment(...)
end

---
--- Handles the event when the `GedCoordAdjuster` object loses capture.
---
--- If the `GedCoordAdjuster` has an `owner` object, this function will disable updating the parent panels while adjusting by setting the `slider_drag_id` property of the owner to `false`.
---
--- After handling the capture lost event, this function will call the `OnCaptureLost` function of the parent `XCoordAdjuster` class.
---
--- @param ... any Additional arguments passed to the event handler.
--- @return any The result of calling `XCoordAdjuster.OnCaptureLost`.
function GedCoordAdjuster:OnCaptureLost(...)
	if self.owner then
		self.owner.slider_drag_id = false
	end
	return XCoordAdjuster.OnCaptureLost(self, ...)
end

DefineClass.GedCoordEditor = {
	__parents = { "GedPropEditor" },
	text_value = false,
	update_thread = false,
	coords = false,
	hide_arrows = false,
	hide_icons = false,
	lock_ratio = false,
	accept_os_clipboard_paste = true,
	GatherCoords = empty_func,
}

---
--- Reassigns the focus order of the coordinate input fields in the GedCoordEditor.
---
--- This function iterates through the `coords` table, which contains the coordinate input fields,
--- and sets the focus order of each field based on the provided `x` and `y` coordinates.
--- The function returns the next `y` coordinate to be used for focus order assignment.
---
--- @param x number The starting x coordinate for focus order assignment.
--- @param y number The starting y coordinate for focus order assignment.
--- @return number The next y coordinate to be used for focus order assignment.
function GedCoordEditor:ReassignFocusOrders(x, y)
	for i, coord in ipairs(self.coords) do
		coord:SetFocusOrder(point(x + i - 1, y))
	end
	return y + 1
end

---
--- Runs a background thread that continuously checks if the coordinate input field is focused and has a different value than the stored text value. If so, it sends the updated value to the game.
---
--- This function is called periodically (every 250 milliseconds) to update the coordinate value in the game if the user has modified it in the UI.
---
--- @return nil
function GedCoordEditor:UpdateThread()
	while true do
		Sleep(250)
		if (self.idEdit:IsFocused() and self.idEdit:GetText() ~= self.text_value) then
			self:SendValueToGame()
		end
	end
end

---
--- Gets the concatenated text of all the coordinate input fields in the GedCoordEditor.
---
--- This function iterates through the `coords` table, which contains the coordinate input fields,
--- and concatenates the text of each field into a single string, separated by commas.
---
--- @return string The concatenated text of all the coordinate input fields.
function GedCoordEditor:GetEditText()
	local coords = self.coords
	local len = #coords
	local text = ""
	for i = 1, len do
		text = text .. coords[i]:GetText()
		if i ~= len then
			text = text .. ","
		end
	end
	return text
end

---
--- Sets the text of all the coordinate input fields in the GedCoordEditor.
---
--- This function takes a comma-separated string of coordinate values and sets the text of each
--- coordinate input field to the corresponding value in the string. If the string contains fewer
--- values than the number of coordinate input fields, the remaining fields will be set to an
--- empty string.
---
--- @param text string The comma-separated string of coordinate values.
--- @return nil
function GedCoordEditor:SetEditText(text)
	local coord_iter = string.gmatch(text or "", "[^,]+")
	for _, coord in ipairs(self.coords) do
		local coord_text = coord_iter()
		coord:SetText(coord_text and coord_text:trim_spaces() or "")
	end
end

---
--- Updates the value of the GedCoordEditor.
---
--- This function is called to update the value of the GedCoordEditor. It checks if the input field is focused and if the text in the input field is different from the current text_value. If so, it retrieves the current property value, converts it to text, and sets the text_value and the input field text. If the property value is Undefined or false, it sets the text to an empty string. Finally, it calls the UpdateValue function of the GedPropEditor.
---
--- @return nil
function GedCoordEditor:UpdateValue()
	if not (self.idEdit:IsFocused() and self:GetEditText() ~= self.text_value) then
		local prop = self:GetProp()
		local text
		if prop == Undefined() then
			text = ""
			-- TODO: Hints (false/Undefined)
		elseif prop == false then
			text = ""
		else
			text = self:ConvertToText(prop) or ""
		end
		self.text_value = text
		self:SetEditText(text)
	end
	GedPropEditor.UpdateValue(self)
end

---
--- Handles keyboard shortcuts for the GedCoordEditor.
---
--- This function is called when a keyboard shortcut is triggered in the GedCoordEditor. If the shortcut is "Enter" or "Ctrl-Enter" and the property is not read-only, it calls the `SendValueToGame()` function to update the value in the game. Otherwise, it calls the `OnShortcut()` function of the parent GedPropEditor.
---
--- @param shortcut string The name of the triggered keyboard shortcut.
--- @param source any The source of the keyboard event.
--- @param ... any Additional arguments passed to the function.
--- @return string|nil Returns "break" if the shortcut was handled, otherwise returns nil.
function GedCoordEditor:OnShortcut(shortcut, source, ...)
	if (shortcut == "Enter" or shortcut == "Ctrl-Enter") and not self.prop_meta.read_only then -- set
		self:SendValueToGame()
		return "break"
	end
	return GedPropEditor.OnShortcut(self, shortcut, source, ...)
end

---
--- Sends the current value of the GedCoordEditor to the game.
---
--- This function is called to update the value of the GedCoordEditor in the game. It first calls the `SetValueFromText()` function to ensure the text value is properly formatted and converted to the appropriate property value. This function is typically called when the user has finished editing the coordinate values and wants to apply the changes to the game.
---
--- @return nil
function GedCoordEditor:SendValueToGame()
	self:SetValueFromText()
end

local mock_prop_getter = {
	prop_value = false,
	GetProp = function(self)
		return self.prop_value
	end
}

---
--- Sets the value of the GedCoordEditor from the current text input.
---
--- This function is called to update the value of the GedCoordEditor based on the current text input. It first trims any leading or trailing spaces from the text, if the `trim_spaces` property is not set to `false`. It then converts the text to the appropriate property value using the `ConvertFromText()` function. If the conversion is successful, it updates the `text_value` property and sets the new property value using the `SetProp()` function. If the `lock_ratio` property is set, it calculates the difference between the old and new coordinate values and updates the coordinate values accordingly. Finally, if the text value has changed, it updates the text display using the `SetEditText()` function.
---
--- @param no_text_update boolean (optional) If true, the text display will not be updated.
--- @return nil
function GedCoordEditor:SetValueFromText(no_text_update)
	local text = self:GetEditText()
	if type(text) == "string" and self.prop_meta.trim_spaces ~= false and string.trim_spaces(text) ~= text then
		text = string.trim_spaces(text)
		if rawget(self, "idEdit") and not no_text_update then
			self:SetEditText(text)
		end
	end
	
	if text ~= self.text_value then
		local value, is_invalid, recalc_text = self:ConvertFromText(text)
		if is_invalid then
			return -- e.g. when a function doesn't compile, we neither update nor revert the value
		end
		
		if value ~= nil then
			if recalc_text then
				text = self:ConvertToText(value)
			end
			self.text_value = text
			local added_value
			if self.lock_ratio then
				local old_value = self:GetProp()
				local diff_coord, diff_value
				for _, coord in ipairs(self.coords) do
					mock_prop_getter.prop_value = old_value
					local old_coord_value = coord.getter(mock_prop_getter)
					mock_prop_getter.prop_value = value
					local new_coord_value = coord.getter(mock_prop_getter)
					if old_coord_value ~= new_coord_value then
						if diff_coord then
							diff_coord = nil
							break
						else
							diff_coord = coord
							diff_value = new_coord_value - old_coord_value
						end
					end
				end
				if diff_coord then
					self:AddCoordValue(diff_coord, diff_value)
					added_value = true
				end
			end
			if not added_value then
				self:SetProp(value)
			end
		end
		if (value == nil or recalc_text) and rawget(self, "idEdit") and not no_text_update then
			self:SetEditText(self.text_value)
		end
	end
end

---
--- Detaches the GedCoordEditor instance for reuse.
--- This function resets the `text_value` field to `false` and calls the `DetachForReuse` function of the parent `GedPropEditor` class.
---
--- @param self GedCoordEditor The GedCoordEditor instance to detach.
---
function GedCoordEditor:DetachForReuse()
	self.text_value = false
	GedPropEditor.DetachForReuse(self)
end

local function CreatePointNumberEditor(self, label, gridx, padding_left, prop_meta, no_buttons, adder, getter)
	local step = prop_meta.buttons_step or prop_meta.step or self.display_scale or 1
	local edit = CreateNumberEditor(self.idEdit, "idNumEdit",
		function(multiplier) self:AddCoordValue(edit,  step * multiplier) end,
		function(multiplier) self:AddCoordValue(edit, -step * multiplier) end,
		no_buttons or prop_meta.read_only
	)
	edit:SetDock()
	edit:SetEnabled(not prop_meta.read_only)
	edit.adder = adder
	edit.getter = getter
	edit.parent:SetDock()
	edit.parent:SetGridX(gridx)
	if label and not self.hide_icons then
		local txt = XText:new({
			Dock = "left",
			TextStyle = prop_meta.text_style,
			Padding = box(padding_left, 2, 4, 2),
			HandleKeyboard = false,
			HandleMouse = false,
			Translate = IsT(label),
			ChildrenHandleMouse = true,
			FoldWhenHidden = true,
		}, edit.parent)
		edit.txt = txt
		txt:SetText(label)
		txt:SetEnabled(not prop_meta.read_only)
		if not prop_meta.read_only then
			GedCoordAdjuster:new({
				set_coord = function(multiplier) self:AddCoordValue(edit, step * multiplier) end,
				owner = self,
			}, txt)
		end
	end
	return edit
end

---
--- Initializes a GedCoordEditor instance.
---
--- @param parent XWindow The parent window for the GedCoordEditor.
--- @param context table The context for the GedCoordEditor.
--- @param prop_meta table The property metadata for the GedCoordEditor.
---
function GedCoordEditor:Init(parent, context, prop_meta)
	XWindow:new({
		Id = "idEdit",
		LayoutMethod = "Grid",
		UniformColumnWidth = true,
		HandleMouse = false,
		OnBoxChanged = function(edit)
			local coords = self.coords
			local column_cnt = self.column_cnt or #coords
			if column_cnt == 0 then return end
			local show_arrows = not self.hide_arrows and edit.content_measure_width > 100 * column_cnt
			local show_icon = not self.hide_icons and edit.content_measure_width > 60 * column_cnt
			for _, coord in ipairs(coords) do
				if coord.top_btn then
					coord.top_btn:SetVisible(show_arrows)
				end
				if coord.bottom_btn then
					coord.bottom_btn:SetVisible(show_arrows)
				end
				if coord.icon then
					coord.icon:SetVisible(show_icon)
				end
				if coord.txt then
					coord.txt:SetVisible(show_icon)
				end
			end
		end,
	}, self)
	if prop_meta.realtime_update and not prop_meta.read_only then
		self.update_thread = self:CreateThread("update_thread", self.UpdateThread, self)
	end
	local coords = {}
	self:GatherCoords(coords, prop_meta)
	self.coords = coords

	if prop_meta.lock_ratio then
		local button = XTemplateSpawn("GedToolbarToggleButtonSmall", self)
		button.OnChange = function(_, toggled)
			self.lock_ratio = toggled
		end
		button:SetIcon("CommonAssets/UI/Ged/link.tga")
		button:SetToggled(not prop_meta.read_only)
		button:SetBorderWidth(0)
		button:SetRolloverText("Lock Property Ratio")
		button:SetEnabled(not prop_meta.read_only)
	end
end

--- Adds a coordinate value to the property being edited.
---
--- @param coord table The coordinate object containing the getter and adder functions.
--- @param num number The value to add to the coordinate.
function GedCoordEditor:AddCoordValue(coord, num)
	if self.window_state == "destroying" or self.prop_meta.read_only then return end
	if not coord or not num then return end
	local coord_value = coord.getter(self)
	local prop_value = coord.adder(self, num)
	if not prop_value then return end
	if not self.lock_ratio then
		return self:SetProp(prop_value, not "force", self.slider_drag_id)
	end
	if coord_value == 0 then return end
	local coord_idx = table.find(self.coords, coord)
	if not coord_idx then return end
	mock_prop_getter.prop_value = prop_value
	for i, cur_coord in ipairs(self.coords) do
		if i ~= coord_idx then
			local cur_value = cur_coord.getter(self)
			local ratio = MulDivRound(cur_value, 100, coord_value)
			prop_value = cur_coord.adder(mock_prop_getter, MulDivRound(num, ratio, 100))
		end
	end
	return self:SetProp(prop_value, not "force", self.slider_drag_id)
end

---
--- Gets the display scale for a property.
---
--- @param prop_meta table The property metadata.
--- @return number, number, number The X, Y, and Z display scales.
---
function GedCoordEditor:GetDisplayScale(prop_meta)
	prop_meta = prop_meta or self.prop_meta
	local scale = prop_meta.scale
	if type(scale) == "string" then
		scale = const.Scale[scale]
	end
	if IsPoint(scale) then
		local x, y, z = scale:xyz()
		return x, y, z or 1
	end
	scale = scale or 1
	return scale, scale, scale
end

GedPropEditors["point"] = "GedPropPoint"
DefineClass.GedPropPoint = {
	__parents = { "GedCoordEditor" },
	_2D = false,
}

---
--- Gathers the coordinate editors for a point property.
---
--- @param coords table The table to store the coordinate editors.
--- @param prop_meta table The property metadata.
---
function GedPropPoint:GatherCoords(coords, prop_meta)
	coords[#coords + 1] = CreatePointNumberEditor(self, "X", 1, 0, prop_meta, self.hide_arrows, function(self, num)
		return self:GetProp():AddX(num)
	end, function(self)
		return self:GetProp():x()
	end)
	coords[#coords + 1] = CreatePointNumberEditor(self, "Y", 2, 4, prop_meta, self.hide_arrows, function(self, num)
		return self:GetProp():AddY(num)
	end, function(self)
		return self:GetProp():y()
	end)
	if not self._2D then
		coords[#coords + 1] = CreatePointNumberEditor(self, "Z", 3, 4, prop_meta, self.hide_arrows, function(self, num)
			return self:GetProp():AddZ(num)
		end, function(self)
			return self:GetProp():z()
		end)
	end
end

---
--- Gets the minimum and maximum values for a point property.
---
--- @param self GedPropPoint The GedPropPoint instance.
--- @return number, number, number, number, number, number The minimum X, Y, Z and maximum X, Y, Z values.
---
function GedPropPoint:GetMinMax()
	local min = self.prop_meta.min
	local minx, miny, minz = min, min, min
	if IsPoint(min) then
		minx, miny, minz = min:xyz()
	end
	local max = self.prop_meta.max
	local maxx, maxy, maxz = max, max, max
	if IsPoint(max) then
		maxx, maxy, maxz = max:xyz()
	end
	return minx or min_int, miny or min_int, minz or min_int, maxx or max_int, maxy or max_int, maxz or max_int
end

---
--- Converts a point value to a string representation.
---
--- @param value table The point value to convert.
--- @param prop_meta table The property metadata.
--- @return string The string representation of the point value.
---
function GedPropPoint:ConvertToText(value, prop_meta)
	local result = ""
	if IsPoint(value) then
		local x, y, z = value:xyz()
		local sx, sy, sz = self:GetDisplayScale(prop_meta)
		result = FormatNumberProp(x, sx) .. ", " .. FormatNumberProp(y, sy)
		if z then
			result = result .. ", " .. FormatNumberProp(z, sz)
		end
	end
	return result
end

---
--- Applies a scaling factor to the given x, y, z coordinates and clamps the values within the minimum and maximum bounds.
---
--- @param self GedPropPoint The GedPropPoint instance.
--- @param x number The x coordinate.
--- @param y number The y coordinate.
--- @param z number The z coordinate.
--- @return number, number, number, boolean The scaled and clamped x, y, z coordinates, and a boolean indicating if any of the coordinates were changed.
---
function GedPropPoint:ApplyScale(x, y, z)
	local sx, sy, sz = self:GetDisplayScale()
	x = floatfloor(x * sx + 0.5)
	y = floatfloor(y * sy + 0.5)
	z = z and floatfloor(z * sz + 0.5)
	
	local minx, miny, minz, maxx, maxy, maxz = self:GetMinMax()
	local x0, y0, z0 = x, y, z
	x = Clamp(x, minx, maxx)
	y = Clamp(y, miny, maxy)
	z = z and Clamp(z, minz, maxz)
	local changed = x0 ~= x or y0 ~= y or z0 ~= z
	
	return x, y, z, changed
end

---
--- Converts a string representation of a point value back to a point value.
---
--- @param self GedPropPoint The GedPropPoint instance.
--- @param value string The string representation of the point value.
--- @return table|nil, boolean|nil The point value, or nil if the input is invalid, and a boolean indicating if the value was changed.
---
function GedPropPoint:ConvertFromText(value)
	local changed
	local x, y, z = value:match("^([^,]+),([^,]+),([^,]+)")
	if not x or not y then
		x, y = value:match("^([^,]+),([^,]+)")
	end
	x, y, z = tonumber(x), tonumber(y), tonumber(z)
	if x and y then
		x, y, z, changed = self:ApplyScale(x, y, z)
		return z and point(x, y, z) or point(x, y), nil, changed
	end
end	

GedPropEditors["point2d"] = "GedPropPoint2D"
DefineClass.GedPropPoint2D = {
	__parents = { "GedPropPoint" },
	_2D = true,
}

----- GedPropBox

local function CreatePointNumberIcon(edit, prop_meta, icon, rollover_text, padding_left)
	local image_preview_size = prop_meta.image_preview_size or 0
	local img = XImage:new({
		Id = "idImage",
		Dock = "left",
		Image = icon,
		ImageColor = RGBA(180, 180, 180, 255),
		ImageFit = "scale-down",
		MaxWidth = Max(image_preview_size, 28),
		MaxHeight = Max(image_preview_size, 28),
		HandleMouse = true,
		FoldWhenHidden = true,
		Padding = box(padding_left, 0, 2, 0),
		RolloverTemplate = "GedPropRollover",
		RolloverText = rollover_text,
		RolloverAnchor = "center-top",
	}, edit.parent)
	img:SetEnabled(not prop_meta.read_only)
	return img
end

local function CreateRectPropNumberEditor(self, coords, prop_meta, padding_left, adder, getter)
	local idx = #coords + 1
	local label = table.get(self.labels, idx)
	local text_padding_left = padding_left or (idx == 1 and 0 or 4)
	local coord_editor = CreatePointNumberEditor(self, label, idx, text_padding_left, prop_meta, self.hide_arrows, adder, getter)
	coords[idx] = coord_editor
	local icon = table.get(self.icons, idx)
	if icon then
		local rollover_text = table.get(self.rollover_texts, idx)
		local icon_padding_left = padding_left or (idx == 1 and 0 or 2)
		local icon_window = CreatePointNumberIcon(coords[idx], prop_meta, icon, rollover_text, icon_padding_left)
		coord_editor.icon = icon_window
		if not prop_meta.read_only then
			local step = prop_meta.buttons_step or prop_meta.step or self.display_scale or 1
			GedCoordAdjuster:new({
				set_coord = function(multiplier) self:AddCoordValue(coord_editor, step * multiplier) end,
				owner = self,
			}, icon_window)
		end
	end
	return coord_editor
end

GedPropEditors["box"] = "GedPropBox"
DefineClass.GedPropBox = {
	__parents = { "GedPropPoint" },
	labels = { Untranslated("Min<right>X"), "Y", "Z", Untranslated("Max<right>X"), "Y", "Z" },
	column_cnt = 3,
}

-- TODO: handle 2d boxes as well
---
--- Gathers the coordinates for a 3D box property editor.
---
--- This function creates a series of number editors to allow the user to
--- edit the minimum and maximum coordinates of a 3D box. The editors are
--- laid out in a grid, with the minimum coordinates on the left and the
--- maximum coordinates on the right.
---
--- @param coords table A table to store the created number editors
--- @param prop_meta table Metadata about the property being edited
---
function GedPropBox:GatherCoords(coords, prop_meta)
	local minx_edit = CreateRectPropNumberEditor(self, coords, prop_meta, nil, function(self, num)
		local minx, miny, minz, maxx, maxy, maxz = self:GetProp():xyzxyz()
		return box(minx + num, miny, minz, maxx, maxy, maxz)
	end, function(self)
		return self:GetProp():minx()
	end)
	minx_edit.txt:SetMinWidth(43)
	CreateRectPropNumberEditor(self, coords, prop_meta, nil, function(self, num)
		local minx, miny, minz, maxx, maxy, maxz = self:GetProp():xyzxyz()
		return box(minx, miny + num, minz, maxx, maxy, maxz)
	end, function(self)
		return self:GetProp():miny()
	end)
	CreateRectPropNumberEditor(self, coords, prop_meta, nil, function(self, num)
		local minx, miny, minz, maxx, maxy, maxz = self:GetProp():xyzxyz()
		return box(minx, miny, minz + num, maxx, maxy, maxz)
	end, function(self)
		return self:GetProp():minz()
	end)
	local maxx_edit = CreateRectPropNumberEditor(self, coords, prop_meta, 0, function(self, num)
		local minx, miny, minz, maxx, maxy, maxz = self:GetProp():xyzxyz()
		return box(minx, miny, minz, maxx + num, maxy, maxz)
	end, function(self)
		return self:GetProp():maxx()
	end)
	maxx_edit.txt:SetMinWidth(43)
	CreateRectPropNumberEditor(self, coords, prop_meta, nil, function(self, num)
		local minx, miny, minz, maxx, maxy, maxz = self:GetProp():xyzxyz()
		return box(minx, miny, minz, maxx, maxy + num, maxz)
	end, function(self)
		return self:GetProp():maxy()
	end)
	CreateRectPropNumberEditor(self, coords, prop_meta, nil, function(self, num)
		local minx, miny, minz, maxx, maxy, maxz = self:GetProp():xyzxyz()
		return box(minx, miny, minz, maxx, maxy, maxz + num)
	end, function(self)
		return self:GetProp():maxz()
	end)
	for i = 4, 6 do
		local coord = coords[i].parent
		coord:SetGridX(i - 3)
		coord:SetGridY(2)
	end
end

---
--- Converts a box value to a string representation.
---
--- @param value table The box value to convert.
--- @param prop_meta table Metadata about the property being edited.
--- @return string The string representation of the box value.
---
function GedPropBox:ConvertToText(value, prop_meta)
	if not value then
		return ""
	end
	local sx, sy, sz = self:GetDisplayScale(prop_meta)
	local boxMin = FormatNumberProp(value:minx(), sx) .. ", " .. FormatNumberProp(value:miny(), sx)
	local boxMax = FormatNumberProp(value:maxx(), sy) .. ", " .. FormatNumberProp(value:maxy(), sy)
	if value:IsValidZ() then
		boxMin = boxMin .. ", " .. FormatNumberProp(value:minz(), sz)
		boxMax = boxMax .. ", " .. FormatNumberProp(value:maxz(), sz)
	end
	return boxMin .. ", " .. boxMax
end

---
--- Converts a string representation of a 3D box value to a `box` object.
---
--- @param value string The string representation of the box value.
--- @return box, boolean, boolean The box object, a flag indicating if the X/Y scale changed, and a flag indicating if the Z scale changed.
---
function GedPropBox:ConvertFromText(value)
	if value == "" then
		return
	end
	local changed1, changed2
	local minx, miny, minz, maxx, maxy, maxz = value:match("^([^,]+),([^,]+),([^,]+),([^,]+),([^,]+),([^,]+)")
	minx, miny, minz, maxx, maxy, maxz = tonumber(minx), tonumber(miny), tonumber(minz), tonumber(maxx), tonumber(maxy), tonumber(maxz)
	if minx and miny and minz and maxx and maxy and maxz then
		minx, miny, minz, changed1 = self:ApplyScale(minx, miny, minz)
		maxx, maxy, maxz, changed2 = self:ApplyScale(maxx, maxy, maxz)
		return box(minx, miny, minz, maxx, maxy, maxz), nil, changed1 or changed2
	end
	minx, miny, maxx, maxy = value:match("^([^,]+),([^,]+),([^,]+),([^,]+)")
	minx, miny, maxx, maxy = tonumber(minx), tonumber(miny), tonumber(maxx), tonumber(maxy)
	if minx and miny and maxx and maxy then
		minx, miny, minz, changed1 = self:ApplyScale(minx, miny)
		maxx, maxy, maxz, changed2 = self:ApplyScale(maxx, maxy)
		return box(minx, miny, maxx, maxy), nil, changed1 or changed2
	end
end

----- GedPropRect

GedPropEditors["rect"] = "GedPropRect"
DefineClass.GedPropRect = {
	__parents = { "GedCoordEditor" },
	labels = { "X1", "Y1", "X2", "Y2" },
	icons = false,
	rollover_texts = false,
}

---
--- Gathers the coordinates for a rectangular property editor.
---
--- This function creates four number editors for the left, top, right, and bottom coordinates of a rectangular property.
--- Each number editor is configured with a function to update the corresponding coordinate of the property.
---
--- @param coords table The table to store the created coordinate editors.
--- @param prop_meta table The metadata for the property being edited.
---
function GedPropRect:GatherCoords(coords, prop_meta)
	CreateRectPropNumberEditor(self, coords, prop_meta, nil, function(self, num)
		local l, u, r, b = self:GetProp():xyxy()
		return box(l + num, u, r, b)
	end, function(self)
		return self:GetProp():minx()
	end)
	CreateRectPropNumberEditor(self, coords, prop_meta, nil, function(self, num)
		local l, u, r, b = self:GetProp():xyxy()
		return box(l, u + num, r, b)
	end, function(self)
		return self:GetProp():miny()
	end)
	CreateRectPropNumberEditor(self, coords, prop_meta, nil, function(self, num)
		local l, u, r, b = self:GetProp():xyxy()
		return box(l, u, r + num, b)
	end, function(self)
		return self:GetProp():maxx()
	end)
	CreateRectPropNumberEditor(self, coords, prop_meta, nil, function(self, num)
		local l, u, r, b = self:GetProp():xyxy()
		return box(l, u, r, b + num)
	end, function(self)
		return self:GetProp():maxy()
	end)
end

---
--- Converts a rectangular property value to a string representation.
---
--- @param value table The rectangular property value to convert.
--- @return string The string representation of the rectangular property value.
---
function GedPropRect:ConvertToText(value)
	if not value then return "" end
	local boxMin = value:minx() .. ", " .. value:miny()
	local boxMax = value:maxx() .. ", " .. value:maxy()
	return boxMin .. ", " .. boxMax
end

---
--- Converts a rectangular property value from a string representation.
---
--- @param value string The string representation of the rectangular property value.
--- @return table The rectangular property value.
---
function GedPropRect:ConvertFromText(value)
	local minx, miny, maxx, maxy = value:match("^([^,]+),([^,]+),([^,]+),([^,]+)")
	minx, miny, maxx, maxy = tonumber(minx), tonumber(miny), tonumber(maxx), tonumber(maxy)
	if minx and miny and maxx and maxy then
		return box(minx, miny, maxx, maxy)
	end
end

GedPropEditors["margins"] = "GedPropMargins"
DefineClass.GedPropMargins = {
	__parents = { "GedPropRect" },
	labels = false,
	icons = {
		"CommonAssets/UI/Controls/MarginPadding/Margin_Left",
		"CommonAssets/UI/Controls/MarginPadding/Margin_Top",
		"CommonAssets/UI/Controls/MarginPadding/Margin_Right",
		"CommonAssets/UI/Controls/MarginPadding/Margin_Bottom",
	},
	rollover_texts = {
		"Margin Left",
		"Margin Top",
		"Margin Right",
		"Margin Bottom",
	}
}

GedPropEditors["padding"] = "GedPropPadding"
DefineClass.GedPropPadding = {
	__parents = { "GedPropRect" },
	labels = false,
	icons = {
		"CommonAssets/UI/Controls/MarginPadding/Padding_Left",
		"CommonAssets/UI/Controls/MarginPadding/Padding_Top",
		"CommonAssets/UI/Controls/MarginPadding/Padding_Right",
		"CommonAssets/UI/Controls/MarginPadding/Padding_Bottom",
	},
	rollover_texts = {
		"Padding Left",
		"Padding Top",
		"Padding Right",
		"Padding Bottom",
	}
}

----- GedPropBool

GedPropEditors["bool"] = "GedPropBool"
DefineClass.GedPropBool = {
	__parents = { "GedPropEditor" },
	HAlign = "left",
}

--- Initializes a GedPropBool editor.
---
--- @param parent table The parent object.
--- @param context table The context object.
--- @param prop_meta table The property metadata.
function GedPropBool:Init(parent, context, prop_meta)
	XCheckButton:new({
		Id = "idCheck",
		Icon = "CommonAssets/UI/check-threestate-40.tga",
		IconRows = 3,
		OnChange = function(control, check)
			self:SetProp(check)
		end,
		OnPress = function(self)
			self:SetFocus()
			local row = self.IconRow + 1
			if row > 2 then
				row = 1
			end
			self:SetIconRow(row)
			self:OnRowChange(row)
		end,
		OnRowChange = function(self, row)
			if row ~= 3 then
				XCheckButton.OnRowChange(self, row)
			end
		end,
		Background = RGB(240, 240, 240),
		BorderWidth = 1, 
		BorderColor = RGBA(0, 0, 0, 0),
		DisabledBorderColor = RGBA(0, 0, 0, 0)
	}, self)
	self.idCheck:SetEnabled(not prop_meta.read_only)
end

---
--- Reassigns the focus order of the check button control within the GedPropBool editor.
---
--- @param x number The x-coordinate of the focus order.
--- @param y number The y-coordinate of the focus order.
--- @return number The next y-coordinate for focus order assignment.
function GedPropBool:ReassignFocusOrders(x, y)
	self.idCheck:SetFocusOrder(point(x, y))
	return y + 1
end

---
--- Updates the value of the GedPropBool editor.
---
--- This function is responsible for updating the icon row of the check button control
--- based on the current value of the property. It then calls the base class's
--- `UpdateValue()` function to handle any other updates.
---
--- @param self table The GedPropBool editor instance.
function GedPropBool:UpdateValue()
	local prop = self:GetProp()
	local icon_row
	if prop == true then
		icon_row = 2
	elseif not prop then
		icon_row = 1
	else
		icon_row = 3 -- Undefined()
	end
	self.idCheck:SetIconRow(icon_row)
	GedPropEditor.UpdateValue(self)
end


----- GedPropCombo

GedPropEditors["combo"] = "GedPropCombo"
GedPropEditors["choice"] = "GedPropCombo"
GedPropEditors["dropdownlist"] = "GedPropCombo" -- compatibility
DefineClass.GedPropCombo = {
	__parents = { "GedPropEditor" },
	last_value = false,
}

---
--- Initializes a GedPropCombo editor instance.
---
--- The GedPropCombo editor is used to display and edit properties that have a list of
--- selectable values. It creates an XCombo control to handle the display and selection
--- of the values.
---
--- @param parent table The parent UI element for the GedPropCombo editor.
--- @param context table The context for the GedPropCombo editor.
--- @param prop_meta table The metadata for the property being edited.
function GedPropCombo:Init(parent, context, prop_meta)
	XCombo:new({
		Id = "idCombo",
		Items = false,
		RefreshItemsOnOpen = true,
		DefaultValue = prop_meta.default or "",
		ArbitraryValue = prop_meta.editor == "combo",
		OnValueChanged = function(combo, value)
			self:ComboValueChanged(value)
		end,
		OnRequestItems = function(combo)
			return self.panel.connection:Call("rfnGetPropItems", self.panel.context, self.prop_meta.id)
		end,
		OnMouseWheelForward = function(combo) 
			if terminal.IsKeyPressed(const.vkControl) then
				self:IncrementValue(true)
				return "break"
			end 
		end,
		OnMouseWheelBack = function(combo) 
			if terminal.IsKeyPressed(const.vkControl) then 
				self:IncrementValue(false) 
				return "break" 
			end
		end,
		MRUStorageId = prop_meta.mru_storage_id,
		MRUCount = prop_meta.show_recent_items,
		VirtualItems = true,
	}, self)
	if prop_meta.items_allow_tags then
		self.idCombo:SetListItemTemplate(GetDarkModeSetting() and "XComboXTextListItemDark" or "XComboXTextListItemLight")
	end
	self.idCombo:SetEnabled(not prop_meta.read_only)
end

---
--- Increments the value of the GedPropCombo editor.
---
--- This function is used to increment or decrement the selected value in the GedPropCombo editor.
--- It retrieves the current list of items, finds the index of the current value, and selects the next
--- or previous item in the list. The new value is then set using the `ComboValueChanged` function.
---
--- @param up boolean If true, the value is incremented, otherwise it is decremented.
---
function GedPropCombo:IncrementValue(up)
	if self:GetThread("IncrementValue") then return end
	self:CreateThread("IncrementValue", function(self, up)
		local items = self.idCombo:OnRequestItems() -- might sleep
		local current_item = self.idCombo.value
		local idx = table.find(items, current_item) or 1
		local add = up and -1 or 1
		local next_idx =  1 + ((idx-1) + add) % #items
		local next_item = items[next_idx]
		self:ComboValueChanged(next_item)
	end, self, up)
end

---
--- Reassigns the focus order of the GedPropCombo editor.
---
--- This function is used to set the focus order of the GedPropCombo editor to the specified x and y coordinates.
--- It calls the `SetFocusOrder` method of the `idCombo` member to update the focus order, and then returns the
--- next y coordinate to be used for focus order assignment.
---
--- @param x number The x coordinate for the focus order.
--- @param y number The y coordinate for the focus order.
--- @return number The next y coordinate to be used for focus order assignment.
---
function GedPropCombo:ReassignFocusOrders(x, y)
	self.idCombo:SetFocusOrder(point(x, y))
	return y + 1
end

---
--- Updates the value of the GedPropCombo editor.
---
--- This function is responsible for updating the value of the GedPropCombo editor. It first checks if the combo box is focused and has an arbitrary value that is different from the displayed text. If so, it sets the last_value to the current property value. Otherwise, it sets the combo box value to the last_value. Finally, it calls the UpdateValue function of the base GedPropEditor class.
---
--- @param self GedPropCombo The GedPropCombo instance.
---
function GedPropCombo:UpdateValue()
	local combo = self.idCombo
	combo.Items = false -- list of items might have changed, must be refetched
	if not (combo:IsFocused() and combo.ArbitraryValue and combo:GetValue() ~= combo:GetText()) then
		self.last_value = self:GetProp()
		local combo_value = self.last_value
		self.idCombo:SetValue(combo_value, true)
	end
	GedPropEditor.UpdateValue(self)
end

---
--- Handles the value change event for the GedPropCombo editor.
---
--- This function is called when the value of the GedPropCombo editor is changed. It performs the following actions:
---
--- 1. If the new value is a string and the `prop_meta.trim_spaces` flag is not set to `false`, it trims any leading or trailing spaces from the value.
--- 2. If the trimmed value is different from the original value, it checks if the trimmed value is a new item in the combo box's list of items. If so, it updates the combo box value with the trimmed value.
--- 3. If the new value is different from the last value, it updates the `last_value` property and calls the `SetProp` method to update the property value.
---
--- @param self GedPropCombo The GedPropCombo instance.
--- @param value string The new value of the combo box.
---
function GedPropCombo:ComboValueChanged(value)
	if type(value) == "string" and self.prop_meta.trim_spaces ~= false and string.trim_spaces(value) ~= value then
		local items = self.idCombo.Items
		local is_new = not table.find(items, value)
		if is_new then
			value = string.trim_spaces(value)
			self.idCombo:SetValue(value)
		end
	end
	if self.last_value ~= value then
		self.last_value = value
		self:SetProp(value)
	end
end

---
--- Converts the given value to a string.
---
--- If the value is a string, it is returned as-is. Otherwise, an empty string is returned.
---
--- @param self GedPropCombo The GedPropCombo instance.
--- @param value any The value to convert to a string.
--- @return string The string representation of the value.
---
function GedPropCombo:ConvertToText(value)
	return type(value) == "string" and value or ""
end

---
--- Converts the given value to a string.
---
--- If the value is a string, it is returned as-is. Otherwise, an empty string is returned.
---
--- @param self GedPropCombo The GedPropCombo instance.
--- @param value any The value to convert to a string.
--- @return string The string representation of the value.
---
function GedPropCombo:ConvertFromText(value)
	return value
end

---
--- Detaches the GedPropCombo instance from its parent and updates the MRU (Most Recently Used) list of the combo box.
---
--- This function is called when the GedPropCombo instance is no longer needed and needs to be reused.
---
--- @param self GedPropCombo The GedPropCombo instance to detach.
---
function GedPropCombo:DetachForReuse()
	self.idCombo:UpdateMRUList()
	GedPropEditor.DetachForReuse(self)
end


----- GedPropExpr

GedPropEditors["expression"] = "GedPropExpr"
DefineClass.GedPropExpr = {
	__parents = { "GedPropFunc" },
	max_lines = 10,
}

---
--- Initializes the GedPropExpr instance.
---
--- If the RolloverText property is empty, it sets the RolloverText to a formatted string containing the property ID and parameters.
---
--- @param self GedPropExpr The GedPropExpr instance.
--- @param parent any The parent object.
--- @param context any The context object.
--- @param prop_meta table The property metadata.
---
function GedPropExpr:Init(parent, context, prop_meta)
	if self.RolloverText == "" then
		self.RolloverText = string.format("function %s(%s)", prop_meta.id, prop_meta.params or "self")
	end
end

---
--- Compiles the given expression code and returns any compilation errors.
---
--- @param self GedPropExpr The GedPropExpr instance.
--- @param code string The expression code to compile.
--- @return string Any compilation errors.
---
function GedPropExpr:Compile(code)
	local f, err = CompileExpression(self.prop_meta.id, self.prop_meta.params or "self", code)
	return err
end


----- GedPropFunc

GedPropEditors["func"] = "GedPropFunc"
DefineClass.GedPropFunc = {
	__parents = { "GedPropText" },
	lines = 1,
	max_lines = 20,
}
local code_edit_plugin = { "XCodeEditorPlugin" }

---
--- Updates the property names for the GedPropFunc instance.
---
--- If `internal` is true, the property name is set to the internal ID. Otherwise, the property name is set to the name or ID of the property metadata.
---
--- The property name is formatted as `function <name>(<params>)`, where `<name>` is the property name and `<params>` is the property metadata parameters.
---
--- @param self GedPropFunc The GedPropFunc instance.
--- @param internal boolean Whether to use the internal ID for the property name.
---
function GedPropFunc:UpdatePropertyNames(internal)
	local prop_meta = self.prop_meta
	local prop_name = internal and prop_meta.id or (prop_meta.name or prop_meta.id)
	prop_name = string.format("function %s(%s)", prop_name, prop_meta.params or "self")
	GedPropText.UpdatePropertyNames(self, internal, prop_name)
end

---
--- Checks if the text in the idEdit control is equal to the given value, ignoring leading and trailing spaces.
---
--- @param self GedPropFunc The GedPropFunc instance.
--- @param value string The value to compare against.
--- @return boolean True if the text is equal to the given value, false otherwise.
---
function GedPropFunc:TextEqualTo(value)
	return self.idEdit:GetText():trim_spaces() == (value or ""):trim_spaces()
end

---
--- Initializes a GedPropFunc instance.
---
--- @param self GedPropFunc The GedPropFunc instance.
--- @param parent table The parent window.
--- @param context table The GED context.
--- @param prop_meta table The property metadata.
---
function GedPropFunc:Init(parent, context, prop_meta)
	local prop_name = prop_meta.name or prop_meta.id
	self.idLabel:SetTranslate(false)
	self.idLabel:SetText(string.format("function %s(%s)", prop_meta.name or prop_meta.id, prop_meta.params or "self"))
	
	self.idEdit.OnTextChanged = function(edit)
		-- clear error & set up a delayed update
		self:UpdateCodeEditorUI()
		self:DeleteThread("set_value")
		self:CreateThread("set_value", function()
			Sleep(1500)
			self:UpdateCompilationError(self.idEdit:GetText())
		end)
	end
	self.idEdit:SetPlugins(code_edit_plugin)
	self.idEdit:SetWordWrap(false) -- word wrap causes errors to be displayed on the wrong line
	self.idEdit:SetFoldWhenHidden(true)
	self.idEdit:SetAutoSelectAll((prop_meta.read_only or prop_meta.auto_select_all) and not prop_meta.no_auto_select)
	
	local collapse_button = XTemplateSpawn("GedToolbarToggleButtonSmall", self.idLabelHost)
	collapse_button:SetId("idCollapseButton")
	collapse_button:SetIcon("CommonAssets/UI/Ged/collapse.tga")
	collapse_button:SetRolloverText("Expand / collapse")
	collapse_button.OnPress = function(button)
		self.idEdit:SetVisible(not self.idEdit:GetVisible())
		button:SetToggled(not button:GetToggled())
	end
	
	local live_panel = XWindow:new({
		Id = "idLivePanel",
		Dock = "bottom",
		Padding = box(2, 2, 2, 2),
		FoldWhenHidden = true,
	}, self)
	XText:new({
		Dock = "left",
		TextStyle = "GedHighlight",
		Padding = box(2, 2, 2, 2),
	}, live_panel):SetText("Changes not sent to the game yet")
	XTextButton:new({
		Dock = "right",
		Padding = box(2, 2, 2, 2),
		Padding = box(2, 0, 2, 0),
		BorderWidth = 1,
		VAlign = "center",
		LayoutMethod = "VList",
		OnPress = function() self:SendValueToGame() end,
	}, live_panel):SetText("Send now (Ctrl-Enter)")
	live_panel:SetVisible(false)
end

---
--- Sends the current value of the property editor to the game.
--- This function is called when the "Send now (Ctrl-Enter)" button is pressed in the property editor.
--- It sets the property value in the game and hides the "Changes not sent to the game yet" panel.
---
--- @param self GedPropFunc The instance of the GedPropFunc class.
---
function GedPropFunc:SendValueToGame()
	self:SetValueFromText("no_text_updates")
	if self.window_state == "destroying" then return end
	self.idLivePanel:SetVisible(false)
end

---
--- Compiles the given Lua code with the specified parameters.
---
--- @param code string The Lua code to compile.
--- @return string|nil The error message if the compilation failed, or nil if it succeeded.
---
function GedPropFunc:Compile(code)
	local f, err = CompileFunc(self.prop_meta.id, self.prop_meta.params or "self", code)
	return err
end

---
--- Updates the UI of the code editor plugin with the given error information.
---
--- @param line number The line number of the error.
--- @param msg string The error message.
---
function GedPropFunc:UpdateCodeEditorUI(line, msg)
	local edit = self.idEdit
	local plugin = edit:FindPluginOfKind("XCodeEditorPlugin")
	plugin:SetDimText(self:TextEqualTo(self.prop_meta.default))
	plugin:SetError(line, msg)
	edit:InvalidateMeasure()
	edit:Invalidate()
	
	local value = self:GetProp()
	self.idLivePanel:SetVisible(type(value) ~= "string" or not self:TextEqualTo(value))
end

---
--- Updates the UI of the code editor plugin with the given error information.
---
--- @param line number The line number of the error.
--- @param msg string The error message.
---
function GedPropFunc:UpdateCompilationError(code)
	if self.window_state == "destroying" then return end
	
	local err = self:Compile(code)
	local src, line, msg
	if err then
		src, line, msg = err:match("^([^:]+):([^:]+):(.+)$")
		line = tonumber(line)
		local edit = self.idEdit
		if not edit:IsFocused() then
			edit:SetCursor(line, 0) -- scroll the error into the view
		end
	end
	self:UpdateCodeEditorUI(line, msg)
end

---
--- Converts the given text to Lua code, optionally applying value-to-code conversion based on the provided property metadata.
---
--- @param code string The text to convert to Lua code.
--- @param prop_meta table The property metadata, if available.
--- @return string The converted Lua code.
---
function GedPropFunc:ConvertFromText(code, prop_meta)
	if prop_meta then
		code = ValueToLuaCode(code)
	end
	code = code:match("^(.-)%s*$") or code -- remove trailing whitespace
	if not prop_meta then
		self:UpdateCompilationError(code)
	end
	return code
end

GedPropFunc.ConvertToText = GedPropFunc.ConvertFromText

---
--- Detaches the code editor plugin from the current instance and prepares it for reuse.
---
function GedPropFunc:DetachForReuse()
	self.idEdit:SetPlugins(code_edit_plugin)
	GedPropText.DetachForReuse(self)
end

---
--- Updates the value of the property editor and sets the dimmed state of the code editor plugin based on the property value.
---
--- @param initial boolean Whether this is the initial update of the value.
---
function GedPropFunc:UpdateValue(initial)
	-- don't set the text and reset the cursor due to whitespace changes
	-- (does happen when the game sends the source code back after an edit)
	local value = self:GetProp()
	if initial or type(value) ~= "string" or not self:TextEqualTo(value) then
		GedPropText.UpdateValue(self)
		self.idEdit:FindPluginOfKind("XCodeEditorPlugin"):SetDimText(self:TextEqualTo(self.prop_meta.default))
	end
	if value == "" or value == false or value == Undefined() or (type(value) == "string" and not value:find("\n", 1, true)) then
		self.idEdit:SetVisible(true)
		self.idCollapseButton:SetVisible(false)
		self.idCollapseButton:SetToggled(false)
	else
		self.idCollapseButton:SetVisible(true)
	end
end


----- ColorEditor helper class

DefineClass.ColorEditor = {
	__parents = { "XWindow" },

	properties = {
		{ id = "CopyPaste", editor = "bool", default = true, } ,
		{ id = "Value", editor = "color", default = RGB(0,0,0) },
		{ id = "ReadOnly", editor = "bool", default = false, },
		{ id = "Alpha", editor = "bool", default = true, }
	},
	IdNode = true,
	picker = false,
	editor_id = false,
}

---
--- Called when the color value of the ColorEditor has changed.
---
--- @param color number The new color value.
---
function ColorEditor:OnColorChanged(color)
end

---
--- Called when the user has finished editing the color value in the ColorEditor.
---
function ColorEditor:OnEditingDone()
end

---
--- Sets the color value of the ColorEditor.
---
--- @param color number The new color value.
--- @param dont_notify boolean (optional) If true, the OnColorChanged event will not be triggered.
---
function ColorEditor:SetValue(color, dont_notify)
	if self.window_state == "destroying" then return end
	
	color = color or 0
	if color == Undefined() then
		color = 0
		self.idColorText:SetText("<color 128 128 128>Undefined")
	else
		self.idColorText:SetText("")
	end
	if not self.Alpha then
		color = RGB(GetRGB(color))
	end
	self.idColor:SetBackground(color)
	
	if self.Value ~= color then
		self.Value = color
		--if self.picker then -- Do not update the picker, as RGBs are 1/ With lower precision, 2/ A few ms older than the current value
		--	self.picker:SetColor(self.Value)
		--end
		if not dont_notify then
			self:OnColorChanged(color)
		end
	end
end

---
--- Initializes a ColorEditor instance.
---
--- @param parent table The parent window of the ColorEditor.
--- @param context table The context of the property editor.
--- @param prop_meta table The metadata of the property being edited.
---
function ColorEditor:Init(parent, context, prop_meta)
	if self.CopyPaste then
		local paste_button = XTemplateSpawn("GedToolbarButtonSmall", self)
		paste_button:SetIcon("CommonAssets/UI/Ged/paste.tga")
		paste_button:SetDock("right")
		paste_button:SetRolloverText("Paste")
		paste_button.OnPress = function(button)
			button:SetFocus()
			local value = self:ConvertFromText(GetFromClipboard(1024))
			if value then
				self:SetValue(value)
				self:OnColorChanged(value)
			end
			button:SetFocus(false)
		end
		paste_button.IconScale = point(500, 500)
		
		local copy_button = XTemplateSpawn("GedToolbarButtonSmall", self)
		copy_button:SetIcon("CommonAssets/UI/Ged/copy.tga")
		copy_button:SetDock("right")
		copy_button:SetRolloverText("Copy")
		copy_button.OnPress = function(b)
			local color = self.Value
			CopyToClipboard(self:ConvertToText(color))
		end
		copy_button.IconScale = point(500, 500)
	end

	XWindow:new({
		Id = "idContainer",
		Padding = box(1, 1, 1, 1),
		BorderWidth = 1,
	}, self)

	XFrame:new({
		Id = "idColorBox",
		BorderColor = RGB(0, 0, 0),
		Image = "CommonAssets/UI/checker-pattern-40.tga",
		IdNode = false,
		TileFrame = true,
		ImageScale = point(450, 450)
	}, self.idContainer)
	
	XWindow:new({
		Id = "idColor",
		IdNode = false,
		HandleMouse = true,
		OnMouseButtonUp = function(image, pt, button)
			if button == "L" then
				self:ToggleCombo()
			end
		end,
		OnMouseButtonDown = function(image, pt, button)
			if button == "L" then
				return "break"
			end
		end,
	}, self.idColorBox)
	
	XText:new({ Id = "idColorText", HandleMouse = false }, self.idColorBox)

	local combo_button = XComboButton:new({
		OnPress = function(button)
			button:SetFocus()
			self:ToggleCombo()
			button:SetFocus(false)
		end,
	}, self.idContainer)
	if self.ReadOnly then
		combo_button:SetEnabled(not self.ReadOnly)
	end

	assert(self.editor_id)
	local active_popup = rawget(rawget(_G, "g_GedApp") or self.desktop, "idColorPicker")
	if active_popup and active_popup.owner_color_editor.editor_id == self.editor_id then
		active_popup.owner_color_editor = self
	end
end

---
--- Toggles the color picker popup for the color editor.
---
--- If the color picker is already open, it will be closed. If the editor is in read-only mode, the color picker will not be opened.
---
--- When the color picker is opened, it creates a new popup window with a color picker component. The color picker's `OnColorChanged` callback is set to update the color editor's value. The popup's `Close` function is set to update the color editor's value and call the `OnEditingDone` callback when the popup is closed.
---
--- The popup also sets up event handlers for mouse button up and shortcut (Escape) events to handle closing the popup.
---
--- @param self ColorEditor The color editor instance.
function ColorEditor:ToggleCombo()
	if self:CloseColorPicker() then return end
	if self.ReadOnly then return end
	
	local popup = XPopup:new({
		Id = "idColorPicker",
		owner_color_editor = self,
		OnMouseButtonUp = function(self, pt, button)
			if button == "L" then
				if not self:MouseInWindow(pt) then
					self:Close()
				end
				return "break"
			elseif button == "R" then
				self:Close()
				return "break"
			end
		end,
		DrawOnTop = true,
	}, rawget(_G, "g_GedApp") or self.desktop)
	
	self.picker = XColorPicker:new({
		OnColorChanged = function(picker, color)
			popup.owner_color_editor:SetValue(color)
		end,
		AdditionalComponent = self.Alpha and "alpha" or "none",
		RolloverMode = function()
			local prop_editor = popup.owner_color_editor.parent
			prop_editor.panel.app:Send("GedRpcColorPickerRollover", prop_editor.panel.context, prop_editor.prop_meta.id)
			popup.owner_color_editor:CloseColorPicker()
		end,
	}, popup)
	popup.Close = function(popup)
		self:SetValue(self.picker:GetColor())
		self:OnEditingDone()
		self.picker = false
		XPopup.Close(popup)
	end
	popup.OnShortcut = function(self, shortcut, ...)
		if shortcut == "Escape" then
			self:Close()
			return "break"
		end
		return XPopup.OnShortcut(self, shortcut, ...)
	end	
	
	self.picker:SetColor(self.Value)
	popup:SetAnchor(self.idContainer.box)
	popup:SetAnchorType("drop")
	popup:Open()
	popup:SetModal()
	popup:SetFocus()

	local prop_editor = popup.owner_color_editor.parent
	prop_editor.panel.app:UpdateChildrenDarkMode(popup)
end

---
--- Closes the color picker popup associated with the ColorEditor instance.
---
--- @return boolean true if a popup was closed, false otherwise
function ColorEditor:CloseColorPicker()
	local popup = rawget(rawget(_G, "g_GedApp") or self.desktop, "idColorPicker")
	if popup then
		popup:Close()
		return true
	end
end

---
--- Converts a color value to a string representation.
---
--- @param value table The color value to convert, represented as a table with fields `r`, `g`, `b`, and `a`.
--- @return string The string representation of the color value.
---
function ColorEditor:ConvertToText(value)
	local r, g, b, a = GetRGBA(value)
	return r .. ", " .. g .. ", " .. b .. ", " .. a
end

---
--- Converts a color value from a string representation.
---
--- @param value string The string representation of the color value.
--- @return table The color value represented as a table with fields `r`, `g`, `b`, and `a`.
---
function ColorEditor:ConvertFromText(value)
	return ConvertColorFromText(value)
end


----- GedPropColor

GedPropEditors["color"] = "GedPropColor"
DefineClass.GedPropColor = {
	__parents = { "GedPropEditor" },
	accept_os_clipboard_paste = true,
}

---
--- Initializes a GedPropColor editor with a ColorEditor instance.
---
--- @param parent table The parent window for the editor.
--- @param context table The context for the editor.
--- @param prop_meta table The metadata for the property being edited.
---
function GedPropColor:Init(parent, context, prop_meta)
	local last_update = now()
	ColorEditor:new({
		Id = "idColorEditor",
		editor_id = prop_meta.id .. self.panel.context,
		OnColorChanged = function(editor, color)
			if now() - last_update >= 100 then
				self:SetProp(color)
				last_update = now()
			end
			self:DeleteThread("update_thread")
			self:CreateThread("update_thread", function()
				Sleep(100)
				self:SetProp(color)
			end)
		end,
		OnEditingDone = function(editor, color)
			self:DeleteThread("update_thread")
		end,
		Alpha = prop_meta.alpha,
		ReadOnly = prop_meta.read_only and true,
	}, self)
end

---
--- Reassigns the focus order for a GedPropColor editor.
---
--- @param x number The current x-coordinate of the focus.
--- @param y number The current y-coordinate of the focus.
--- @return number The new y-coordinate of the focus.
---
function GedPropColor:ReassignFocusOrders(x, y)
	return y + 1
end

---
--- Updates the value of the GedPropColor editor.
---
--- This function sets the value of the ColorEditor instance associated with the GedPropColor editor to the current property value. It then calls the UpdateValue function of the parent GedPropEditor class.
---
--- @param self table The GedPropColor editor instance.
---
function GedPropColor:UpdateValue()
	self.idColorEditor:SetValue(self:GetProp(), "dont_notify")
	GedPropEditor.UpdateValue(self)
end

---
--- Converts a color value to a text representation.
---
--- @param value table The color value to convert.
--- @return string The text representation of the color value.
---
function GedPropColor:ConvertToText(value)
	return ColorEditor:ConvertToText(value)
end

---
--- Converts a color value from a text representation.
---
--- @param text string The text representation of the color value.
--- @return table The color value.
---
function GedPropColor:ConvertFromText(text)
	return ColorEditor:ConvertFromText(text)
end

----- GedPropEditorWithSubeditors -- helper to create composite editors

DefineClass.GedPropEditorWithSubeditors = {
	__parents = { "GedPropEditor" },
	editors = false,
	subeditor_container = false,
}

---
--- Initializes a GedPropEditorWithSubeditors instance.
---
--- This function creates a new XWindow instance as the subeditor_container for the GedPropEditorWithSubeditors. The subeditor_container is configured with a vertical list layout, margins, a border width, and padding.
---
--- @param self table The GedPropEditorWithSubeditors instance.
--- @param parent table The parent window for the subeditor_container.
--- @param context table The context for the GedPropEditorWithSubeditors.
--- @param prop_meta table The property metadata for the GedPropEditorWithSubeditors.
---
function GedPropEditorWithSubeditors:Init(parent, context, prop_meta)
	self.subeditor_container = XWindow:new({
		LayoutMethod = "VList",
		Margins = box(0, 2, 0, 0),
		BorderWidth = 1,
		Padding = box(2, 2, 2, 2),
	}, self)
end

---
--- Creates a new sub-editor for the GedPropEditorWithSubeditors instance.
---
--- @param parent table The parent window for the sub-editor. If not provided, the sub-editor_container of the GedPropEditorWithSubeditors instance is used.
--- @param class table The class of the sub-editor to create. Must be a subclass of GedPropEditor.
--- @param meta table The metadata for the sub-editor.
--- @return table The newly created sub-editor.
---
function GedPropEditorWithSubeditors:MakeSubEditor(parent, class, meta)
	parent = parent or self.subeditor_container
	assert(IsKindOf(class, "GedPropEditor"))
	local win = class:new({
		SetProp = function (win, value)
			if not value then value = meta.default end
			win.subeditor_value = value
			self:TrySetProp()
		end,
		GetProp = function(win, new_focus)
			return win.subeditor_value
		end,
		panel = self.panel,
		subeditor_value = meta.default, 
	}, parent, nil, meta)
	self.editors = self.editors or {}
	table.insert(self.editors, win)
	return win
end

---
--- Updates the value of the GedPropEditorWithSubeditors instance.
---
--- This function iterates through all the sub-editors of the GedPropEditorWithSubeditors instance and calls their `UpdateValue()` function. It then calls the `UpdateValue()` function of the GedPropEditor base class.
---
--- @param self table The GedPropEditorWithSubeditors instance.
---
function GedPropEditorWithSubeditors:UpdateValue()
	for _, editor in ipairs(self.editors) do
		editor:UpdateValue()
	end
	GedPropEditor.UpdateValue(self)
end

---
--- Updates the property names of all sub-editors in the GedPropEditorWithSubeditors instance.
---
--- This function iterates through all the sub-editors of the GedPropEditorWithSubeditors instance and calls their `UpdatePropertyNames()` function. It then calls the `UpdatePropertyNames()` function of the GedPropEditor base class.
---
--- @param self table The GedPropEditorWithSubeditors instance.
--- @param internal boolean Whether the update is being triggered internally.
---
function GedPropEditorWithSubeditors:UpdatePropertyNames(internal)
	for _, editor in ipairs(self.editors) do
		editor:UpdatePropertyNames(internal)
	end
	GedPropEditor.UpdatePropertyNames(self, internal)
end


----- GedPropMaterial

GedPropEditors["rgbrm"] = "GedPropMaterial"
DefineClass.GedPropMaterial = {
	__parents = { "GedPropEditorWithSubeditors" },

	color_editor = false,
	roughness_editor = false,
	metallic_editor = false,
}

---
--- Initializes a GedPropMaterial instance with the given parent, context, and property metadata.
---
--- This function creates three sub-editors for the GedPropMaterial instance: a color editor, a roughness editor, and a metallic editor. The values for these sub-editors are initialized based on the default value specified in the property metadata.
---
--- @param self table The GedPropMaterial instance.
--- @param parent table The parent GUI element.
--- @param context table The context for the GUI element.
--- @param prop_meta table The property metadata.
---
function GedPropMaterial:Init(parent, context, prop_meta)
	self.idLabelHost:SetDock("top")
	
	local default = prop_meta.default
	local r, g, b, ro, m = GetRGBRM(default)
	
	self.color_editor = self:MakeSubEditor(false, GedPropColor, {
		editor = "color",
		alpha = false,
		id = "Color_" .. prop_meta.id,
		name = "Color",
		default = RGB(r, g, b),
		read_only = prop_meta.read_only,
	})
	
	self.roughness_editor = self:MakeSubEditor(false, GedPropNumber, {
		max = 127,
		min = -128,
		slider = true,
		default = ro,
		id = "Roughness",
		editor = "number",
		read_only = prop_meta.read_only,
	})
	
	self.metallic_editor = self:MakeSubEditor(false, GedPropNumber, {
		max = 127,
		min = -128,
		slider = true,
		default = m,
		id = "Metallic",
		editor = "number",
		read_only = prop_meta.read_only,
	})
end

---
--- Attempts to set the property value for the GedPropMaterial instance.
---
--- This function retrieves the current values from the sub-editors (color, roughness, and metallic) and constructs a new property value using the RGBRM function. If any of the sub-editor values are undefined, the default values from the property metadata are used instead. The new property value is then set on the GedPropMaterial instance if it differs from the current value.
---
--- @param self table The GedPropMaterial instance.
---
function GedPropMaterial:TrySetProp()
	local rgb, roughness, metallic = self.color_editor.subeditor_value, self.roughness_editor.subeditor_value, self.metallic_editor.subeditor_value
	if rgb == Undefined() then
		rgb = self.color_editor.prop_meta.default
	end
	if roughness == Undefined() then
		roughness = self.roughness_editor.prop_meta.default
	end
	if metallic == Undefined() then
		metallic = self.metallic_editor.prop_meta.default
	end
	local value = RGBRM(rgb, roughness, metallic)
	if value ~= self:GetProp() then
		self:SetProp(value)
	end
end

---
--- Reassigns the focus order for the GedPropMaterial instance.
---
--- This function takes the current x and y coordinates and returns the new y coordinate with an offset of 3.
---
--- @param self table The GedPropMaterial instance.
--- @param x number The current x coordinate.
--- @param y number The current y coordinate.
--- @return number The new y coordinate.
---
function GedPropMaterial:ReassignFocusOrders(x, y)
	return y + 3
end

---
--- Updates the value of the GedPropMaterial instance.
---
--- This function retrieves the current property value and extracts the RGB, roughness, and metallic components. If the property value is undefined, all components are set to the undefined value. Otherwise, the components are extracted using the GetRGBRM3 function.
---
--- The extracted components are then assigned to the corresponding sub-editor values (color_editor, roughness_editor, metallic_editor). Finally, the UpdateValue function of the GedPropEditorWithSubeditors class is called to update the controls.
---
--- @param self table The GedPropMaterial instance.
---
function GedPropMaterial:UpdateValue()
	local value = self:GetProp()
	local rgb, roughness, metallic
	if value == Undefined() then
		rgb = value
		roughness = value
		metallic = value
	else
		rgb, roughness, metallic = GetRGBRM3(value)
	end
	
	self.color_editor.subeditor_value = rgb
	self.roughness_editor.subeditor_value = roughness
	self.metallic_editor.subeditor_value = metallic

	-- update controls
	GedPropEditorWithSubeditors.UpdateValue(self)
end


----- GedPropRange

GedPropEditors["range"] = "GedPropRange"
DefineClass.GedPropRange = {
	__parents = { "GedCoordEditor" },
	labels = { "From", "To" },
	rollovers = false,
}

---
--- Initializes a GedPropRange instance with the given parent, context, and property metadata.
---
--- If the property metadata specifies a slider, this function sets up the slider UI and associated functionality, including:
--- - Hiding the arrows and icons
--- - Setting the layout method to "Box"
--- - Positioning the "From" and "To" sub-editors
--- - Creating custom rollovers for the slider thumb and range
--- - Setting up the XRangeScroll instance with various event handlers
---
--- The XRangeScroll instance is stored in the `idScroll` field of the GedPropRange instance.
---
--- @param self table The GedPropRange instance.
--- @param parent table The parent UI element.
--- @param context table The UI context.
--- @param prop_meta table The property metadata.
---
function GedPropRange:Init(parent, context, prop_meta)
	if prop_meta.slider then
		self.hide_arrows = true
		self.hide_icons = true
		self.idEdit:SetLayoutMethod("Box")
		self.coords[1].parent:SetDock("left")
		self.coords[1]:SetMinWidth(50)
		self.coords[2].parent:SetDock("right")
		self.coords[2]:SetMinWidth(50)

		local function create_custom_rollover(parent, context, GetCustomAnchor)
			context = context or {}
			context.control = parent
			context.anchor = parent.box
			context.RolloverAnchor = "custom"
			local rollover = XTemplateSpawn("GedPropRollover", nil, context)
			rollover.GetCustomAnchor = GetCustomAnchor
			local rollover_text = rollover[1]
			if rollover_text then
				rollover_text:SetMargins(box(2, 0, 2, 0))
			end
			rollover:SetMargins(box(0, 0, 0, 1))
			rollover:Open()
			self.panel.app:UpdateChildrenDarkMode(rollover)
			self.rollovers = self.rollovers or {}
			self.rollovers[#self.rollovers + 1] = rollover
		end

		local function create_rollovers(scroll)
			if self.rollovers then return end
			local max_range = scroll.Max - scroll.Min
			local range_min_from = scroll.Scroll.from - scroll.Min
			local range_min_from_pct = range_min_from * 100 / max_range
			if range_min_from_pct > 15 then
				create_custom_rollover(scroll, { min = true }, function(rollover, x, y, width, height, anchor)
					local margins_x1, margins_y1, margins_x2, margins_y2 = ScaleXY(rollover.scale, rollover.Margins:xyxy())
					x = anchor:minx() - width/2 - margins_x2
					y = anchor:miny() - height - margins_y1 - margins_y2
					return x, y, width, height
				end)
			end
			local range_to_max = scroll.Max - scroll.Scroll.to
			local range_to_max_pct = range_to_max * 100 / max_range
			if range_to_max_pct > 15 then
				create_custom_rollover(scroll, nil, function(rollover, x, y, width, height, anchor)
					local margins_x1, margins_y1, margins_x2, margins_y2 = ScaleXY(rollover.scale, rollover.Margins:xyxy())
					x = anchor:maxx() - width/2 + margins_x2
					y = anchor:miny() - height - margins_y1 - margins_y2
					return x, y, width, height
				end)
			end
			local range_from_to = scroll.Scroll.to - scroll.Scroll.from
			local range_pct = range_from_to * 100 / max_range
			create_custom_rollover(scroll.idThumbLeft, nil, function(rollover, x, y, width, height, anchor)
				local margins_x1, margins_y1, margins_x2, margins_y2 = ScaleXY(rollover.scale, rollover.Margins:xyxy())
				x = anchor:minx() - width/2 + margins_x2
				if range_pct < 20 then
					x = x - width*(20-range_pct)/40
				end
				y = anchor:miny() - height - margins_y1 - margins_y2
				return x, y, width, height
			end)
			create_custom_rollover(scroll.idThumbRight, nil, function(rollover, x, y, width, height, anchor)
				local margins_x1, margins_y1, margins_x2, margins_y2 = ScaleXY(rollover.scale, rollover.Margins:xyxy())
				x = anchor:maxx() - width/2 + margins_x2
				if range_pct < 20 then
					x = x + width*(20-range_pct)/40
				end
				y = anchor:miny() - height - margins_y1 - margins_y2
				return x, y, width, height
			end)
		end

		local function close_rollovers()
			for _, rollover in ipairs(self.rollovers) do
				rollover:Close()
			end
			self.rollovers = nil
		end

		local idScroll = XRangeScroll:new({
			Id = "idScroll",
			Dock = "box",
			Margins = box(2, 2, 2, 2),
			Min = (prop_meta.min or 0),
			Max = (prop_meta.max or 100),
			Horizontal = true,
			Target = "node",
			StepSize = prop_meta.step or 1,
			Scroll = prop_meta.default or nil,
			OnMousePos = function(scroll, ...)
				create_rollovers(scroll)
				return XRangeScroll.OnMousePos(scroll, ...)
			end,
			OnMouseLeft = function(scroll, ...)
				close_rollovers()
				return XRangeScroll.OnMouseLeft(scroll, ...)
			end,
			StartScroll = function(...)
				-- Disable updating parent panels while dragging (self.slider_drag_id is a number)
				self.slider_drag_id = AsyncRand()
				return XRangeScroll.StartScroll(...)
			end,
			
			-- Called after letting go of the slider
			OnCaptureLost = function(...)
				self:DeleteThread("scroll_update_thread")
				-- GED -> Game - Update "prop value" in case this would change how the object is displayed in a parent UI panel
				-- Update parent panels (self.slider_drag_id is not a number)
				self.slider_drag_id = false
				self:TrySetProp(self.idScroll:GetScroll(), not "update_scrollbar")
				close_rollovers()
				XRangeScroll.OnCaptureLost(...)
			end,
			MoveThumb = function(scroll)
				XRangeScroll.MoveThumb(scroll)
				if scroll.mouse_in or scroll.current_pos then
					close_rollovers()
					create_rollovers(scroll)
				end
			end,
			GetRolloverText = function(scroll, context)
				return tostring(context and context.min and scroll.Min or scroll.Max)
			end,
		}, self.idEdit)
		self.idScroll.idThumbLeft.GetRolloverText = function(thumb)
			return tostring(self.idScroll.Scroll.from)
		end
		self.idScroll.idThumbRight.GetRolloverText = function(thumb)
			return tostring(self.idScroll.Scroll.to)
		end
		self.idScroll = idScroll
		idScroll:SetEnabled(not prop_meta.read_only)
	end
end

---
--- Gathers the coordinates for a property range editor in the GED (Graphical Editor) UI.
---
--- @param coords table The table of coordinates to add the range editors to.
--- @param prop_meta table The metadata for the property being edited.
---
function GedPropRange:GatherCoords(coords, prop_meta)
	CreateRectPropNumberEditor(self, coords, prop_meta, nil, function(self, num)
		local prop = self:GetProp()
		if prop.from + num > prop.to then
			num = prop.to - prop.from
		end
		return range(prop.from + num, prop.to)
	end, function(self)
		return self:GetProp().from
	end)
	CreateRectPropNumberEditor(self, coords, prop_meta, nil, function(self, num)
		local prop = self:GetProp()
		if prop.from > prop.to + num then
			num = prop.from - prop.to
		end
		return range(prop.from, prop.to + num)
	end, function(self)
		return self:GetProp().to
	end)
end

-- Called repeatedly while holding the slider to update the "prop value"
---
--- Called when the scroll position changes, to update the property value.
---
--- This function is called when the scroll position changes, and it creates a thread that waits 75 milliseconds before trying to set the property value based on the new scroll position. This is done to avoid updating the property value too frequently while the user is scrolling, which could cause performance issues.
---
--- @param value table The new scroll position.
---
function GedPropRange:OnScrollTo(value)
	if not self:IsThreadRunning("scroll_update_thread") then
		self:CreateThread("scroll_update_thread", function()
			Sleep(75)
			self:TrySetProp(self.idScroll:GetScroll(), not "update_scrollbar")
		end)
	end
end

-- Game -> GED - Update the UI with the latest "prop value"
---
--- Updates the value of the property being edited in the GED (Graphical Editor) UI.
---
--- This function is called to update the value of the property being edited in the GED UI. It checks if the slider is being held by the user, and if so, it updates the slider value to match the current property value. If the slider is not being held, it calls the `GedCoordEditor.UpdateValue` function to update the value.
---
--- @return boolean Whether the value was successfully updated.
---
function GedPropRange:UpdateValue()
	-- If the slider is being held => don't update the "slider value"
	if self.prop_meta.slider and self.desktop:GetMouseCapture() ~= self.idScroll then
		for _, coord in ipairs(self.coords) do
			if not coord:IsFocused(true) then
				local value = self:GetProp()
				self:SetSliderValue(value)
				--self:SetEditedValue(value) -- update text in the textbox
				break
			end
		end
	end
	return GedCoordEditor.UpdateValue(self)
end

---
--- Attempts to set the property value and update the slider value if requested.
---
--- This function is called to set the property value in the GED (Graphical Editor) UI. It first checks if the window is being destroyed or if the property is read-only, and returns if either of these conditions is true. It then checks if the provided property value is valid (i.e., the `from` value is less than or equal to the `to` value), and if so, it calls the `SetProp` function to set the property value. If the `update_scrollbar` parameter is true, it also calls the `SetSliderValue` function to update the slider value.
---
--- @param prop_value table The new property value to set.
--- @param update_scrollbar boolean Whether to update the slider value.
---
function GedPropRange:TrySetProp(prop_value, update_scrollbar)
	if self.window_state == "destroying" or self.prop_meta.read_only then return end
	if not prop_value or prop_value.from > prop_value.to then return end
	self:SetProp(prop_value, not "force", self.slider_drag_id)
	if update_scrollbar then
		self:SetSliderValue(prop_value)
	end
end

---
--- Sets the slider value to the specified property value.
---
--- This function is called to update the slider value in the GED (Graphical Editor) UI. It first checks if the provided property value is a valid range, and if the property has a slider. If either of these conditions is not met, the function returns without doing anything.
---
--- If the conditions are met, the function calls the `SetScroll` method of the `idScroll` object to update the slider value to match the provided property value.
---
--- @param prop_value table The new property value to set the slider to.
---
function GedPropRange:SetSliderValue(prop_value)
	if not IsRange(prop_value) or not self.prop_meta.slider then return end
	self.idScroll:SetScroll(prop_value)
end

---
--- Gets the display scale for the property.
---
--- This function is used to get the display scale for the property being edited in the GED (Graphical Editor) UI. It first checks if a `prop_meta` parameter is provided, and if not, it uses the `prop_meta` property of the current object. It then checks the type of the `scale` property in the `prop_meta` object. If it is a string, it looks up the corresponding value in the `const.Scale` table. If the `scale` property is not found or is not a valid number, the function returns 1 as the default display scale.
---
--- @param prop_meta table (optional) The property metadata to use for getting the display scale.
--- @return number The display scale for the property.
---
function GedPropRange:GetDisplayScale(prop_meta)
	prop_meta = prop_meta or self.prop_meta
	local scale = prop_meta.scale
	if type(scale) == "string" then
		scale = const.Scale[scale]
	end
	return scale or 1
end

---
--- Converts a range value to a string representation.
---
--- This function is used to convert a range value (a table with `from` and `to` fields) to a string representation. It first checks if the provided value is a valid range using the `IsRange` function. If it is, the function calls `GetDisplayScale` to get the display scale for the property, and then uses `FormatNumberProp` to format the `from` and `to` values with the display scale. The formatted values are then concatenated with a comma separator and returned as a string.
---
--- @param value table The range value to convert to a string.
--- @return string The string representation of the range value.
function GedPropRange:ConvertToText(value)
	if IsRange(value) then
		local display_scale = self:GetDisplayScale()
		return FormatNumberProp(value.from, display_scale)  .. ", " .. FormatNumberProp(value.to, display_scale)
	end
	return ""
end

---
--- Converts a string representation of a range value to a table with `from` and `to` fields.
---
--- This function is used to parse a string representation of a range value (a string with two comma-separated numbers) and convert it to a table with `from` and `to` fields. It first extracts the `from` and `to` values from the input string using a regular expression. It then converts the extracted values to numbers and checks if the `from` value is less than or equal to the `to` value. If so, it applies the display scale to the `from` and `to` values, ensuring they are within the valid range for the property. The function returns the converted range value, or `nil` if the input string is not a valid range representation.
---
--- @param value string The string representation of the range value to convert.
--- @return table|nil The converted range value as a table with `from` and `to` fields, or `nil` if the input is not a valid range.
--- @return boolean|nil Whether the range values were changed to fit the valid range.
function GedPropRange:ConvertFromText(value)
	local from, to = value:match("^([^,]+),([^,]+)")
	from, to = tonumber(from), tonumber(to)
	if from and to and from <= to then
		local display_scale = self:GetDisplayScale()
		from = floatfloor(from * display_scale + 0.5)
		to = floatfloor(to * display_scale + 0.5)
		local min = self.prop_meta.min
		local max = self.prop_meta.max
		local changed
		if min and from < min then
			from = min
			changed = true
		end
		if max and to > max then
			to = max
			changed = true
		end
		return range(from, to), nil, changed
	end
end


----- GedPropSet

GedPropEditors["set"] = "GedPropSet"
DefineClass.GedPropSet = {
	__parents = { "GedPropEditor" },

	add_thread = false,
}

---
--- Initializes a new `GedPropSet` instance.
---
--- This function creates a new `XWindow` instance with the specified properties and assigns it to the `idContainer` field of the `GedPropSet` instance. If the `prop_meta.horizontal` field is true, the `idLabelHost` field is set to dock to the top, and the `XWindow` instance is given a border width of 1.
---
--- @param self GedPropSet The `GedPropSet` instance being initialized.
function GedPropSet:Init()
	local win = XWindow:new({
		Dock = "box",
		Id = "idContainer",
		LayoutMethod = "HWrap",
		VAlign = "center",
	}, self)
	if self.prop_meta.horizontal then
		self.idLabelHost:SetDock("top")
		win:SetBorderWidth(1)
	end
end

---
--- Returns the list of items for the `GedPropSet` instance.
---
--- If the `prop_meta.items` field is a set, the function returns a list of the keys in the set. Otherwise, it returns the `prop_meta.items` field as-is.
---
--- @param self GedPropSet The `GedPropSet` instance.
--- @return table The list of items for the `GedPropSet` instance.
function GedPropSet:GetItems()
	local items = self.prop_meta.items or empty_table
	if IsSet(items) or #items == 0 then
		items = table.keys(items, true)
	end
	return items
end

---
--- Updates the value of the `GedPropSet` instance.
---
--- This function deletes all children of the `idContainer` window, then creates a button for each item in the `self:GetItems()` list. If the `self:GetProp()` contains any keys that are not in the `item_keys` list, it creates a button for those keys with the "invalid_item" flag.
---
--- If the `prop_meta.arbitrary_value` field is true, it creates an "Add" button that allows the user to enter a new item to add to the property.
---
--- Finally, it sends an "XWindowRecreated" message and calls the `GedPropEditor.UpdateValue()` function.
---
--- @param self GedPropSet The `GedPropSet` instance.
function GedPropSet:UpdateValue()
	self.idContainer:DeleteChildren()
	local item_keys = {}
	for _, item in ipairs(self:GetItems() or empty_table) do
		self:CreateButton(item)
		item_keys[type(item) == "table" and (item.value or item.id) or item] = true
	end
	for key in pairs(self:GetProp() or empty_table) do
		if not item_keys[key] then
			self:CreateButton(key, nil, "invalid_item")
		end
	end
	if self.prop_meta.arbitrary_value then
		local button = XTextButton:new({
			Text = "Add",
			Dock = "right",
			FoldWhenHidden = true,
			BorderWidth = 1,
			OnPress = function(button)
				self.add_thread = IsValidThread(self.add_thread) or CreateRealTimeThread(function()
					local host = GetActionsHost(self, true)
					local prop_name = (self.prop_meta.name or "") ~= "" and self.prop_meta.name or "tag"
					local new_item, err = host:WaitUserInput("Enter a new " .. prop_name, "")
					if not new_item or new_item == "" then
						self.add_thread = nil
						return
					end
					local prop = table.copy(self:GetProp() or set())
					prop[new_item] = true
					self:SetProp(prop)
					self:UpdateValue()
					self.add_thread = nil
				end)
				XTextButton.OnPress(button)
			end,
		}, self.idContainer)
	end
	Msg("XWindowRecreated", self)
	GedPropEditor.UpdateValue(self)
end

local function GetItemCount(prop)
	local count = 0
	for _, value in pairs(prop) do
		if value ~= nil then
			count = count + 1
		end
	end
	return count
end

local function RemoveOneItem(prop)
	for idx, value in pairs(prop) do
		if value ~= nil then
			prop[idx] = nil
			return
		end
	end
end

---
--- Creates a button for a property set in the GED editor.
---
--- @param item table|string The button item, which can be a table with `text` and `value` fields, or a string.
--- @param parent? table The parent container for the button.
--- @param invalid_item? boolean Whether the button represents an invalid item.
--- @return table The created button.
function GedPropSet:CreateButton(item, parent, invalid_item)
	if type(item) ~= "table" then 
		local str = item
		if type(item) ~= "string" and not IsT(item) then
			str = tostring(item)
		end
		item = { text = str, value = item }
	end
	
	local max_items_in_set = self.prop_meta.max_items_in_set or 0
	local button = XToggleButton:new({
		Text = item.text,
		Toggled = self:GetProp() and self:GetProp()[item.value] and true,
		ToggledBackground = RGB(204, 232, 255),
		RolloverBackground = RGBA(0, 0, 0, 0),
		RolloverAnchor = "live-mouse",
		RolloverTemplate = "GedPropRollover",
		Padding = self.prop_meta.horizontal and box(0, 2, 0, 2) or box(0, 0, 0, 0),
		AltPress = self.prop_meta.three_state,
		CalcBackground = function(button)
			if self.prop_meta.three_state then
				local value
				local prop = self:GetProp()
				if prop then
					value = prop[item.value]
				end
				
				if value == nil then return RGBA(0, 0, 0, 0) end
				local color
				if button.state == "mouse-in" or button:IsFocused() then
					color = value and RGB(0, 128, 0) or RGB(160, 0, 0)
				else
					color = value and RGB(0, 96, 0) or RGB(128, 0, 0)
				end
				return GetDarkModeSetting() and color or color + RGB(80, 80, 80)
			end
			return XToggleButton.CalcBackground(button)
		end,
		OnPress = function(button)
			if self.prop_meta.three_state then
				button:DoToggle(nil, true, false)
				return
			end
			XToggleButton.OnPress(button)
		end,
		OnAltPress = function(button)
			if self.prop_meta.three_state then
				button:DoToggle(nil, false)
				return
			end
			XToggleButton.OnAltPress(button)
		end,
		OnChange = function(button, toggle)
			button:DoToggle(nil, true)
		end,
		DoToggle = function(button, val1, val2, val3)
			button:SetFocus()
			local prop = table.copy(self:GetProp() or set())
			local value = prop[item.value]
			if value == val1 then
				value = val2
			elseif value == val2 then
				value = val3
			elseif val3 == nil or value == val3 then
				value = val1
			end
			if max_items_in_set ~= 0 and max_items_in_set == GetItemCount(prop) then
				RemoveOneItem(prop)
			end
			prop[item.value] = value
			self:SetProp(prop)
			button:Invalidate()
			button:SetFocus(false)
		end,
	}, parent or self.idContainer)
	
	if invalid_item then
		XWindow:new({
			Background = RGB(255, 0, 0),
			Dock = "bottom",
			MinHeight = 2,
			MaxHeight = 2,
		}, button)
	end
	
	button:SetEnabled(not self.prop_meta.read_only)
	if item.help then
		button:SetRolloverText(item.help)
	end
	return button
end

--- Searches for the given `search_text` in the labels of all `XToggleButton` child controls of the `GedPropSet` instance, and highlights the matching text using the `XHighlightTextPlugin.HighlightColor`. Returns `true` if any matching text is found, otherwise delegates to the `GedPropEditor.FindText` method.
---
--- @param search_text string The text to search for.
--- @param highlight_text string The text to highlight in the matching labels.
--- @return boolean True if any matching text is found, false otherwise.
function GedPropSet:FindText(search_text, highlight_text)
	local found = false
	local buttons = get_children_of_classes(self, nil, "XToggleButton")
	for _, button in ipairs(buttons) do
		local label = button.idLabel
		label:HighlightText(highlight_text, XHighlightTextPlugin.HighlightColor, true)
		found = found or search_display_text(label.text, search_text)
	end
	return found or GedPropEditor.FindText(self, search_text, highlight_text)
end


----- GedPropImage

GedPropEditors["image"] = "GedPropImage"
DefineClass.GedPropImage = {
	__parents = { "GedPropEditor" },
	comp_modifier = false,
}

--- Initializes a `GedPropImage` instance.
---
--- This function creates an `XImage` control with the following properties:
--- - `Id = "idImage"`
--- - `ImageFit = (self.prop_meta.img_width or self.prop_meta.img_height) and "largest" or "smallest"`
--- - `HAlign = "center"`
--- - `DrawContent = function(img, clip_rect) self:DrawImageContent(clip_rect) end`
---
--- It also creates an `XLabel` control with the following properties:
--- - `Id = "idErrLabel"`
--- - `Dock = "ignore"`
---
--- These controls are added as children of the `GedPropImage` instance.
function GedPropImage:Init()
	XImage:new({
		Id = "idImage",
		ImageFit = (self.prop_meta.img_width or self.prop_meta.img_height) and "largest" or "smallest",
		HAlign = "center",
		DrawContent = function(img, clip_rect) self:DrawImageContent(clip_rect) end,
	}, self)
	XLabel:new({
		Id = "idErrLabel",
		Dock = "ignore",
	}, self)
end

--- Updates the value of a `GedPropImage` instance.
---
--- This function is responsible for updating the appearance of the `GedPropImage` instance based on the current value of the associated property. It performs the following tasks:
---
--- 1. Checks if the property value is a valid file path. If the file does not exist, it attempts to measure the image dimensions using `UIL.MeasureImage()`.
--- 2. Sets the visibility and docking of the `idImage` and `idErrLabel` controls based on whether the file exists or not.
--- 3. If the file exists, it sets the image of the `idImage` control and applies any additional formatting options specified in the `prop_meta` table (e.g. max width/height, border width, background color).
--- 4. If the file does not exist, it sets the text of the `idErrLabel` control to indicate the missing file.
--- 5. Removes any existing shader modifier on the `idImage` control and adds a new modifier if the `img_draw_alpha_only` property is set.
--- 6. Sets the `base_color_map` property of the `idImage` control.
--- 7. Calls the `UpdateValue()` method of the parent `GedPropEditor` class.
---
--- @return nil
function GedPropImage:UpdateValue()
	local prop = self:GetProp()
	local file_exists = prop ~= Undefined() and prop and io.exists(prop)
	if not file_exists and type(prop) == "string" then
		prop = string.gsub(prop, "\\", "/")
		local width, height = UIL.MeasureImage(prop)
		if width and height and width > 0 and height > 0 then
			file_exists = true
		end
	end
	self.idImage:SetDock(not file_exists and "ignore")
	self.idImage:SetVisible(file_exists)
	self.idErrLabel:SetDock(file_exists and "ignore" or "right")
	self.idErrLabel:SetVisible(not file_exists)
	if file_exists then
		self.idImage:SetImage(prop)
		local meta = self.prop_meta
		if meta.img_size and type(meta.img_size) == "number" and meta.img_size > 0 or meta.img_width or meta.img_height then
			self.idImage.MaxWidth = meta.img_width or meta.img_size
			self.idImage.MaxHeight = meta.img_height or meta.img_size
		end
		if meta.img_box and meta.img_box > 0 then
			self.idImage.BorderWidth = meta.img_box
		end
		if meta.img_back then
			self.idImage.Background = meta.img_back
		end
	else
		self.idErrLabel:SetText(prop ~= Undefined() and "File not found " .. prop or "Undefined")
	end
	if self.comp_modifier then
		self.idImage:RemoveModifier(self.comp_modifier)
		self.comp_modifier = false
	end
	if self.prop_meta.img_draw_alpha_only then
		self.comp_modifier = self.idImage:AddShaderModifier({
			modifier_type = const.modShader,
			shader_flags = const.modImageCompAlpha
		})
	end
	self.idImage:SetBaseColorMap(self.prop_meta.base_color_map)
	GedPropEditor.UpdateValue(self)
end

--- Draws the image content of the `GedPropImage` object, including any polylines defined in the `img_polyline` property of the `prop_meta` table.
---
--- @param clip_rect table The clipping rectangle to use when drawing the image content.
function GedPropImage:DrawImageContent(clip_rect)
	XImage.DrawContent(self.idImage, clip_rect)
	local meta = self.prop_meta
	local color = meta.img_polyline_color
	local polylines = meta.img_polyline
	if polylines and color then
		local content_box = self.idImage.content_box
		local pt, sizex, sizey = content_box:min(), content_box:sizex(), content_box:sizey()
		for _, polyline in ipairs(polylines) do
			if type(polyline) ~= "table" then
				break
			end
			assert(#polyline >= 2)
			for i = 2, #polyline do
				local p1 = pt + point(polyline[i - 1]:x() * sizex, polyline[i - 1]:y() * sizey) / 4096
				local p2 = pt + point(polyline[i]:x() * sizex, polyline[i]:y() * sizey) / 4096
				UIL.DrawLine(p1, p2, color)
			end
		end
	end
end

----- GedPropShortcut

DefineClass.ShortcutPropContainer = {
	__parents = { "XWindow" },
	IdNode = true,
	LayoutHSpacing = 2,
	LayoutVSpacing = 2,
	FoldWhenHidden = true,
	RolloverAnchor = "left",
	RolloverTemplate = "GedPropRollover",
	SelectionBackground = RGB(204, 232, 255),
	BorderColor = RGBA(0, 0, 0, 0),
	BorderWidth = 2,

	Label = false,
	ResetFunc = empty_func,
}

--- Initializes a `ShortcutPropContainer` object.
---
--- @param parent XWindow The parent window for the container.
--- @param ResetFunc function The function to call when resetting the container.
function ShortcutPropContainer:Init(parent, ResetFunc)
	local label_container = XWindow:new({
		Id = "idLabelHost",
		Dock = "left",
		FoldWhenHidden = true,
	}, self)
	XText:new({
		Id = "idLabel", 
		Dock = "left",
		VAlign = "center",
		MinWidth = 147,
	}, label_container):SetText(self.Label)
	XTextButton:new({
		Id = "idResetToDefault",
		Dock = "right",
		VAlign = "center",
		Text = "x",
		MaxWidth = 20,
		MaxHeight = 16,
		LayoutHSpacing = 0,
		Padding = box(1, 1, 1, 1),
		Background = RGBA(0, 0, 0, 0),
		RolloverBackground = RGB(204, 232, 255),
		PressedBackground = RGB(121, 189, 241),
		OnPress = function()
			return self:ResetFunc()
		end
	}, label_container)
end

DefineClass.ShortcutEditor = {
	__parents = { "XPopup" },

	handle_keyboard = true,
	handle_mouse = true,
	handle_gamepad = false,

	last_value = false,

	IdNode = true,
	editor_id = false,
	owner = false,
}

local keyboard_modifiers = { "Ctrl", "Alt", "Shift" } -- synced with KbdShortcut and MouseShortcut
local gamepad_modifiers = { "LeftTrigger", "RightTrigger", "LeftShoulder", "RightShoulder"} -- synced with XInputShortcut

---
--- Initializes a ShortcutEditor UI control.
---
--- @param parent XWindow The parent window for the container.
--- @param context table The context for the editor.
--- @param prop_meta table The metadata for the property being edited.
function ShortcutEditor:Init(parent, context, prop_meta)
	local container = XControl:new({
		Id = "idContainer",
		Padding = box(1, 1, 1, 1),
		BorderWidth = 1,
		LayoutMethod = "VList",
		OnMouseButtonDown = function(self, pos, button)
			if button == "L" then
				self:SetFocus()
			end
			return XWindow.OnMouseButtonDown(self, pos, button)
		end,
	}, self)

	local keycode_prop = ShortcutPropContainer:new({
		Id = "idKeycode",
		Label = "Keycode",
		ResetFunc = function(self)
			local combo = self.idCombo
			return combo:SetValue(combo.DefaultValue)
		end,
	}, container)

	local keys = { "" }
	if self.handle_keyboard then
		for _, key in ipairs(table.values(VKStrNames)) do
			keys[#keys + 1] = key
		end
	end
	if self.handle_mouse then
		for _, mouse_button in ipairs(table.keys(MouseButtonNames, true)) do
			keys[#keys + 1] = mouse_button
		end
	end
	if self.handle_gamepad then
		for _, button in ipairs(XInput.Buttons) do
			keys[#keys + 1] = button
		end
		for _, button in ipairs(XInput.AnalogsAsButtons) do
			keys[#keys + 1] = button
		end
		for _, button in ipairs(XInput.ThumbsAsButtons) do
			keys[#keys + 1] = button
		end
		for _, button in ipairs(XInput.LeftThumbDirectionButtons) do
			keys[#keys + 1] = button
		end
		for _, button in ipairs(XInput.RightThumbDirectionButtons) do
			keys[#keys + 1] = button
		end
	end

	XCombo:new({
		Id = "idCombo",
		RefreshItemsOnOpen = true,
		DefaultValue = "",
		ArbitraryValue = false,
		OnValueChanged = function(combo, value)
			return self:SetTextFromShortcutUI()
		end,
		OnRequestItems = function(combo)
			return keys
		end,
		VirtualItems = true,
		MRUStorageId = prop_meta.mru_storage_id,
		MRUCount = prop_meta.show_recent_items,
	}, keycode_prop)

	local listen_button = XToggleButton:new({
		IdNode = true,
		Id = "idInputListener",
		BorderWidth = 1,
		Margins = box(2, 1, 2, 1),
		Dock = "right",
		VAlign = "center",
		TextHAlign = true,
		Text = "Listen",
		MinWidth = 70,
		FocusedBorderColor = RGB(128, 128, 128),
		DisabledBorderColor = RGB(128, 128, 128),
		RolloverBorderColor = RGB(128, 128, 128),
		PressedBorderColor = RGB(128, 128, 128),
		OnShortcut = function(button, shortcut)
			if shortcut:starts_with("-") then return end
			if self.handle_gamepad and not shortcut:starts_with("+") then return end
			if shortcut:starts_with("+") then
				shortcut = shortcut:sub(2, #shortcut)
			end
			self:SetShortcutUIFromText(shortcut)
			self:SetTextFromShortcutUI()
			return "break"
		end,
		OnMouseButtonDown = function(button, pt, mouse_button)
			if mouse_button == "L" and button.Toggled and not button:MouseInWindow(pt) then
				button:SetToggled(false)
				return "break"
			end
			return XToggleButton.OnMouseButtonDown(button, pt, mouse_button)
		end,
		OnChange = function(button, toggled)
			button:SetFocus(toggled)
			button:SetText(toggled and "Listening" or "Listen")
		end,
		SetText = function(button, text)
			self.Text = text
			return button.idLabel:SetText(text)
		end,
	}, keycode_prop)
	listen_button.idLabel:SetDock("box")
	listen_button.ToggledBackground = RGB(20, 109, 171)

	local modifiers = self.handle_gamepad and gamepad_modifiers or keyboard_modifiers
	local active_modifiers = { cnt = #modifiers }
	self.Modifiers = active_modifiers
	local modifiers_prop = ShortcutPropContainer:new({
		Id = "idModifiers",
		Label = "Modifiers",
		LayoutMethod = "HWrap",
		ResetFunc = function(self)
			for _, modifier in ipairs(modifiers) do
				local modifier_button = self[modifier]
				if modifier_button then
					modifier_button:SetToggled(false)
				end
			end
		end
	}, container)
	for i, modifier in ipairs(modifiers) do
		XToggleButton:new({
			Id = modifier,
			Text = modifier,
			ToggledBackground = RGB(204, 232, 255),
			RolloverBackground = RGBA(0, 0, 0, 0),
			RolloverAnchor = "live-mouse",
			RolloverTemplate = "GedPropRollover",
			Padding = box(0, 2, 0, 2),
			OnChange = function(button, toggled)
				self.Modifiers[i] = toggled and modifier or nil
				return self:SetTextFromShortcutUI()
			end,
		}, modifiers_prop)
	end

	local interaction_prop = ShortcutPropContainer:new({
		Id = "idInteraction",
		Label = "Interaction",
		ResetFunc = function(self)
			local combo = self.idCombo
			return combo:SetValue(combo.DefaultValue)
		end
	}, container)

	local interactions
	if self.handle_gamepad then
		interactions = {
			"Held",
			"Pressed +",
			"Released -"
		}
	else
		interactions = {
			"Pressed",
			"Released -"
		}
	end
	XCombo:new({
		Id = "idCombo",
		RefreshItemsOnOpen = true,
		DefaultValue = interactions[1],
		ArbitraryValue = false,
		OnValueChanged = function(combo, value)
			return self:SetTextFromShortcutUI()
		end,
		OnRequestItems = function(combo)
			return interactions
		end,
		VirtualItems = true,
		MRUStorageId = prop_meta.mru_storage_id,
		MRUCount = prop_meta.show_recent_items,
	}, interaction_prop)

	self:SetShortcutUIFromText(self.owner:GetProp())
	self:SetTextFromShortcutUI()
end

---
--- Handles the mouse button down event for the ShortcutEditor.
---
--- If the left mouse button is pressed and the mouse pointer is not within the editor window, the editor is closed.
---
--- @param pt table The mouse pointer position.
--- @param button string The mouse button that was pressed.
--- @return string "break" to indicate the event has been handled.
---
function ShortcutEditor:OnMouseButtonDown(pt, button)
	if button == "L" then
		if not self:MouseInWindow(pt) then
			self:Close()
		end
		return "break"
	end
end

---
--- Sets the shortcut UI from the given text.
---
--- @param text string The shortcut text to set the UI from.
---
function ShortcutEditor:SetShortcutUIFromText(text)
	if not text then return end
	local container = self.idContainer
	local interation_combo = container.idInteraction.idCombo
	if text:starts_with("+") then
		interation_combo:SetValue("Pressed +")
		text = text:sub(2, #text)
	elseif text:starts_with("-") then
		interation_combo:SetValue("Released -")
		text = text:sub(2, #text)
	end

	local modifier_buttons = container.idModifiers
	local modifiers = self.handle_gamepad and gamepad_modifiers or keyboard_modifiers
	for _, modifier in ipairs(modifiers) do
		local modifier_button = modifier_buttons[modifier]
		if modifier_button then
			modifier_button:SetToggled(false)
		end
	end

	local keycode_combo = container.idKeycode.idCombo
	local keys = text:split('-')
	local key_cnt = #keys
	for i = 1, key_cnt do
		local key = keys[i]
		if i < key_cnt or table.find(modifiers, key) then
			local modifier_button = modifier_buttons[key]
			if modifier_button then
				modifier_button:SetToggled(true)
			end
		else
			keycode_combo:SetValue(key, "do_not_validate")
		end
	end
end

---
--- Sets the shortcut text from the UI elements.
---
--- This function is called when the user interacts with the shortcut editor UI to update the shortcut text.
--- It extracts the interaction type (pressed/released), modifiers, and key code from the UI elements and
--- constructs the final shortcut text. If the shortcut text has changed, it updates the property value.
---
--- @param self ShortcutEditor The ShortcutEditor instance.
---
function ShortcutEditor:SetTextFromShortcutUI()
	if self:IsThreadRunning("set_text_from_ui_thread") then return end
	self:CreateThread("set_text_from_ui_thread", function()
		local container = self.idContainer
		local interaction = container.idInteraction
		local interation_combo = interaction.idCombo
		local interaction_value = interation_combo:GetValue()

		local shortcut_text = ""
		if interaction_value == "Pressed +" then
			shortcut_text = shortcut_text .. "+"
		elseif interaction_value == "Released -" then
			shortcut_text = shortcut_text .. "-"
		end
		interaction.idResetToDefault:SetVisibleInstant(interaction_value ~= interation_combo.DefaultValue)

		local has_modifiers = false
		local modifiers = self.Modifiers
		for i = 1, modifiers.cnt do
			if modifiers[i] then
				shortcut_text = shortcut_text .. modifiers[i] .. "-"
				has_modifiers = true
			end
		end
		container.idModifiers.idResetToDefault:SetVisibleInstant(has_modifiers)
		
		local keycode = container.idKeycode
		local keycode_combo = keycode.idCombo
		local keycode_value = keycode_combo:GetValue()
		keycode.idResetToDefault:SetVisibleInstant(keycode_value ~= keycode_combo.DefaultValue)
		if #keycode_value > 0 then
			shortcut_text = shortcut_text .. keycode_value
		elseif has_modifiers then
			shortcut_text = shortcut_text:sub(1, #shortcut_text - 1)
		end
		if self.last_value ~= shortcut_text then
			self.last_value = shortcut_text
			self.owner:SetProp(shortcut_text)
		end
	end)
end

GedPropEditors["shortcut"] = "GedPropShortcut"
DefineClass.GedPropShortcut = {
	__parents = { "GedPropText" },

	single_line_edit_template = "XCombo",
	shortcut_type = "keyboard&mouse",
}

---
--- Initializes the `GedPropShortcut` class.
---
--- @param parent table The parent object.
--- @param context table The context object.
--- @param prop_meta table The property metadata.
---
function GedPropShortcut:Init(parent, context, prop_meta)
	self.shortcut_type = prop_meta.shortcut_type or self.shortcut_type
end

---
--- Creates a single line editor for a shortcut property.
---
--- @param prop_meta table The property metadata.
--- @return table The created single line editor.
---
function GedPropShortcut:CreateSingleLineEditor(prop_meta)
	local combo = XCombo:new({
		ArbitraryValue = false,
		OpenCombo = function(combo, mode)
			if mode == "suggest" then return end
			local active_popup = rawget(rawget(_G, "g_GedApp") or self.desktop, "idShortcutEditor")
			if active_popup then
				active_popup.owner = self
			else
				self:OpenShortcutEditor()
			end
		end
	}, self)
	local idEdit = combo.idEdit
	idEdit:SetVAlign("center")
	idEdit:SetTextStyle(prop_meta.text_style)
	idEdit:SetFilter(prop_meta.allowed_chars or ".")
	self.idEdit = idEdit
	return idEdit
end

---
--- Opens the shortcut editor popup for the current property.
---
--- If the shortcut editor is already open, it will be closed first.
--- The editor popup will be positioned relative to the current property's box.
--- The editor popup will be set as modal and will have the focus.
---
--- @param self table The current `GedPropShortcut` instance.
---
function GedPropShortcut:OpenShortcutEditor()
	if self:CloseShortcutEditor() then return end
	if self.ReadOnly then return end

	local context = self.context
	local prop_meta = self.prop_meta
	
	-- TODO: Handle ActionMouseBindable and ActionBindSingleKey

	local shortcut_type = self.shortcut_type
	local editor_popup = ShortcutEditor:new({
		Id = "idShortcutEditor",
		editor_id = prop_meta.id .. self.panel.context,
		ReadOnly = prop_meta.read_only,
		DrawOnTop = true,
		handle_keyboard = shortcut_type == "keyboard&mouse" or shortcut_type == "keyboard",
		handle_mouse = shortcut_type == "keyboard&mouse",
		handle_gamepad = shortcut_type == "gamepad",
		owner = self,
	}, rawget(_G, "g_GedApp") or self.desktop, context, prop_meta)
	
	editor_popup:SetAnchor(self.box)
	editor_popup:SetAnchorType("drop")
	editor_popup:Open()
	editor_popup:SetModal()
	editor_popup:SetFocus()

	self.panel.app:UpdateChildrenDarkMode(editor_popup)
end

---
--- Closes the shortcut editor popup for the current property.
---
--- If the shortcut editor is already open, it will be closed.
---
--- @param self table The current `GedPropShortcut` instance.
--- @return boolean True if the editor was closed, false otherwise.
---
function GedPropShortcut:CloseShortcutEditor()
	local editor_popup = rawget(rawget(_G, "g_GedApp") or self.desktop, "idShortcutEditor")
	if editor_popup then
		editor_popup:Close()
		return true
	end
end

----- GedPropFlags

local function LimitIntToSize(value, size)
	local mask = 0
	for i = 1, size do
		mask = shift(mask, 1)
		mask = bor(mask, 1)
	end
	return band(value, mask)
end

-- Sorts flags - named flags are first alphabetically, then unnamed flags alphabetically
local function sort_flags(a, b)
	-- shape of a/b: { name, id, value }
	local a_noname = string.starts_with(a.name, "bit")
	local b_noname = string.starts_with(b.name, "bit")
	
	if a_noname and not b_noname then
		return false -- b before a
	elseif not a_noname and b_noname then
		return true -- a before b
	else
		return a.name < b.name
	end
end

GedPropEditors["flags"] = "GedPropFlags"
DefineClass.GedPropFlags = {
	__parents = { "GedPropEditor" },
}

---
--- Initializes the GedPropFlags editor.
---
--- This function creates a new XCheckButtonCombo instance with the following properties:
--- - Id: "idCombo"
--- - Items: A function that returns the combo items from the `GetComboItems()` method
--- - Editable: True if the `prop_meta.read_only` flag is false
--- - OnCheckButtonChanged: A callback function that updates the property value when a checkbox is changed
---
--- The callback function finds the flag bit corresponding to the changed checkbox, and updates the property value accordingly by setting or clearing the corresponding bit.
---
--- @param self table The current `GedPropFlags` instance.
---
function GedPropFlags:Init()
	XCheckButtonCombo:new({
		Id = "idCombo",
		Items = function(check_combo) return self:GetComboItems() end,
		Editable = not self.prop_meta.read_only,
		OnCheckButtonChanged = function(checkbox, id, value)
			local items = self:GetComboItems()
			local item_idx = table.find(items, "id", id)
			assert(item_idx, "Flag not found in items")
			if not item_idx then return end
			
			local flag_bit = items[item_idx] and items[item_idx].flag_bit
			
			local flags = self:GetProp()
			if not value then
				flags = band(flags, bnot(shift(1, flag_bit - 1)))
			else
				flags = bor(flags, shift(1, flag_bit - 1))
			end
			self:SetProp(LimitIntToSize(flags, self.prop_meta.size))
			self:UpdateValue()
		end
	}, self)
end

---
--- Gets the combo items for the GedPropFlags editor.
---
--- This function returns a table of combo items, where each item is a table with the following properties:
--- - id: The unique identifier for the item
--- - flag_bit: The bit position of the flag
--- - name: The display name of the item
--- - read_only: A boolean indicating whether the item is read-only
--- - value: A boolean indicating whether the flag is currently set
---
--- The items are sorted in ascending order by their flag bit position.
---
--- @param self table The current `GedPropFlags` instance.
--- @param flags number The current value of the flags property.
--- @param flag_names table The list of flag names from the property metadata.
--- @return table The list of combo items.
---
function GedPropFlags:GetComboItems(flags, flag_names)
	local items = {}
	local flags = self:GetProp()
	local flag_names = self.prop_meta.items
	for i = 1, self.prop_meta.size do
		local name = flag_names[i]
		local read_only = false
		if type(name) == "table" then
			read_only = name.read_only
			name = name.name
		end
		if not name then
			name = "bit " .. i
		end
		
		local value = band(flags, shift(1, i - 1)) ~= 0
		table.insert(items, { id = name, flag_bit = i, name = name, read_only = read_only or flags == Undefined() or self.prop_meta.read_only, value = value })
	end
	
	table.sort(items, sort_flags)
	
	return items
end

---
--- Updates the value of the GedPropFlags editor.
---
--- This function is responsible for updating the display of the GedPropFlags editor based on the current value of the flags property. It first checks if the flags value is undefined, and if so, sets the text of the combo box to "Undefined". Otherwise, it generates a list of the currently set flags and displays them in the combo box.
---
--- The function first retrieves the current value of the flags property using `self:GetProp()`. It then calls `self:GetComboItems()` to get a list of all the possible flags and their current values. It then filters this list to only include the flags that are currently set, sorts the resulting list, and displays it in the combo box.
---
--- @param self table The current `GedPropFlags` instance.
---
function GedPropFlags:UpdateValue()
	GedPropEditor.UpdateValue(self)
	
	local flags = self:GetProp()
	if flags == Undefined() then
		self.idCombo:SetText("Undefined")
		return
	end
	
	local items = self:GetComboItems(flags)
	local filtered_items = {}
	for idx = 1, self.prop_meta.size do
		if band(flags, shift(1, idx - 1)) ~= 0 then
			local item_idx = table.find(items, "flag_bit", idx)
			if item_idx then
				table.insert(filtered_items, items[item_idx].name)
			end
		end
	end
	
	table.sort(filtered_items)
	self.idCombo:SetText(string.format("0x%x", flags) .. " : " .. table.concat(filtered_items, " | "))
end


----- GedPropEmpty

GedPropEditors["empty"] = "GedPropEmpty"
DefineClass.GedPropEmpty = {
	__parents = { "GedPropEditor" },
}

---
--- Initializes a GedPropEmpty instance.
---
--- The GedPropEmpty class is used to represent a property editor in the GED (Graphical Editor) that has no editable value. This Init() function sets the text of a label within the GedPropEmpty instance to "Undefined".
---
--- @param self table The current GedPropEmpty instance.
---
function GedPropEmpty:Init()
	XLabel:new({
		Id = "idLabel",
		Dock = "box",
	}, self):SetText("Undefined")
end


----- GedPropGrid

if FirstLoad then
	GridToUnload = {}
	GridPreviewIdx = 1
end

GedPropEditors["grid"] = "GedPropGrid"
DefineClass.GedPropGrid = {
	__parents = { "GedPropEditor" },
	grid = false,
	grid_img = "",
	grid_hash = false,
	grid_size = false,
	grid_offset = false,
	max_size = 0,
	color = false,
	invalid_value = false,
	dont_normalize = false,
}

---
--- Marks the GedPropGrid instance as having no grid image set.
---
--- This function is called when the GedPropGrid instance is done being used, and sets the grid image to `false` to indicate that no grid image is currently set.
---
--- @param self table The current GedPropGrid instance.
---
function GedPropGrid:Done()
	self:SetGridImage(false)
end

---
--- Initializes a GedPropGrid instance.
---
--- The GedPropGrid class is used to represent a property editor in the GED (Graphical Editor) that displays a grid image. This Init() function sets up the UI elements for the grid image, including a label for "No Grid Data" and an image control to display the grid.
---
--- The image control has several properties set, including:
--- - Dock = "box": Docks the image to the box layout
--- - ImageFit = "stretch": Stretches the image to fit the control
--- - VAlign = "center": Vertically centers the image
--- - HAlign = "left": Horizontally aligns the image to the left
--- - HandleMouse = true: Enables mouse handling for the image
--- - RolloverAnchor = "live-mouse": Anchors the rollover window to the live mouse position
--- - RolloverTemplate = "GedPropRollover": Uses the "GedPropRollover" template for the rollover window
--- - Measure = function(self, width, height) return UIL.MeasureImage(self.Image) end: Sets the measure function to return the size of the image
---
--- The image control also has two callback functions set:
--- - OnMousePos = function(image, pt): Recreates the rollover window when the mouse position changes
--- - GetRolloverText = function(image): Returns the text to display in the rollover window, which includes the grid coordinates and value at the mouse position
---
--- @param self table The current GedPropGrid instance.
---
function GedPropGrid:Init()
	XLabel:new({
		Id = "idNoData",
		Dock = "box",
	}, self):SetText("No Grid Data")
	
	local image = XImage:new({
		Id = "idImage",
		Dock = "box",
		ImageFit = "stretch",
		VAlign = "center",
		HAlign = "left",
		HandleMouse = true,
		RolloverAnchor = "live-mouse",
		RolloverTemplate = "GedPropRollover",
		Measure = function(self, width, height) return UIL.MeasureImage(self.Image) end
	}, self)
	image.OnMousePos = function(image, pt)
		XRecreateRolloverWindow(image)
	end
	image.GetRolloverText = function(image)
		local grid = self.grid
		if not grid then
			return
		end
		local pt = terminal.GetMousePos()
		local box = image.content_box
		if not pt:InBox(box) then
			return ""
		end
		local rw, rh = self.grid_size:xy()
		local gw, gh = grid:size()
		local bw, bh = box:sizexyz()
		local bx, by = (pt - box:min()):xy()
		local gx = MulDivTrunc(gw, bx, bw)
		local gy = MulDivTrunc(gh, by, bh)
		local rx = MulDivTrunc(rw, bx, bw)
		local ry = MulDivTrunc(rh, by, bh)
		local scale = 1000
		local v = GridGet(grid, gx, gy, scale)
		local sign = v < 0 and "-" or ""
		v = abs(v)
		local a, b = v / scale, v % scale
		local bs
		if b < 1 then
			bs = ""
		elseif b < 10 then
			bs = ".00" .. b
		elseif b < 100 then
			bs = ".0" .. b
		else
			bs = "." .. b
		end
		return string.format("(%i, %i) %s%d%s", rx, ry, sign, a, bs)
	end
end

---
--- Sets the grid image for the GedPropGrid.
---
--- This function is responsible for managing the loading and unloading of grid images.
--- It checks for any old grid images that have not been used for 5 frames and deletes them asynchronously.
--- It then sets the new grid image on the idImage component and updates the grid_img field.
---
--- @param img string|nil The new grid image to set, or nil to clear the image.
---
function GedPropGrid:SetGridImage(img)
	local frame = GetRenderFrame()
	for unload_img, unload_frame in pairs(GridToUnload) do
		if frame - unload_frame > 5 and UIL.IsImageReady(unload_img) then
			local err = AsyncFileDelete(unload_img)
			GridToUnload[unload_img] = nil
		end
	end
	img = img or ""
	local prev_img = self.grid_img or ""
	if prev_img ~= "" then
		UIL.UnloadImage(prev_img)
		GridToUnload[prev_img] = frame
	end
	self.idImage:SetImage(img)
	self.grid_img = img
end

---
--- Updates the value of the GedPropGrid.
---
--- This function is responsible for managing the loading, unloading, and display of the grid image associated with the property value.
--- It checks if the property value has changed, and if so, it updates the grid image accordingly. It also handles various properties of the grid image, such as color, normalization, and size.
---
--- @param self GedPropGrid The GedPropGrid instance.
---
function GedPropGrid:UpdateValue()
	local prop_value = self:GetProp()
	local grid_str, grid_w, grid_h
	if type(prop_value) == "table" then
		grid_str, grid_w, grid_h = table.unpack(prop_value)
	else
		grid_str = prop_value
	end
	local hasgrid = type(grid_str) == "string" and grid_str ~= ""
	self.idImage:SetDock(hasgrid and "box" or "ignore")
	self.idNoData:SetDock(hasgrid and "ignore" or "box")
	self.idImage:SetVisible(hasgrid)
	self.idNoData:SetVisible(not hasgrid)
	if not hasgrid then
		self.grid = false
		return
	end
	local update
	local grid = self.grid
	local force_read_grid
	local grid_offset = self.prop_meta.grid_offset or false
	if grid_offset ~= self.grid_offset then
		force_read_grid = true
		self.grid_offset = grid_offset
	end
	local grid_hash = xxhash(grid_str)
	if not grid or force_read_grid or grid_hash ~= self.grid_hash then
		update = true
		self.grid_hash = grid_hash
		grid = GridReadStr(grid_str)
		if not grid then
			self.grid = false
			return
		end
		grid = GridRepack(grid, "F")
		if grid_offset then
			GridAdd(grid, grid_offset)
		end
		self.grid = grid
	end
	self.grid_size = grid_w and grid_h and point(grid_w, grid_h) or point(grid:size())
	local color = self.prop_meta.color or false
	if color ~= self.color then
		update = true
		self.color = color
	end
	local invalid_value = self.prop_meta.invalid_value or false
	if invalid_value ~= self.invalid_value then
		update = true
		self.invalid_value = invalid_value
	end
	local dont_normalize = self.prop_meta.dont_normalize or false
	if dont_normalize ~= self.dont_normalize then
		update = true
		self.dont_normalize = dont_normalize
	end
	local min_size = self.prop_meta.min or 0
	local max_size = self.prop_meta.max or 512
	if self.max_size ~= max_size then
		update = true
		self.max_size = max_size
	end
	local w, h = grid:size()
	if update then
		local size = Max(w, h)
		if not color then
			while true do
				if size < 2 * max_size then
					break
				end
				w, h = w / 2, h / 2
				grid = GridResample(grid, w, h)
			end
		elseif size > max_size then
			grid = GridResample(grid, w * max_size / size, h * max_size / size, false)
		end
		GridPreviewIdx = GridPreviewIdx + 1
		local new_img = "memoryfs/grid_" .. GridPreviewIdx .. ".tga"
		-- Prepare image for exporting to TGA:
		local color_fmt = color and "color" or "gray24"
		local normalize = not dont_normalize
		local err = GridToImage(new_img, grid, color_fmt, invalid_value, normalize)
		if err then
			assert(false, 'Failed to export tga: ' .. err)
			new_img = ""
		end
		self:SetGridImage(new_img)
	end
	local frame = self.prop_meta.frame or 0
	self.idImage.BorderWidth = frame
	self.idImage.BorderHeight = frame
	if min_size > 0 then
		local s = Min(w, h)
		self.idImage.MinWidth = min_size * w / s
		self.idImage.MinHeight = min_size * h / s
	end
	if max_size > min_size then
		local s = Max(w, h)
		self.idImage.MaxWidth = max_size * w / s
		self.idImage.MaxHeight = max_size * h / s
	end
	
	GedPropEditor.UpdateValue(self)
end


----- GedPropPresetId

GedPropEditors["preset_id"] = "GedPropPresetId"
DefineClass.GedPropPresetId = {
	__parents = { "GedPropEditor" }
}

---
--- Initializes the GedPropPresetId editor component.
---
--- The GedPropPresetId editor is used to edit a preset ID property in the GED (Game Editor) UI.
--- It provides a combo box to select the preset, as well as buttons to create a new preset and open the preset editor.
---
--- @param self GedPropPresetId The GedPropPresetId editor instance.
--- @param prop_meta table The metadata for the property being edited.
--- @return nil
function GedPropPresetId:Init()
	local prop_meta = self.prop_meta
	local create_button, open_button
	
	if not prop_meta.read_only and self:ShouldShowButtonForFunc("GedOpPresetIdNewInstance") then
		create_button = XTemplateSpawn("GedToolbarButtonSmall", self)
		create_button:SetIcon("CommonAssets/UI/Ged/plus-one.tga")
		create_button:SetRolloverText(string.format("New %s", prop_meta.preset_class))
		create_button.OnPress = function(button)
			button:SetFocus()
			self.panel.app:Op("GedOpPresetIdNewInstance", self.panel.context, prop_meta.id, prop_meta.preset_class)
			self.idCombo.Items = false -- let it fetch them again
			button:SetFocus(false)
		end
	end
	
	if self:ShouldShowButtonForFunc("GedRpcEditPreset") then
		open_button = XTemplateSpawn("GedToolbarButtonSmall", self)
		open_button:SetIcon("CommonAssets/UI/Ged/explorer.tga")
		open_button:SetRolloverText("Open Preset Editor")
		open_button.OnPress = function(button)
			button:SetFocus()
			self.panel.app:Send("GedRpcEditPreset", self.panel.context, prop_meta.id)
			button:SetFocus(false)
		end
	end
	
	XCombo:new({
		Id = "idCombo",
		Items = false,
		RefreshItemsOnOpen = true,
		DefaultValue = prop_meta.default or "",
		ArbitraryValue = false,
		OnValueChanged = function(combo, value)
			self:SetProp(value)
		end,
		OnRequestItems = function(combo)
			return self.panel.connection:Call("rfnGetPresetItems", self.panel.context, self.prop_meta.id)
		end,
		MRUStorageId = prop_meta.mru_storage_id,
		MRUCount = prop_meta.show_recent_items,
		VirtualItems = true,
	}, self)
	self.idCombo:SetEnabled(not prop_meta.read_only)
	
	if prop_meta.editor_preview then
		GedTextPanel:new({
			Title = "",
			Dock = "bottom",
			ZOrder = -1,
			Format = prop_meta.editor_preview,
		}, self):SetContext(prop_meta.id..".ReferencedPreset")
	end
	
	-- GoldMaster (Mod Editor) does not support the additional features
	if not Platform.developer then
		if open_button then
			open_button:SetVisible(false)
			open_button:SetDock("ignore")
		end
		if create_button then
			create_button:SetVisible(false)
			create_button:SetDock("ignore")
		end
	end
end
	
---
--- Updates the value of the preset ID combo box and optionally binds the referenced preset to the app.
---
--- @param self GedPropPresetId The instance of the GedPropPresetId class.
---
function GedPropPresetId:UpdateValue()
	local combo = self.idCombo
	combo.Items = false -- list of items might have changed, must be refetched
	if not (combo:IsFocused() and combo.ArbitraryValue and combo:GetValue() ~= combo:GetText()) then
		self.last_value = self:GetProp()
		combo:SetValue(self.last_value, true)
	end
	
	if self.prop_meta.editor_preview then
		self.panel.app:Send("GedRpcBindPreset", self.prop_meta.id..".ReferencedPreset", self.panel.context, self.prop_meta.id)
	end
	GedPropEditor.UpdateValue(self)
end

---
--- Reassigns the focus order of the idCombo combo box to the specified coordinates.
---
--- @param self GedPropPresetId The instance of the GedPropPresetId class.
--- @param x number The x-coordinate of the new focus order.
--- @param y number The y-coordinate of the new focus order.
--- @return number The next y-coordinate for focus order assignment.
---
function GedPropPresetId:ReassignFocusOrders(x, y)
	self.idCombo:SetFocusOrder(point(x, y))
	return y + 1
end


---
--- Detaches the GedPropPresetId instance from its current context and updates the MRU list of the idCombo combo box.
---
--- This function is called when the GedPropPresetId instance is no longer needed and needs to be reused.
---
--- @param self GedPropPresetId The instance of the GedPropPresetId class.
---
function GedPropPresetId:DetachForReuse()
	self.idCombo:UpdateMRUList()
	GedPropEditor.DetachForReuse(self)
end



----- GedPropEmbeddedObject (base class for the nested_obj/nested_list/script editors)

DefineClass.GedPropEmbeddedObject = {
	__parents = { "GedPropEditor" },
}

---
--- Initializes a GedPropEmbeddedObject instance.
---
--- This function sets up the UI elements for the GedPropEmbeddedObject, including buttons for creating, copying, and pasting nested objects.
---
--- @param self GedPropEmbeddedObject The instance of the GedPropEmbeddedObject class.
--- @param parent table The parent UI element.
--- @param context table The context of the GedPropEmbeddedObject.
--- @param prop_meta table The metadata for the property being edited.
---
function GedPropEmbeddedObject:Init(parent, context, prop_meta)
	local create_button = XTemplateSpawn("GedToolbarButtonSmall", self)
	create_button:SetId("idCreateItemButton")
	create_button:SetIcon("CommonAssets/UI/Ged/new.tga")
	create_button:SetRolloverText("Create Item")
	create_button:SetEnabled(not prop_meta.read_only)
	
	local paste_button = XTemplateSpawn("GedToolbarButtonSmall", self)
	paste_button:SetId("idPasteButton")
	paste_button:SetIcon("CommonAssets/UI/Ged/paste.tga")
	paste_button:SetRolloverText("Paste")
	paste_button:SetEnabled(not prop_meta.read_only)
	
	local copy_button = XTemplateSpawn("GedToolbarButtonSmall", self)
	copy_button:SetId("idCopyButton")
	copy_button:SetIcon("CommonAssets/UI/Ged/copy.tga")
	copy_button:SetRolloverText("Copy")
	
	if self:HasMember("idButtonsHost") then
		self.idButtonsHost:SetDock("right")
		self.idButtonsHost:SetZOrder(-1)
	end
	
	if prop_meta.editor ~= "script" then
		XText:new({
			Id = "idValueText",
			VAlign = "center",
			MaxHeight = 24,
			HandleMouse = false,
		}, self)
	end
end

---
--- Reassigns the focus order of the create item button.
---
--- @param self GedPropEmbeddedObject The instance of the GedPropEmbeddedObject class.
--- @param x number The new x-coordinate for the focus order.
--- @param y number The new y-coordinate for the focus order.
--- @return number The new y-coordinate after reassigning the focus order.
---
function GedPropEmbeddedObject:ReassignFocusOrders(x, y)
	self.idCreateItemButton:SetFocusOrder(point(x, y))
	return y + 1
end


----- GedPropNestedObj

GedPropEditors["nested_obj"] = "GedPropNestedObj"
GedPropEditors["property_array"] = "GedPropNestedObj"
DefineClass.GedPropNestedObj = {
	__parents = { "GedPropEmbeddedObject", "GedPanelBase" },
}

---
--- Initializes a GedPropNestedObj instance.
---
--- @param parent table The parent object.
--- @param context table The context object.
--- @param prop_meta table The property metadata.
---
function GedPropNestedObj:Init(parent, context, prop_meta)
	self.idCreateItemButton.OnPress = function(button)
		if prop_meta.editor == "property_array" then
			if self.window_state == "destroying" then return end
			button:SetFocus()
			self.app:Op("GedCreateNestedObj", self.panel.context, self.prop_meta.id, "GedDynamicProps")
			self.idPropPanel.expanded = true
			button:SetFocus(false)
			return
		end
		
		CreateRealTimeThread(function()
			local items = self.app:Call("GedGetNestedClassItems", self.panel.context, self.prop_meta.id)
			local title = string.format("New %s object", prop_meta.base_class)
			GedOpenCreateItemPopup(self, title, items, button, function(class)
				if self.window_state == "destroying" then return end
				self.app:Op("GedCreateNestedObj", self.panel.context, self.prop_meta.id, class)
				self.idPropPanel.expanded = true
			end)
		end)
	end
	self.idCreateItemButton:SetFoldWhenHidden(true)
	
	self.idCopyButton.OnPress = function(button)
		self.panel:SetFocus()
		self.app:Op("GedNestedObjCopy", self.panel.context, self.prop_meta.id, self.prop_meta.base_class)
	end
	self.idPasteButton.OnPress = function(button)
		self.panel:SetFocus()
		self.app:Op("GedNestedObjPaste", self.panel.context, self.prop_meta.id, self.prop_meta.base_class)
	end
	
	GedPropPanel:new({
		Id = "idPropPanel",
		Dock = "bottom",
		ZOrder = -1,
		Margins = box(10, 0, 0, 0),
		FoldWhenHidden = true,
		Embedded = true,
		Collapsible = true,
		HideFirstCategory = true,
		RootObjectBindName = self.panel.RootObjectBindName,
		Title = prop_meta.editor == "property_array" and "<empty>" or prop_meta.format or "<EditorView>",
		ActionsClass = "PropertyObject",
		Copy = "GedOpPropertyCopy",
		Paste = "GedOpPropertyPaste",
		StartsExpanded = prop_meta.auto_expand or false,
		SuppressProps = prop_meta.suppress_props,
		read_only = prop_meta.read_only,
	}, self)
end

---
--- Detaches the GedPropNestedObj instance from its views and unbinds the idPropPanel view. Calls the DetachForReuse method of the parent GedPropEditor class.
---
--- This method is used to prepare the GedPropNestedObj instance for reuse, by disconnecting it from any bound views and resetting its state.
---
--- @function GedPropNestedObj:DetachForReuse
--- @return nil
function GedPropNestedObj:DetachForReuse()
	self:UnbindViews()
	self.idPropPanel:UnbindViews()
	GedPropEditor.DetachForReuse(self)
end

---
--- Updates the context and view of the GedPropNestedObj instance.
---
--- If the view is `nil`, the method sets the context of the `idPropPanel` to the current context of the GedPropNestedObj instance.
---
--- This method is called when the context or view of the GedPropNestedObj instance is updated.
---
--- @function GedPropNestedObj:OnContextUpdate
--- @param context table The new context of the GedPropNestedObj instance.
--- @param view table The new view of the GedPropNestedObj instance.
--- @return nil
function GedPropNestedObj:OnContextUpdate(context, view)
	GedPanelBase.OnContextUpdate(self, context, view)
	if view == nil then
		self.idPropPanel:SetContext(self.context)
	end
end

---
--- Updates the value of the GedPropNestedObj instance.
---
--- This method is responsible for updating the value of the GedPropNestedObj instance, including setting the text of the `idValueText` element, and controlling the visibility of the `idPropPanel` and `idCreateItemButton` elements based on the value.
---
--- It also binds the context of the GedPropNestedObj instance to the context of the parent panel, using the `prop:` prefix and the ID of the property metadata.
---
--- Finally, it calls the `UpdateValue` method of the parent `GedPropEditor` class.
---
--- @function GedPropNestedObj:UpdateValue
--- @return nil
function GedPropNestedObj:UpdateValue()
	local value = self:GetProp()
	self.idValueText:SetText(value == Undefined() and "(undefined)" or "")
	
	value = value ~= Undefined() and value
	self.idPropPanel:SetVisible(value)
	self.idCreateItemButton:SetVisible(not value)
	
	self.connection:BindObj(self.context, { self.panel.context, "prop:" .. self.prop_meta.id })
	GedPropEditor.UpdateValue(self)
end

---
--- Reassigns the focus order of the GedPropNestedObj instance and its child idPropPanel.
---
--- This method is responsible for updating the focus order of the GedPropNestedObj instance and its child idPropPanel. It calls the ReassignFocusOrders method of the parent GedPropEmbeddedObject class, and then calls the ReassignFocusOrders method of the idPropPanel.
---
--- @param x number The x-coordinate of the focus order.
--- @param y number The y-coordinate of the focus order.
--- @return number The updated y-coordinate of the focus order.
function GedPropNestedObj:ReassignFocusOrders(x, y)
	y = GedPropEmbeddedObject.ReassignFocusOrders(self, x, y)
	y = self.idPropPanel:ReassignFocusOrders(x, y)
	return y
end

---
--- Updates the property names of the GedPropNestedObj instance and its child idPropPanel.
---
--- This method is responsible for updating the property names of the GedPropNestedObj instance and its child idPropPanel. It calls the UpdatePropertyNames method of the child idPropPanel, and then calls the UpdatePropertyNames method of the parent GedPropEditor class.
---
--- @param internal boolean Whether the property names are being updated internally.
--- @return nil
function GedPropNestedObj:UpdatePropertyNames(internal)
	self.idPropPanel:UpdatePropertyNames(internal)
	GedPropEditor.UpdatePropertyNames(self, internal)
end


----- GedPropNestedList

DefineClass.GedPropListDragAndDrop = {
	__parents = { "GedDragAndDrop", },
	prop_parent_class = "GedPropEditor",
	drop_target_container_class = "XList",
	List = false,
	Item = false,
}

---
--- Initializes a new GedPropListDragAndDrop instance with a centered image.
---
--- This method creates a new XImage instance and sets its properties to display a centered image with a specific scale and color. The image is set to "CommonAssets/UI/Ged/dragndrop.tga" and the ImageFit is set to "scale_down". The ImageScale is set to point(700, 700), and the ImageColor is set based on the GetDarkModeSetting() function.
---
--- @return nil
function GedPropListDragAndDrop:Init()
	XImage:new({
		HAlign = "center",
		VAlign = "center",
		Image = "CommonAssets/UI/Ged/dragndrop.tga",
		ImageFit = "scale_down",
		ImageScale = point(700, 700),
		ImageColor = GetDarkModeSetting() and RGB(210, 210, 210) or RGB(0, 0, 0),
	}, self)
end

---
--- Returns the appropriate mouse cursor based on the state of the GedPropListDragAndDrop instance.
---
--- If the GedPropListDragAndDrop instance is not enabled, this function returns `nil`, indicating that the default cursor should be used.
--- If the GedPropListDragAndDrop instance has a drag window and there is a drag and drop error, this function returns the path to the "CommonAssets/UI/ErrorCursor.tga" image, which should be used as the mouse cursor.
--- Otherwise, this function returns the path to the "CommonAssets/UI/HandCursor.tga" image, which should be used as the mouse cursor.
---
--- @return string|nil The path to the appropriate mouse cursor image, or `nil` if the default cursor should be used.
function GedPropListDragAndDrop:GetMouseCursor()
	if not self.enabled then return end
	if self.drag_win and self:GetDragAndDropError() then
		return "CommonAssets/UI/ErrorCursor.tga"
	else
		return "CommonAssets/UI/HandCursor.tga"
	end
end

---
--- Iterates over the selected children of the drag target and calls the provided function for each one.
---
--- @param func function The function to call for each selected child.
--- @param ... any Additional arguments to pass to the function.
--- @return string "break" if the function returns "break", otherwise nil.
function GedPropListDragAndDrop:ForEachSelectedDragTargetChild(func, ...)
	local prop_list = GetParentOfKind(ged_drag_target, self.prop_parent_class)
	if not prop_list then return end
	local selection = ged_drag_target:GetSelection()
	for _, idx in ipairs(selection) do
		local selected_child = ged_drag_target[idx]
		if func(selected_child, ...) == "break" then
			return "break"
		end
	end
end

---
--- Returns the GedPropList instance associated with this GedPropListDragAndDrop instance.
---
--- @return GedPropList The GedPropList instance.
function GedPropListDragAndDrop:GetGedDragTarget()
	return self.List
end

---
--- Iterates over the children of the drag target and calls the provided function for each one.
---
--- @param func function The function to call for each child.
--- @param ... any Additional arguments to pass to the function.
--- @return string "break" if the function returns "break", otherwise nil.
function GedPropListDragAndDrop:ForEachDragTargetChild(func, ...)
	if not IsKindOf(ged_drag_target, self.drop_target_container_class) then return end
	for _, child in ipairs(ged_drag_target) do
		if func(child, ...) == "break" then
			return "break"
		end
	end
end

DefineClass.GedNestedPropDragAndDrop = {
	__parents = { "GedPropListDragAndDrop", },
	prop_parent_class = "GedPropNestedList",
}

---
--- Returns the title control of the specified control, which is used as the drag window text.
---
--- @param control any The control to get the title control from.
--- @return any The title control of the specified control.
function GedNestedPropDragAndDrop:GetDragWindowTextControl(control)
	return control.idTitle
end

---
--- Handles the drop event for a nested property drag and drop operation.
---
--- @param drag_win any The drag window.
--- @param pt table The drop point.
--- @param drag_source_win any The drag source window.
function GedNestedPropDragAndDrop:OnDrop(drag_win, pt, drag_source_win)
	if self:GetDragAndDropError() then return end
	local prop_parent = GetParentOfKind(ged_drop_target, self.prop_parent_class)
	local sel = prop_parent.idList:GetSelection()
	local last_time = prop_parent.last_move_items_time
	-- don't allow multiple ops to reach the game before they get the chance to get executed
	if GetPreciseTicks() > last_time + 350 then
		prop_parent:CollapseUnselected()
		local op = gedListDragAndDropOps[ged_drop_type]
		prop_parent.app:Op(op, prop_parent.context, sel, table.find(prop_parent.idList, ged_drop_target))
		prop_parent.app:Send("GedNotifyPropertyChanged", prop_parent.panel.context, prop_parent.prop_meta.id)
		prop_parent.last_move_items_time = GetPreciseTicks()
		prop_parent.last_move_items_selection = sel
	end
end

DefineClass.GedNestedPropPanel = {
	__parents = { "GedPropPanel", "XListItem" },
	
	SelectionBackground = RGB(255, 255, 255),
	Embedded = true,
	Collapsible = true,
	HideFirstCategory = true,
	
	expanded = false,
	prop_id = false,
	item_addr = false,
	list_context = false,
	parent_obj_context = false,
	selection_mark = false,
}

GedNestedPropPanel.OnMouseButtonDown = XControl.OnMouseButtonDown

---
--- Initializes the controls for a GedNestedPropPanel.
--- This function sets up the delete and duplicate buttons for the panel, as well as the drag and drop functionality.
--- It also creates a thread to handle the rollover highlighting of nested items in the panel.
---
--- @param self GedNestedPropPanel The GedNestedPropPanel instance.
---
function GedNestedPropPanel:InitControls()
	GedPropPanel.InitControls(self)
	
	local read_only = GetParentOfKind(self, "GedPropNestedList").prop_meta.read_only

	if self:ShouldShowButtonForFunc("GedOpListDeleteItem") then
		local delete_button = XTemplateSpawn("GedToolbarButtonSmall", self.idTitleContainer)
		delete_button:SetIcon("CommonAssets/UI/Ged/delete.tga")
		delete_button:SetRolloverText("Delete")
		delete_button.OnPress = function(button)
			local idx = table.find(self.parent, self)
			button:SetFocus()
			self.app:Op("GedOpListDeleteItem", self.list_context, idx)
			self.app:Send("GedNotifyPropertyChanged", self.parent_obj_context, self.prop_id)
			button:SetFocus(false)
		end
		delete_button:SetEnabled(not read_only)
	end
	
	if self:ShouldShowButtonForFunc("GedOpListDuplicate") then
		local duplicate_button = XTemplateSpawn("GedToolbarButtonSmall", self.idTitleContainer)
		duplicate_button:SetIcon("CommonAssets/UI/Ged/duplicate.tga")
		duplicate_button:SetRolloverText("Duplicate")
		duplicate_button.OnPress = function(button)
			local idx = table.find(self.parent, self)
			button:SetFocus()
			self.app:Op("GedOpListDuplicate", self.list_context, { idx })
			self.app:Send("GedNotifyPropertyChanged", self.parent_obj_context, self.prop_id)
			GetParentOfKind(self, "GedPropNestedList").new_item_idx = idx + 1
			button:SetFocus(false)
		end
		duplicate_button:SetEnabled(not read_only)
	end
	
	self.selection_mark = XWindow:new({ MinWidth = 3, Dock = "left", ZOrder = 0, HandleMouse = true }, self)
	
	GedNestedPropDragAndDrop:new({
		Id = "idDragAndDrop",
		Dock = "left",
		Padding = box(2, 1, 2, 1),
		List = GetParentOfKind(self, "XList"),
		Item = self,
		ZOrder = -1, 
	}, self)
	self.idDragAndDrop:SetEnabled(not read_only)

	-- find our GedPropPanel parent, and create a thread there to highlight the currently hovered GetNestedPropPanel
	local current_list = GetParentOfKind(self, "GedPropNestedList")
	local prop_panel = GetParentOfKind(self, "GedPropPanel")
	repeat
		prop_panel = GetParentOfKind(prop_panel.parent, "GedPropPanel")
	until prop_panel.class == "GedPropPanel"
	
	if not prop_panel:IsThreadRunning("NestedItemRolloverThread") then
		prop_panel:CreateThread("NestedItemRolloverThread", function(self)
			local last_rollover
			while true do
				local pt = terminal.GetMousePos()
				local list = GetParentOfKind(terminal.desktop:GetMouseTarget(pt), "GedPropNestedList")
				list = list and list.idList
				local rollover = list and list[list:GetItemAt(pt)]
				if rollover ~= last_rollover then
					if rollover and not rollover.selected then
						rollover.selection_mark:SetBackground(GetDarkModeSetting() and RGB(128, 128, 128) or RGB(180, 180, 180))
					end
					if last_rollover and not last_rollover.selected then
						last_rollover.selection_mark:SetBackground(0)
					end
					
					if last_rollover then
						last_rollover.RolloverTemplate = nil
						last_rollover.RolloverText = nil
						last_rollover.RolloverAnchor = nil
					end
					if rollover and list:GetSelection() and #list:GetSelection() == 1 and list:GetItemCount() > 1 then
						rollover.RolloverTemplate = "GedPropRollover"
						rollover.RolloverText = "Hold Ctrl or Shift to select multiple list elements."
						rollover.RolloverAnchor = "bottom"
					end
					
					last_rollover = rollover
				end
				Sleep(50)
			end
		end, prop_panel)
	end
	
	Msg("XWindowRecreated", self)
end

--- When the GedNestedPropPanel receives focus, this function sets the selection of the parent panel to the current panel.
---
--- This ensures that when the user interacts with the nested panel, the parent panel's selection reflects the currently focused nested panel.
function GedNestedPropPanel:OnSetFocus()
	self.parent:SetSelection(table.find(self.parent, self))
end

--- Calculates the background for the GedNestedPropPanel.
---
--- This function overrides the default background calculation for the GedNestedPropPanel, ensuring that the background does not change when the panel is selected.
---
--- @return table The calculated background for the GedNestedPropPanel.
function GedNestedPropPanel:CalcBackground()
	return XContextControl.CalcBackground(self) -- don't change background when selected
end

--- Sets the selected state of the GedNestedPropPanel.
---
--- This function is responsible for updating the appearance of the panel's selection mark based on the selected state. It also ensures that when a nested panel is selected, all other nested panels in the same properties panel are deselected.
---
--- @param selected boolean Whether the panel should be selected or not.
function GedNestedPropPanel:SetSelected(selected)
	if self.selected ~= selected then
		self.selected = selected
		self.selection_mark:SetBackground(selected and (GetDarkModeSetting() and RGB(180, 180, 180) or RGB(128, 128, 128)) or 0)
		if selected then
			-- unselect items in all other nested lists in the same properties panel
			local current_list = GetParentOfKind(self, "GedPropNestedList")
			local prop_panel = GetParentOfKind(self, "GedPropPanel")
			repeat
				prop_panel = GetParentOfKind(prop_panel.parent, "GedPropPanel")
			until prop_panel.class == "GedPropPanel"
			for _, list in ipairs(get_children_of_classes(prop_panel, nil, "GedPropNestedList")) do
				if list ~= current_list then
					list.idList:SetSelection(false)
				end
			end
		end
	end
end


GedPropEditors["nested_list"] = "GedPropNestedList"
DefineClass.GedPropNestedList = {
	__parents = { "GedPropEmbeddedObject", "GedPanelBase" },
	
	Interactive = true,
	new_item_idx = false,
	last_move_items_time = 0,
	last_move_items_selection = empty_table,
	table_addr = false,
}

--- Handles the double-click event on the mouse button for the GedPropNestedList.
---
--- When the left mouse button is double-clicked, this function toggles the expanded state of all the nested panels in the list. If all panels are currently expanded, they will all be collapsed. If any panel is collapsed, they will all be expanded.
---
--- @param _ any Unused parameter for the mouse button event.
--- @param button string The mouse button that was double-clicked ("L" for left).
--- @return string "break" to indicate that the event has been handled and should not propagate further.
function GedPropNestedList:OnMouseButtonDoubleClick(_, button)
	if button == "L" then
		local expanded = true
		for _, panel in ipairs(self.idList or empty_table) do
			expanded = expanded and panel.expanded
		end
		for _, panel in ipairs(self.idList or empty_table) do
			panel:Expand(not expanded)
		end

		return "break"
	end
end

--- Initializes a GedPropNestedList object.
---
--- This function sets up the various UI elements and event handlers for a GedPropNestedList object. It creates buttons for creating new items, copying, pasting, and moving items up and down in the list. It also sets up the list view that displays the nested items.
---
--- @param parent table The parent object of the GedPropNestedList.
--- @param context table The context object associated with the GedPropNestedList.
--- @param prop_meta table The property metadata associated with the GedPropNestedList.
function GedPropNestedList:Init(parent, context, prop_meta)
	self.idCreateItemButton.OnPress = function(button)
		CreateRealTimeThread(function()
			local items = self.app:Call("GedGetNestedClassItems", self.panel.context, self.prop_meta.id)
			local title = string.format("New %s element", prop_meta.base_class)
			GedOpenCreateItemPopup(self, title, items, button, function(class)
				if self.window_state == "destroying" then return end
				local parent_context = self.panel.context
				self.app:Op("GedOpNestedListNewItem", parent_context, parent_context, prop_meta.id, self.idList:GetFocusedItem(), class)
				self.new_item_idx = (self.idList:GetFocusedItem() or #self.idList) + 1
				self:CollapseUnselected()
			end)
		end)
	end
	
	self.idCopyButton:SetRolloverText("Copy all")
	self.idCopyButton.OnPress = function(button)
		self.panel:SetFocus()
		self.app:Op("GedNestedListCopy", self.context, self.prop_meta.base_class)
	end
	self.idPasteButton:SetRolloverText("Paste over")
	self.idPasteButton.OnPress = function(button)
		self.panel:SetFocus()
		self.app:Op("GedNestedListPaste", self.panel.context, self.prop_meta.id, self.prop_meta.base_class)
	end
	
	local movedown_button = XTemplateSpawn("GedToolbarButtonSmall", self)
	movedown_button:SetId("idMoveDown")
	movedown_button:SetIcon("CommonAssets/UI/Ged/down.tga")
	movedown_button:SetRolloverText("Move item(s) down")
	movedown_button.OnPress = function(button)
		local idx, sel = self.idList:GetFocusedItem(), self.idList:GetSelection()
		local last_time, last_sel = self.last_move_items_time, self.last_move_items_selection
		if idx then
			-- don't allow multiple ops to reach the game before they get the chance to get executed
			if GetPreciseTicks() > last_time + 350 or not table.iequal(last_sel, sel) then
				button:SetFocus()
				self:CollapseUnselected()
				self.app:Op("GedOpListMoveDown", context, sel)
				self.app:Send("GedNotifyPropertyChanged", self.panel.context, prop_meta.id)
				button:SetFocus(false)
				
				self.last_move_items_time, self.last_move_items_selection = GetPreciseTicks(), sel
			end
		else
			CreateMessageBox(nil, Untranslated("Info"), Untranslated("Please select the item(s) you would like to move."))
		end
	end
	movedown_button:SetEnabled(not prop_meta.read_only)
	movedown_button:SetVisibleInstant(false)
	
	local moveup_button = XTemplateSpawn("GedToolbarButtonSmall", self)
	moveup_button:SetId("idMoveUp")
	moveup_button:SetIcon("CommonAssets/UI/Ged/up.tga")
	moveup_button:SetRolloverText("Move item(s) up")
	moveup_button.OnPress = function(button)
		local idx, sel = self.idList:GetFocusedItem(), self.idList:GetSelection()
		local last_time, last_sel = self.last_move_items_time, self.last_move_items_selection
		if idx then
			-- don't allow multiple ops to reach the game before they get the chance to get executed
			if GetPreciseTicks() > last_time + 350 or not table.iequal(last_sel, sel) then
				button:SetFocus()
				self:CollapseUnselected()
				self.app:Op("GedOpListMoveUp", context, sel)
				self.app:Send("GedNotifyPropertyChanged", self.panel.context, prop_meta.id)
				button:SetFocus(false)
				
				self.last_move_items_time, self.last_move_items_selection = GetPreciseTicks(), sel
			end
		else
			CreateMessageBox(nil, Untranslated("Info"), Untranslated("Please select the item(s) you would like to move."))
		end
	end
	moveup_button:SetEnabled(not prop_meta.read_only)
	moveup_button:SetVisibleInstant(false)
	
	XList:new({
		Id = "idList",
		Dock = "bottom",
		ZOrder = -1,
		Margins = box(0, 0, 2, 0),
		BorderWidth = 0,
		FoldWhenHidden = true,
		Visible = false,
		MultipleSelection = true,
	}, self)
	self.idList.OnShortcut = function(list, shortcut, source, ...)
		if shortcut == "Ctrl-C" then
			self.app:Op("GedOpListCopy", self.context, list:GetSelection(), prop_meta.base_class)
			return "break"
		elseif shortcut == "Ctrl-X" then
			self.app:Op("GedOpListCut", self.context, list:GetSelection(), prop_meta.base_class)
			return "break"
		elseif shortcut == "Ctrl-V" then
			self.app:Op("GedOpListPaste", self.context, list:GetSelection(), prop_meta.base_class)
			return "break"
		end
	end
	self.idList.OnSelection = function(list, selected)
		self.idMoveUp:SetVisibleInstant(selected)
		self.idMoveDown:SetVisibleInstant(selected)
	end
end

--- Detaches the GedPropNestedList object from its views and clears the idList.
--- Unbinds the views, clears the idList, and resets the table_addr.
--- Then calls the DetachForReuse method of the parent GedPropEditor class.
---@method DetachForReuse
function GedPropNestedList:DetachForReuse()
	self:UnbindViews()
	for _, prop_panel in ipairs(self.idList) do
		prop_panel:UnbindViews()
	end
	self.idList:Clear()
	self.table_addr = false
	GedPropEditor.DetachForReuse(self)
end

---Collapses all unselected nested property panels in the idList.
---
---This function iterates through the idList and collapses any nested property panels
---that are not currently selected. This is useful for maintaining a clean and organized
---view of the nested properties.
---@method CollapseUnselected
function GedPropNestedList:CollapseUnselected()
	local list = self.idList
	for i, win in pairs(list) do
		if IsKindOf(win, "GedNestedPropPanel") and not win.selected and win.context then
			win:Expand(false)
		end
	end
end

---Gets the currently selected item(s) from the nested property list.
---
---This function returns the first selected item from the nested property list, as well as the full list of selected items.
---
---@return any, table The first selected item, and the full list of selected items.
function GedPropNestedList:GetSelection()
	local selection = self.idList:GetSelection()
	if not selection then return end
	return selection[1], selection
end

---Sets the selection of the nested property list.
---
---@param selection any The item(s) to select in the nested property list.
---@param multiple_selection boolean Whether to allow multiple items to be selected.
function GedPropNestedList:SetSelection(selection, multiple_selection)
	self.idList:SetSelection(multiple_selection or selection)
end

---Reassigns the focus order of the nested property panels in the GedPropNestedList.
---
---This function first calls the ReassignFocusOrders method of the parent GedPropEmbeddedObject class,
---then iterates through the idList of nested property panels and calls their ReassignFocusOrders
---method as well. This ensures that the focus order is properly reassigned for the entire
---nested property list.
---
---@param x number The starting x-coordinate for the focus order.
---@param y number The starting y-coordinate for the focus order.
---@return number The next y-coordinate after reassigning the focus order.
function GedPropNestedList:ReassignFocusOrders(x, y)
	y = GedPropEmbeddedObject.ReassignFocusOrders(self, x, y)
	for _, prop_panel in ipairs(self.idList) do
		y = prop_panel:ReassignFocusOrders(x, y)
	end
	return y
end

---Updates the value of the GedPropNestedList.
---
---This function is responsible for updating the value of the GedPropNestedList. It performs the following tasks:
---
---1. Calls the `UpdateValue` method of the parent `GedPropEmbeddedObject` class.
---2. Retrieves the current property metadata and the list of nested property panels.
---3. If the property value is undefined, it clears the list and sets the value text to "(undefined)".
---4. If the property value has changed, it binds the object context to the property.
---5. Detaches any old property panels that are not currently docked, to reuse them if the object address matches.
---6. Updates the list of nested property panels, reusing old panels where the object addresses match.
---7. Sets up the selection of the nested property panels, focusing on the new item if it exists.
---8. Queues a reassignment of the focus orders for the nested property panels.
---9. Sets the value text to the number of objects in the property.
---
---@method UpdateValue
function GedPropNestedList:UpdateValue()
	GedPropEmbeddedObject.UpdateValue(self)
	
	local item_data = self:GetProp()
	local prop_meta = self.prop_meta
	local list = self.idList
	if item_data == Undefined() then
		list:Clear()
		self.idValueText:SetText("(undefined)")
		return
	end
	
	if (item_data and item_data.table_addr or false) ~= self.table_addr then
		self.connection:BindObj(self.context, { self.panel.context, "prop:" .. prop_meta.id })
		self.table_addr = item_data.table_addr
	end
	
	-- detach old item panels to reuse them if they stayed the same (are displaying the same object)
	local old_panels = {}
	local old_sel = table.map(list:GetSelection(), function(idx) return list[idx].item_addr end)
	for i = #list, 1, -1 do
		local win = list[i]
		if not win.Dock or win.Dock == "ignore" then
			table.insert(old_panels, win)
			win:SetFocused(false)
			win:SetSelected(false)
			win:SetParent(false)
		end
	end
	
	-- update list, reusing old panel where the object addresses match
	local binding_map = {}
	for idx, addr in ipairs(type(item_data) == "table" and item_data) do
		local item_context = self.context .. "." .. addr
		local panel = table.find_value(old_panels, "item_addr", addr)
		if panel then
			table.remove_value(old_panels, panel)
			panel:SetParent(list)
		else
			local panel = GedNestedPropPanel:new({
				Title = prop_meta.format or "<EditorView>",
				RootObjectBindName = self.panel.RootObjectBindName,
				StartsExpanded = prop_meta.auto_expand or self.new_item_idx and idx == self.new_item_idx,
				prop_id = prop_meta.id,
				read_only = prop_meta.read_only,
				item_addr = addr,
				list_context = self.context,
				parent_obj_context = self.panel.context,
			}, self.idList, item_context)
			panel:Open()
			self.connection:BindObj(item_context, { self.context, idx })
		end
	end
	for _, panel in ipairs(old_panels) do
		panel:delete()
	end
	
	-- setup selection, etc.
	list:SetVisible(#item_data > 0)
	if self.new_item_idx then
		list:SetFocus(true)
		list:SetSelection(self.new_item_idx)
		self.new_item_idx = false
	else
		local sel = {}
		for _, addr in ipairs(old_sel) do
			local new_idx = table.findfirst(list, function(idx, item) return item.item_addr == addr end)
			if new_idx then
				table.insert(sel, new_idx)
			end
		end
		list:SetSelection(sel)
	end
	
	self:QueueReassignFocusOrders()
	self.idValueText:SetText(string.format("(%d objects)", #item_data))
end

---
--- Updates the property names for all nested property panels in this list.
---
--- @param internal boolean Whether the update is being triggered internally.
---
function GedPropNestedList:UpdatePropertyNames(internal)
	for _, prop_panel in ipairs(self.idList) do
		prop_panel:UpdatePropertyNames(internal)
	end
	GedPropEditor.UpdatePropertyNames(self, internal)
end


----- GedPropLinkedPresets

GedPropEditors["linked_presets"] = "GedPropLinkedPresets"

-- caption comes from prop_meta.help; Create/Delete buttons come from prop_meta.buttons (both set in Ged.lua)
DefineClass.GedPropLinkedPresets = {
	__parents = { "GedPropHelp" },
	LayoutMethod = "VList",
}

---
--- Calculates the background color for the GedPropLinkedPresets UI element.
---
--- The background color is interpolated between a base color (based on the dark mode setting)
--- and the GedHighlight text color, with a weight of 1 out of 3.
---
--- @return RGB The calculated background color.
---
function GedPropLinkedPresets:CalcBackground()
	local base = GetDarkModeSetting() and RGB(32, 32, 32) or RGB(240, 240, 240)
	return InterpolateRGB(base, TextStyles.GedHighlight.TextColor, 1, 3)
end

---
--- Updates the value of the GedPropLinkedPresets UI element.
---
--- This function is called when the initial value of the property is set.
--- It creates a new GedPropPanel for each preset class defined in the property metadata,
--- configures it with the appropriate settings, and adds it to the GedPropLinkedPresets UI.
--- It also adds a button to the panel's title container that allows the user to open the
--- preset editor for the corresponding preset class.
---
--- @param initial boolean Whether this is the initial value update.
---
function GedPropLinkedPresets:UpdateValue(initial)
	if not initial then return end
	
	local prop_meta = self.prop_meta
	for _, class in ipairs(prop_meta.preset_classes) do
		local suppress_props = {}
		for prop, value in pairs(prop_meta.suppress_props) do
			suppress_props[prop] = suppress_props[prop] or (value == true)
		end
		for prop, value in pairs(prop_meta.suppress_props[class]) do
			suppress_props[prop] = suppress_props[prop] or (value == true)
		end
		
		local panel_context = self.panel.context .. "." .. class
		local panel = GedPropPanel:new({
			preset_class = class,
			
			FoldWhenHidden = true,
			Embedded = true,
			Collapsible = true,
			HideFirstCategory = true,
			RootObjectBindName = self.panel.RootObjectBindName,
			Title = "<style GedHighlight>" .. class,
			ActionsClass = "PropertyObject",
			Copy = "GedOpPropertyCopy",
			Paste = "GedOpPropertyPaste",
			SuppressProps = suppress_props,
		}, self, panel_context)
		panel:SetVisible(false)
		panel:Open()
		
		if self:ShouldShowButtonForFunc("GedRpcEditPreset") then
			local open_button = XTemplateSpawn("GedToolbarButtonSmall", panel.idTitleContainer)
			open_button:SetIcon("CommonAssets/UI/Ged/explorer.tga")
			open_button:SetRolloverText("Open Preset Editor")
			open_button.OnPress = function(button)
				button:SetFocus()
				panel.app:Send("GedRpcEditPreset", panel.context)
				button:SetFocus(false)
			end
			open_button:Open()
		end
		
		self.panel.app:Call("GedRpcBindLinkedPreset", panel_context, self.panel.context, class)
	end
	
	-- GedPropHelp.UpdateValue(self) -- no need to call, this type of property is virtual and has no value
end

--- Detaches and deletes all the `GedPropPanel` instances associated with this `GedPropLinkedPresets` instance, and then calls the `DetachForReuse` function from the `GedPropHelp` module.
---
--- This function is used to clean up and prepare this `GedPropLinkedPresets` instance for reuse, by removing all the associated `GedPropPanel` instances and resetting any necessary state.
function GedPropLinkedPresets:DetachForReuse()
	for i = #self, 1, -1 do
		local win = self[i]
		if IsKindOf(win, "GedPropPanel") then
			win:UnbindViews()
			win:delete()
		end
	end
	GedPropHelp.DetachForReuse(self)
end


----- GedPropPrimitiveList base class
-- Override ConvertToText and ConvertFromText to validate and display values


DefineClass.GedPropPrimitiveListDragAndDrop = {
	__parents = { "GedPropListDragAndDrop" },
	prop_parent_class = "GedPropPrimitiveList",
}

---
--- Returns the edit control associated with the given control.
---
--- If the control has an `idEdit` field, that is returned. Otherwise, if the control has an `idCombo` field with an `idEdit` field, that is returned.
---
--- @param control table The control to get the edit control for.
--- @return table|nil The edit control associated with the given control, or `nil` if no edit control is found.
function GedPropPrimitiveListDragAndDrop:GetDragWindowTextControl(control)
	return control.idEdit or control.idCombo and control.idCombo.idEdit
end

---
--- Handles the drop event for a `GedPropPrimitiveListDragAndDrop` instance.
---
--- This function is called when an item is dropped onto the list. It rearranges the list items based on the drop position and updates the list values and controls accordingly.
---
--- @param drag_win table The window that was being dragged.
--- @param pt table The position where the item was dropped.
--- @param drag_source_win table The window that was the source of the drag.
function GedPropPrimitiveListDragAndDrop:OnDrop(drag_win, pt, drag_source_win)
	if self:GetDragAndDropError() then return end
	local list = ged_drag_target
	local prop_list = GetParentOfKind(list, self.prop_parent_class)
	local sel = list:GetSelection()
	if #sel == 0 then return end 
	local sel_map = {}
	for _, sel_idx in ipairs(sel) do
		sel_map[sel_idx] = true
	end
	local drop_target_idx = table.find(list, ged_drop_target)
	assert(drop_target_idx)
	if not drop_target_idx then return end
	if ged_drop_type == "Down" then
		if sel[1] > drop_target_idx then
			drop_target_idx = Min(#prop_list.list_values, drop_target_idx + 1)
		end
	elseif sel[1] < drop_target_idx then
		drop_target_idx = Max(1, drop_target_idx - 1)
	end
	local values = {}
	local i = 1
	local values_cnt = 0
	for _, value in ipairs(prop_list.list_values) do
		if values_cnt == drop_target_idx - 1 then
			break
		end
		if not sel_map[i] then
			values_cnt = values_cnt + 1
			values[values_cnt] = value
		end
		i = i + 1
	end
	local new_selection = {}
	for _, sel_idx in ipairs(sel) do
		values_cnt = values_cnt + 1
		values[values_cnt] = prop_list.list_values[sel_idx]
		new_selection[#new_selection + 1] = values_cnt
	end
	for j = i, #prop_list.list_values do
		if not sel_map[j] then
			values_cnt = values_cnt + 1
			values[values_cnt] = prop_list.list_values[j]
		end
	end
	prop_list.list_values = values
	prop_list:SetProp(values)
	prop_list:UpdateControls()
	list:SetSelection(new_selection)
end

local function ItemText(item)
	if type(item) == "table" then
		return item.name or item.text or item.id
	end
	return tostring(item)
end

local function ItemId(item)
	if type(item) == "table" then
		return item.id or (item.value ~= nil and item.value)
	end
	return item
end

DefineClass.GedPropPrimitiveList = {
	__parents = { "GedPropEditor" },
	
	Translate = false,
	list_values = false,
	new_item_default = false,
	
	choice_items = false,
	choice_items_status = false,
	choice_items_fetch_time = false,
}

---
--- Initializes a `GedPropPrimitiveList` object, which is a type of `GedPropEditor` that manages a list of primitive values.
---
--- The `Init` function sets up the UI elements for the list, including an "Add new" button, "Move up" and "Move down" buttons, and a list container to display the list items.
---
--- The function also sets up event handlers for the buttons, allowing the user to add new items, move items up or down in the list, and update the list values and controls accordingly.
---
--- @param parent table The parent object for this `GedPropPrimitiveList`.
--- @param context table The context object for this `GedPropPrimitiveList`.
--- @param prop_meta table The metadata for the property being edited by this `GedPropPrimitiveList`.
---
function GedPropPrimitiveList:Init(parent, context, prop_meta)
	self.idLabelHost:SetDock("top")
	
	local add_button = XTemplateSpawn("GedToolbarButtonSmall", self.idLabelHost)
	add_button:SetIcon("CommonAssets/UI/Ged/new.tga")
	add_button:SetRolloverText("Add new")
	add_button:SetId("idNewElement")
	add_button:SetEnabled(not prop_meta.read_only)
	add_button.OnPress = function(button)
		local focus = terminal.desktop.keyboard_focus
		button:SetFocus()
		if focus and focus ~= self.idContainer and focus:IsWithin(self.idContainer) then
			-- search for item element so we can find its index
			while focus.parent ~= self.idContainer do
				focus = focus.parent
			end
			self:NewElement(table.find(self.idContainer, focus))
			button:SetFocus(false)
			return
		end
		self:NewElement(table.max(self.idContainer:GetSelection()))
		button:SetFocus(false)
	end
	
	local move_down = XTemplateSpawn("GedToolbarButtonSmall", self.idLabelHost)
	move_down:SetIcon("CommonAssets/UI/Ged/down.tga")
	move_down:SetRolloverText("Move down\n(select an item first)")
	move_down:SetId("idDown")
	move_down:SetEnabled(false)
	move_down.OnPress = function(button)
		local sel = table.copy(self.idContainer:GetSelection())
		local values = table.copy(self.list_values)
		local focus
		for i = #values - 1, 1, -1 do
			local idx = table.find(sel, i)
			if idx and not table.find(sel, i + 1) then
				values[i], values[i + 1] = values[i + 1], values[i]
				sel[idx] = i + 1
				if self.idContainer[i]:IsFocused(true) then
					self.idContainer[i]:SetFocus(false)
					focus = i + 1
				end
			end
		end
		self.list_values = values
		self:SetProp(values)
		self:UpdateControls()
		if focus then
			self.idContainer[focus][1]:SetFocus()
		end
		self.idContainer:SetSelection(sel)
	end
	
	local move_up = XTemplateSpawn("GedToolbarButtonSmall", self.idLabelHost)
	move_up:SetIcon("CommonAssets/UI/Ged/up.tga")
	move_up:SetRolloverText("Move up\n(select an item first)")
	move_up:SetId("idUp")
	move_up:SetEnabled(false)
	move_up.OnPress = function(button)
		local sel = table.copy(self.idContainer:GetSelection())
		local values = table.copy(self.list_values)
		local focus
		for i = 2, #values do
			local idx = table.find(sel, i)
			if idx and not table.find(sel, i - 1)  then
				values[i], values[i - 1] = values[i - 1], values[i]
				sel[idx] = i - 1
				if self.idContainer[i]:IsFocused(true) then
					self.idContainer[i]:SetFocus(false)
					focus = i - 1
				end
			end
		end
		self.list_values = values
		self:SetProp(values)
		self:UpdateControls()
		if focus then
			self.idContainer[focus][1]:SetFocus()
		end
		self.idContainer:SetSelection(sel)
	end
	
	XList:new({
		Id = "idContainer",
		Dock = "bottom",
		BorderWidth = 0,
		MultipleSelection = true,
		OnSelection = function(list, focused_item, selection)
			self.idUp:SetEnabled(next(selection) and not prop_meta.read_only)
			self.idDown:SetEnabled(next(selection) and not prop_meta.read_only)
		end
	}, self)
	self:WithItems(function(items)
		self:ValidatePropMetaAndInitDefault()
	end)
end

---
--- Detaches the GedPropPrimitiveList instance from its current state and prepares it for reuse.
--- This method is responsible for:
--- - Clearing the selection of the idContainer list
--- - Updating the MRU (Most Recently Used) list of any ComboBox controls in the idContainer list
--- - Calling the DetachForReuse method of the parent GedPropEditor class
---
--- @param self GedPropPrimitiveList The instance of the GedPropPrimitiveList class
---
function GedPropPrimitiveList:DetachForReuse()
	self.idContainer:SetSelection(false)
	for _, item in ipairs(self.idContainer) do
		if rawget(item, "idCombo") then
			item.idCombo:UpdateMRUList()
		end
	end
	GedPropEditor.DetachForReuse(self)
end

---
--- Calls the provided function `f` with the choice items, ensuring that the choice items have been fetched and are available.
---
--- If the choice items have already been fetched, the function `f` is called immediately with the choice items.
---
--- If the choice items have not yet been fetched, this method will wait for the choice items to be fetched before calling the function `f`.
---
--- @param self GedPropPrimitiveList The instance of the GedPropPrimitiveList class
--- @param f function The function to call with the choice items
---
function GedPropPrimitiveList:WithItems(f)
	if self.choice_items_status == "fetched" then
		f(self.choice_items)
	else
		CreateRealTimeThread(function()
			self:WaitForItems()
			if self.window_state ~= "destroying" then
				f(self.choice_items)
			end
		end)
	end
end

---
--- Waits for the choice items to be fetched and available.
---
--- If the choice items have already been fetched, this method returns the choice items immediately.
---
--- If the choice items have not yet been fetched, this method will wait for the choice items to be fetched before returning them.
---
--- @param self GedPropPrimitiveList The instance of the GedPropPrimitiveList class
--- @return table The fetched choice items
---
function GedPropPrimitiveList:WaitForItems()
	assert(CanYield())
	if self.choice_items_status == false or self.choice_items_status == "fetched" and self.choice_items_fetch_time ~= RealTime() then
		self.choice_items_status = { }
		CreateRealTimeThread(function()
			local old_status = self.choice_items_status
			repeat
				self.choice_items = self:GetChoiceItems()
			until self.choice_items ~= "timeout"
			self.choice_items_status = "fetched"
			self.choice_items_fetch_time = RealTime()
			for _, thread in ipairs(old_status) do
				Wakeup(thread)
			end
		end)
	elseif self.choice_items_status == "fetched" then
		return self.choice_items
	else
		assert( type(self.choice_items_status) == "table" )
	end
	table.insert(self.choice_items_status, CurrentThread())
	WaitWakeup()
	return self.choice_items
end

---
--- Reassigns the focus order of the UI elements in the GedPropPrimitiveList.
---
--- @param self GedPropPrimitiveList The instance of the GedPropPrimitiveList class
--- @param x number The starting x-coordinate for the focus order
--- @param y number The starting y-coordinate for the focus order
--- @return number The updated y-coordinate after reassigning the focus order
---
function GedPropPrimitiveList:ReassignFocusOrders(x, y)
	self.idUp:SetFocusOrder(point(x, y))
	y = y + 1
	self.idDown:SetFocusOrder(point(x, y))
	y = y + 1
	self.idNewElement:SetFocusOrder(point(x, y))
	y = y + 1
	local container = self.idContainer
	for _, edit in ipairs(container) do
		edit:SetFocusOrder(point(x, y))
		y = y + 1
	end
	return y
end

---
--- Validates the property metadata and initializes the default value for a new item in the GedPropPrimitiveList.
---
--- This function performs the following tasks:
--- - Asserts that the choice items have been fetched successfully.
--- - Clears any existing property result error.
--- - Validates the choice items, if any, by checking that each item's value is valid.
--- - Determines the default value for a new item, either from the `item_default` property metadata or the first choice item's value.
--- - Validates the determined default value and caches it in the `new_item_default` field.
---
--- @param self GedPropPrimitiveList The instance of the GedPropPrimitiveList class.
function GedPropPrimitiveList:ValidatePropMetaAndInitDefault()
	assert(self.choice_items_status == "fetched")
	self:SetPropResult("")
	
	-- Validate choice items
	local choice_items = self.choice_items
	if choice_items then
		for _, item in ipairs(choice_items) do
			 self:CheckUpdateError(self:ValidateValue(item.value), "'items' contains invalid entries.")
		end
	end
	
	-- Validate and cache item_default
	local item_default = self.prop_meta.item_default or self:DefaultValue()
	if item_default and choice_items then
		local value_default = choice_items and choice_items[1] and choice_items[1].value or item_default
		self.new_item_default = value_default
	else
		self.new_item_default = item_default
	end
	self:CheckUpdateError(self:ValidateValue(self.new_item_default), "Invalid 'item_default'")
end

---
--- Validates the sum of all weights in the list_values array.
---
--- If the list_values array is empty, this function returns true.
--- Otherwise, it calculates the sum of all weights in the list_values array
--- and returns true if the sum is greater than 0, false otherwise.
---
--- @param self GedPropPrimitiveList The instance of the GedPropPrimitiveList class.
--- @return boolean True if the sum of all weights is greater than 0, false otherwise.
function GedPropPrimitiveList:ValidateWeights()
	if #self.list_values == 0 then
		return true
	end
	local weight_sum = 0
	for _, item in ipairs(self.list_values) do
		local _, weight = self:ResolveItem(item)
		if weight then
			weight_sum = weight_sum + weight
		end
	end
	return weight_sum > 0
end

---
--- Checks if the sum of all weights in the `list_values` array is greater than zero.
---
--- If the `prop_meta` has a `weights` field, this function will call `ValidateWeights()` and
--- set the `PropResult` to an error message if the sum of weights is not greater than zero.
---
--- @param self GedPropPrimitiveList The instance of the GedPropPrimitiveList class.
function GedPropPrimitiveList:CheckWeightsError()
	if self.prop_meta and self.prop_meta.weights then
		self:CheckUpdateError(self:ValidateWeights(), "The sum of all weights has to be more than zero")
	end
end

---
--- Checks if the given expression is false, and if so, sets the PropResult to the provided error message.
---
--- @param self GedPropPrimitiveList The instance of the GedPropPrimitiveList class.
--- @param expr boolean The expression to check.
--- @param err string The error message to set if the expression is false.
---
function GedPropPrimitiveList:CheckUpdateError(expr, err)
	if not expr then
		self:SetPropResult(err)
	end
end

---
--- Adds a new element to the list of values in the GedPropPrimitiveList.
---
--- If the `max_items` property is set and the list of values has reached the maximum, this function will return an error message instead of adding a new element.
---
--- Otherwise, this function will:
--- - Get the current list of values
--- - Create a new item value based on the `copy_item_value` parameter
--- - Insert the new item value into the list at the specified `idx` position (or at the end of the list if `idx` is not provided)
--- - Update the list of values in the GedPropPrimitiveList
--- - Update the UI controls to display the new element
--- - Set the focus on the newly added element
--- - Set the updated list of values as the property value
---
--- @param self GedPropPrimitiveList The instance of the GedPropPrimitiveList class.
--- @param idx number The index at which to insert the new element (optional).
--- @param copy_item_value boolean Whether to copy the value of the element at the specified index (optional).
--- @return nil
function GedPropPrimitiveList:NewElement(idx, copy_item_value)
	local max_items = self.prop_meta.max_items or -1
	if max_items ~= -1 and #self.list_values >= max_items then
		return self:SetPropResult("Can not add more than "..tostring(max_items).." items to the list.")
	end
	
	self:WithItems(function()
		local list_values = self.list_values or {}
		local new_item_value = copy_item_value and list_values[idx] or self.new_item_default
		idx = (idx or #list_values) + 1
		local new_item = self:WrapValue(new_item_value)
		table.insert(list_values, idx, new_item)
		self.list_values = list_values
		
		self:UpdateControls() -- will spawn the new control
		local last = self.idContainer[idx]
		if last then
			last:SetFocus()
		end
		
		self:SetProp(list_values)
		self.idContainer:SetSelection(false)
	end)
end

---
--- Removes an element from the list of values in the GedPropPrimitiveList.
---
--- This function will:
--- - Get the current list of values
--- - Remove the element at the specified `idx` index from the list
--- - Update the UI controls to remove the corresponding element
--- - Set the updated list of values as the property value
--- - If the `max_items` property is set and the list of values is now less than or equal to the maximum, clear any previous property result error
---
--- @param self GedPropPrimitiveList The instance of the GedPropPrimitiveList class.
--- @param idx number The index of the element to remove.
--- @return nil
function GedPropPrimitiveList:RemoveElement(idx)
	if self:IsFocused(true) then
		assert(IsKindOf(self.desktop.keyboard_focus, "XButton"))
	end
	local list_values = self.list_values or {}
	if #list_values >= idx then
		table.remove(list_values, idx)
		local container = self.idContainer
		container[idx]:delete()
		self:UpdateControls()
		self:SetProp(list_values)
	end
	
	local max_items = self.prop_meta.max_items or -1
	if max_items ~= -1 and #self.list_values <= max_items then
		self:SetPropResult()
	end
end

---
--- Resolves the value and weight of a list item.
---
--- If the item is a table, this function will extract the value and weight from the table based on the `value_key` and `weight_key` properties of the `prop_meta` table.
---
--- @param item table|any The list item to resolve.
--- @return any, number The value and weight of the list item.
function GedPropPrimitiveList:ResolveItem(item)
	local prop_meta = self.prop_meta or empty_table
	if not item or not prop_meta.weights then
		return item
	end
	local value_key = prop_meta.value_key or "value"
	local weight_key = prop_meta.weight_key or "weight"
	return item[value_key], item[weight_key]
end

---
--- Sets the element at the specified index in the list of values.
---
--- This function will:
--- - Get the current list of values
--- - Resolve the old and new values and weights of the list item
--- - Check if the value or weight has changed
--- - If the item has changed, update the list of values and set the property value
--- - Notify that the list item value has changed
---
--- @param idx number The index of the element to set.
--- @param value any The new value for the list item.
--- @return nil
function GedPropPrimitiveList:SetElement(idx, value)
	local list_values = self.list_values or {}

	local old_value, old_weight = self:ResolveItem(list_values[idx])
	local new_value, new_weight = self:ResolveItem(value)
	local has_changed = old_value ~= new_value or old_weight ~= new_weight
	
	if idx and has_changed then
		list_values[idx] = value
		self.list_values = list_values
		self:SetProp(list_values)
		self:OnListItemValueChanged(idx)
	end
end

---
--- Gets the choice items for the primitive list.
---
--- This function retrieves the list of choice items for the primitive list. If the `prop_meta.items` table is empty or not defined, it returns `false`. Otherwise, it converts the items to a table of `{ text = <item_text>, value = <item_value> }` format, where `item_text` is the text representation of the item and `item_value` is the actual value of the item.
---
--- @return table|false The list of choice items, or `false` if the list is empty.
function GedPropPrimitiveList:GetChoiceItems()
	local items = self.prop_meta.items
	if not items or #items <= 0 then
		return false
	end
	
	local t = {}
	for key, value in ipairs(items) do
		-- support most popular item formats
		if type(value) == "table" then
			table.insert(t, { text = ItemText(value), value = ItemId(value) })
		else
			table.insert(t, { text = self:ConvertToText(value), value = value })
		end
	end
	return t
end

---
--- Wraps a value with a weight, if the property metadata specifies that weights are used.
---
--- @param value any The value to wrap.
--- @param weight number The weight to associate with the value.
--- @return table The wrapped value and weight.
function GedPropPrimitiveList:WrapValue(value, weight)
	local prop_meta = self.prop_meta or empty_table
	assert(not (type(value) == "table" and not (prop_meta.editor == "T_list")), "Weighted list - Wrapping a table value")
	if not prop_meta.weights then
		return value
	end
	local value_key = prop_meta.value_key or "value"
	local weight_key = prop_meta.weight_key or "weight"
	return {[value_key] = value, [weight_key] = weight or self:DefaultWeightValue()}
end

---
--- Updates an item in the primitive list.
---
--- @param container table The container that holds the list item.
--- @param item table The list item to update.
--- @param value any The new value for the list item.
--- @param weight_ctrl table The weight control for the list item.
function GedPropPrimitiveList:UpdateItem(container, item, value, weight_ctrl)
	self:SetElement(
		table.find(container, item),
		self:WrapValue(value, weight_ctrl and weight_ctrl:GetNumber())
	)
end

---
--- Creates a new item editor for the primitive list.
---
--- @param container table The container that holds the list items.
--- @param choice_items table The list of choice items for the list.
--- @param idx number The index of the new list item.
function GedPropPrimitiveList:CreateItemEditor(container, choice_items, idx)
	local item = XListItem:new({
		BorderWidth = 0,
		Padding = box(2, 2, 2, 2),
		SelectionBackground = RGB(204, 232, 255),
		SetFocus = function(item, focus)
			if item.idEdit then
				return item.idEdit:SetFocus(focus)
			elseif item.idCombo then
				return item.idCombo:SetFocus(focus)
			end
			return XWindow.SetFocus(item, focus)
		end,
		SetValue = function(item, value)
			local actual_value, weight = self:ResolveItem(value)
			if weight and item.idWeightEdit then
				item.idWeightEdit:SetNumber(weight)
			end
			if item.idEdit then
				item.idEdit:SetText(self:ConvertToText(actual_value))
			elseif item.idCombo then
				item.idCombo:SetValue(actual_value)
			end
			self:OnListItemValueChanged(idx)
		end,
		SetFocusOrder = function(item, order)
			if item.idEdit then
				item.idEdit:SetFocusOrder(order)
			elseif item.idCombo then
				item.idCombo:SetFocusOrder(order)
			end
		end,
		idEdit = false,
		idCombo = false,
		IdNode = true, -- capture the nodes above
		idWeightEdit = false
	}, container)
	
	local control
	local weight_control
	
	if self.prop_meta.weights then
		local weight_label = XText:new({
			Id = "idWeightLabel", 
			Dock = "right",
			MinWidth = 50,
			ZOrder = 3, -- Order in the component tree (default = 1)
			Margins = box(5, 0, 0, 0)
		}, item):SetText("Weight:")
		weight_control = XNumberEdit:new({
			Id = "idWeightEdit",
			MinWidth = 40,
			Dock = "right",
			ZOrder = 2, -- Order in the component tree (default = 1)
			Margins = box(2, 0, 2, 0)
		}, item)
		weight_control:SetEnabled(not self.prop_meta.read_only)
		weight_control.OnTextChanged = function(weight_edit)
			self:DeleteThread("SetElementWeightThread")
			self:CreateThread("SetElementWeightThread", function()
				Sleep(250)
				local value = (item.idEdit and self:ConvertFromText(item.idEdit:GetText())) or (item.idCombo and item.idCombo:GetValue())
				self:UpdateItem(container, item, value, weight_edit)
			end)
		end
	end
	
	if choice_items then
		control = XCombo:new({
			Id = "idCombo",
			RefreshItemsOnOpen = true,
			OnRequestItems = function() return self:WaitForItems() end,
			DefaultValue = self.new_item_default,
			ArbitraryValue = self.prop_meta.arbitraty_value,
			OnValueChanged = function(combo, value)
				self:UpdateItem(container, item, value, weight_control)
			end,
			MRUStorageId = self.prop_meta.mru_storage_id,
			MRUCount = self.prop_meta.show_recent_items,
			VirtualItems = true,
		}, item)
		control:SetEnabled(not self.prop_meta.read_only)
		control.OnSetFocus = function(control)
			container:SetSelection(idx)
			XCombo.OnSetFocus(control)
		end
	else
		control = self:CreateTextEditControl(item)
		control:SetEnabled(not self.prop_meta.read_only)
		control.OnTextChanged = function(edit)
			self:DeleteThread("SetElementThread")
			self:CreateThread("SetElementThread", function()
				Sleep(250)
				local value = self:ConvertFromText(edit:GetText())
				self:UpdateItem(container, item, value, weight_control)
			end)
		end
		control.OnKillFocus = function(edit, new_focus)
			local value = self:ConvertFromText(edit:GetText())
			self:UpdateItem(container, item, value, weight_control)
			return XTextEditor.OnKillFocus(edit, new_focus)
		end
		control.OnSetFocus = function(control)
			container:SetSelection(idx)
			XTextEditor.OnSetFocus(control)
		end
	end
	
	self:CreateAdditionalButtons(item, table.find(container, item))
	
	local delete_button = XTemplateSpawn("GedToolbarButtonSmall", item)
	delete_button:SetIcon("CommonAssets/UI/Ged/delete.tga")
	delete_button:SetRolloverText("Delete")
	delete_button.OnPress = function(button)
		button:SetFocus()
		self:RemoveElement(table.find(container, item))
		button:SetFocus(false)
	end
	delete_button:SetEnabled(not self.prop_meta.read_only)
	
	local duplicate_button = XTemplateSpawn("GedToolbarButtonSmall", item)
	duplicate_button:SetIcon("CommonAssets/UI/Ged/duplicate.tga")
	duplicate_button:SetRolloverText("Duplicate")
	duplicate_button.OnPress = function(button)
		button:SetFocus()
		self:NewElement(table.find(container, item), "copy_item_value")
		button:SetFocus(false)
	end
	duplicate_button:SetEnabled(not self.prop_meta.read_only)

	if self.prop_meta.per_item_buttons then
		self:SpawnCustomButtons(container, item, idx)
	end
	
	GedPropPrimitiveListDragAndDrop:new({
		Id = "idDragAndDrop",
		Dock = "left",
		Padding = box(2, 1, 2, 1),
		List = self.idContainer,
		Item = item,
	}, item)
	item.idDragAndDrop:SetEnabled(not self.prop_meta.read_only)

	item:Open()
end

---
--- Spawns custom buttons for each item in a GedPropPrimitiveList.
---
--- @param container table The container holding the list items.
--- @param item table The current list item.
--- @param idx number The index of the current list item.
---
function GedPropPrimitiveList:SpawnCustomButtons(container, item, idx)
	for _, button_props in ipairs(self.prop_meta.per_item_buttons) do
		local custom_button = XTemplateSpawn("GedToolbarButtonSmall", item)
		custom_button:SetIcon(button_props.icon)
		custom_button:SetRolloverText(button_props.name)
		custom_button.OnPress = function(button)
			button:SetFocus()
			if button_props.func then
				self.panel:Op("GedPropEditorButton", self.panel.context, self.panel.RootObjectBindName or "root",
					self.prop_meta.id, button_props.name, button_props.func, button_props.param, idx)
			end
			button:SetFocus(false)
		end
		custom_button:SetEnabled(not self.prop_meta.read_only)
	end
end

---
--- Called when the value of a list item in the GedPropPrimitiveList is changed.
---
--- @param idx number The index of the list item that was changed.
---
function GedPropPrimitiveList:OnListItemValueChanged(idx)
	self:CheckWeightsError()
end

---
--- Creates a new text edit control in the given parent container.
---
--- @param parent table The parent container for the text edit control.
--- @return table The newly created text edit control.
---
function GedPropPrimitiveList:CreateTextEditControl(parent)
	return XEdit:new({ Id = "idEdit" }, parent)
end

---
--- Creates additional buttons for the GedPropPrimitiveList.
---
--- @param parent table The parent container for the additional buttons.
--- @param idx number The index of the list item that the buttons are for.
---
function GedPropPrimitiveList:CreateAdditionalButtons(parent, idx)
end

---
--- Updates the controls in the GedPropPrimitiveList.
---
--- This function is responsible for managing the list of items in the GedPropPrimitiveList control. It ensures that the number of items in the list matches the number of values in the `list_values` table, creating or deleting items as necessary. It also updates the values of the individual items to match the values in the `list_values` table.
---
--- @param self GedPropPrimitiveList The GedPropPrimitiveList instance.
function GedPropPrimitiveList:UpdateControls()
	assert(self.choice_items_status == "fetched")
	local list_values = self.list_values
	local container = self.idContainer
	
	if #list_values ~= #container then
		self:QueueReassignFocusOrders()
	end
	
	-- remove unnecessary items
	while #list_values < #container do
		container[#list_values+1]:delete()
	end
	
	-- spawn additional items
	local choice_items = self.choice_items
	while #list_values > #container do
		self:CreateItemEditor(container, choice_items, #container + 1)
	end
	
	-- update controls' values
	for idx, item in ipairs(container) do
		item:SetValue(list_values[idx])
	end
	
	self:CheckWeightsError()
	
	Msg("XWindowRecreated", self)
end

---
--- Updates the value of the GedPropPrimitiveList.
---
--- This function is responsible for updating the `list_values` property of the GedPropPrimitiveList instance based on the current value of the associated property. If the current focus is not within the GedPropPrimitiveList or the length of the `data` table does not match the length of the `list_values` table, the `list_values` table is updated with a copy of the `data` table. The `UpdateControls()` function is then called to update the controls in the list. Finally, the `UpdateValue()` function of the parent `GedPropEditor` class is called.
---
--- @param self GedPropPrimitiveList The GedPropPrimitiveList instance.
function GedPropPrimitiveList:UpdateValue()
	local data = self:GetProp() or {}
	local focus = terminal.desktop.keyboard_focus
	if (not focus or not focus:IsWithin(self)) or #data ~= #(self.list_values or empty_table) then
		self.list_values = type(data) == "table" and table.copy(data) or {}
		self:WithItems(function()
			self:UpdateControls()
		end)
	end
	GedPropEditor.UpdateValue(self)
end

---
--- Converts the given text to the appropriate value for the GedPropPrimitiveList.
---
--- This function is responsible for converting the provided text string to the appropriate value for the GedPropPrimitiveList instance. In this case, the function simply returns the text as-is, as the GedPropPrimitiveList does not require any special conversion.
---
--- @param self GedPropPrimitiveList The GedPropPrimitiveList instance.
--- @param text string The text to be converted.
--- @return any The converted value.
function GedPropPrimitiveList:ConvertFromText(text)
	return text
end

---
--- Converts the given value to a text representation.
---
--- This function is responsible for converting the provided value to a text representation. In this case, the function simply returns the value as-is, as the GedPropPrimitiveList does not require any special conversion.
---
--- @param self GedPropPrimitiveList The GedPropPrimitiveList instance.
--- @param value any The value to be converted.
--- @return string The converted text.
function GedPropPrimitiveList:ConvertToText(value)
	return value
end

---
--- Returns the default value for the GedPropPrimitiveList.
---
--- This function returns the default value for the GedPropPrimitiveList, which is `false`.
---
--- @param self GedPropPrimitiveList The GedPropPrimitiveList instance.
--- @return boolean The default value for the GedPropPrimitiveList.
function GedPropPrimitiveList:DefaultValue()
	return false
end

---
--- Returns the default weight value for the GedPropPrimitiveList.
---
--- This function returns the default weight value for the GedPropPrimitiveList, which is either the value specified in the `prop_meta.weight_default` field, or 100 if that field is not set.
---
--- @param self GedPropPrimitiveList The GedPropPrimitiveList instance.
--- @return number The default weight value for the GedPropPrimitiveList.
function GedPropPrimitiveList:DefaultWeightValue()
	return self.prop_meta.weight_default or 100
end

---
--- Validates the given value for the GedPropPrimitiveList.
---
--- This function is responsible for validating the provided value for the GedPropPrimitiveList instance. In this case, the function simply returns `true`, as the GedPropPrimitiveList does not require any special validation.
---
--- @param self GedPropPrimitiveList The GedPropPrimitiveList instance.
--- @param value any The value to be validated.
--- @return boolean `true` if the value is valid, `false` otherwise.
function GedPropPrimitiveList:ValidateValue(value)
	return true
end


----- GedPropPresetIdList

GedPropEditors["preset_id_list"] = "GedPropPresetIdList"
DefineClass.GedPropPresetIdList = {
	__parents = { "GedPropPrimitiveList" },
}

---
--- Returns a list of choice items for the GedPropPresetIdList.
---
--- This function is responsible for retrieving the list of preset items that can be selected in the GedPropPresetIdList. It calls the "rfnGetPresetItems" RPC method on the panel's connection, passing the panel's context and the property's ID as arguments.
---
--- @param self GedPropPresetIdList The GedPropPresetIdList instance.
--- @return table A table of preset items that can be selected in the GedPropPresetIdList.
function GedPropPresetIdList:GetChoiceItems()
	return self.panel.connection:Call("rfnGetPresetItems", self.panel.context, self.prop_meta.id)
end

---
--- Creates additional buttons for the GedPropPresetIdList.
---
--- This function is responsible for creating additional buttons that may be displayed alongside the GedPropPresetIdList. It checks if the "GedRpcEditPreset" function should be shown, and if so, creates a button that opens the preset editor when pressed. If the `editor_preview` field is set in the property metadata, it also creates a text panel that displays a preview of the referenced preset.
---
--- @param self GedPropPresetIdList The GedPropPresetIdList instance.
--- @param parent table The parent widget where the buttons should be created.
--- @param idx number The index of the selected item in the list.
function GedPropPresetIdList:CreateAdditionalButtons(parent, idx)
	if self:ShouldShowButtonForFunc("GedRpcEditPreset") then
		local open_button = XTemplateSpawn("GedToolbarButtonSmall", parent)
		open_button:SetIcon("CommonAssets/UI/Ged/explorer.tga")
		open_button:SetRolloverText("Open Preset Editor", self.prop_meta.preset_class)
		open_button.OnPress = function(button)
			button:SetFocus()
			self.panel.app:Send("GedRpcEditPreset", self.panel.context, self.prop_meta.id, self.list_values[idx])
			button:SetFocus(false)
		end
	end
	
	if self.prop_meta.editor_preview then
		GedTextPanel:new({
			Title = "",
			Dock = "bottom",
			ZOrder = -1,
			Format = self.prop_meta.editor_preview,
			Shorten = true,
			MaxHeight = 50,
		}, parent):SetContext(self.prop_meta.id..".ReferencedPreset"..tostring(idx))
	end
end

---
--- Called when the value of a list item in the GedPropPresetIdList is changed.
---
--- This function is responsible for handling the changes to the selected item in the GedPropPresetIdList. It first calls the `OnListItemValueChanged` function of the parent `GedPropPrimitiveList` class to handle the base list item change logic. If the property metadata has an `editor_preview` field set, it then sends a "GedRpcBindPreset" message to the panel's application, passing the context, property ID, and the new selected preset ID as arguments. This allows the application to update the preview of the referenced preset.
---
--- @param self GedPropPresetIdList The GedPropPresetIdList instance.
--- @param idx number The index of the selected item in the list.
function GedPropPresetIdList:OnListItemValueChanged(idx)
	GedPropPrimitiveList:OnListItemValueChanged(idx)

	if self.prop_meta.editor_preview then
		self.panel.app:Send("GedRpcBindPreset", self.prop_meta.id..".ReferencedPreset"..tostring(idx), self.panel.context, self.prop_meta.id, self.list_values[idx])
	end
end


----- GedPropNumberList

GedPropEditors["number_list"] = "GedPropNumberList"
DefineClass.GedPropNumberList = {
	__parents = { "GedPropPrimitiveList"},
}

---
--- Converts the given text string to a number value.
---
--- If the text cannot be converted to a number, this function returns 0.
---
--- @param self GedPropNumberList The GedPropNumberList instance.
--- @param text string The text to be converted to a number.
--- @return number The number value represented by the input text, or 0 if the text cannot be converted.
---
function GedPropNumberList:ConvertFromText(text)
	return tonumber(text) or 0
end

---
--- Converts the given number value to a string representation.
---
--- If the input value is not a number, this function returns an empty string.
---
--- @param self GedPropNumberList The GedPropNumberList instance.
--- @param value number The number value to be converted to a string.
--- @return string The string representation of the input number value, or an empty string if the input is not a number.
---
function GedPropNumberList:ConvertToText(value)
	if type(value) ~= "number" then return "" end
	return tostring(value)
end

---
--- Returns the default value for the GedPropNumberList.
---
--- This function returns the default value of 0 for the GedPropNumberList.
---
--- @return number The default value for the GedPropNumberList, which is 0.
---
function GedPropNumberList:DefaultValue()
	return 0
end

---
--- Validates the given value to ensure it is a number.
---
--- @param self GedPropNumberList The GedPropNumberList instance.
--- @param value any The value to be validated.
--- @return boolean True if the value is a number, false otherwise.
---
function GedPropNumberList:ValidateValue(value)
	return type(value) == "number"
end


----- GedPropStringList

GedPropEditors["string_list"] = "GedPropStringList"
DefineClass.GedPropStringList = {
	__parents = { "GedPropPrimitiveList"},
}

---
--- Returns the default value for the GedPropStringList.
---
--- This function returns the default value of an empty string for the GedPropStringList.
---
--- @return string The default value for the GedPropStringList, which is an empty string.
---
function GedPropStringList:DefaultValue()
	return ""
end

---
--- Validates the given value to ensure it is a string.
---
--- @param self GedPropStringList The GedPropStringList instance.
--- @param value any The value to be validated.
--- @return boolean True if the value is a string, false otherwise.
---
function GedPropStringList:ValidateValue(value)
	return type(value) == "string"
end


----- GedPropTList

GedPropEditors["T_list"] = "GedPropTList"
DefineClass.GedPropTList = {
	__parents = { "GedPropPrimitiveList"},
}

---
--- Initializes a GedPropTList instance.
---
--- This function is called to initialize a GedPropTList instance. It asserts that the prop_meta table does not have a 'weights' field, as the T_list type does not support weights.
---
--- @param parent any The parent object for the GedPropTList instance.
--- @param context any The context object for the GedPropTList instance.
--- @param prop_meta table The metadata for the property being edited.
---
function GedPropTList:Init(parent, context, prop_meta)
	assert(not prop_meta.weights, "T_list doesn't support weights")
end

---
--- Returns the default value for the GedPropStringList.
---
--- This function returns the default value of an empty string for the GedPropStringList.
---
--- @return string The default value for the GedPropStringList, which is an empty string.
---
function GedPropTList:DefaultValue()
	return ""
end

---
--- Validates the given value to ensure it is a string.
---
--- @param self GedPropStringList The GedPropStringList instance.
--- @param value any The value to be validated.
--- @return boolean True if the value is a string, false otherwise.
---
function GedPropTList:ValidateValue(value)
	return type(value) == "string"
end

---
--- Creates a multi-line text edit control for the GedPropTList.
---
--- This function creates a new XMultiLineEdit control with the following properties:
--- - Id: "idEdit"
--- - MinVisibleLines: 1
--- - MaxVisibleLines: 30
--- - Translate: true
--- 
--- The control is also set up with the "XSpellcheckPlugin" plugin.
---
--- @param self GedPropTList The GedPropTList instance.
--- @param parent any The parent object for the text edit control.
--- @return XMultiLineEdit The created text edit control.
---
function GedPropTList:CreateTextEditControl(parent)
	local control = XMultiLineEdit:new({
		Id = "idEdit",
		MinVisibleLines = 1, 
		MaxVisibleLines = 30,	
		Translate = true,
	}, parent)
	control:SetPlugins({ "XSpellcheckPlugin" })
	return control
end

---
--- Converts the given value to a text representation.
---
--- @param self GedPropTList The GedPropTList instance.
--- @param value any The value to be converted to text.
--- @return string The text representation of the value.
---
function GedPropTList:ConvertToText(value)
	return GedPropValueToT(value)
end

---
--- Converts the given text value to a property value.
---
--- @param self GedPropTList The GedPropTList instance.
--- @param value string The text value to be converted.
--- @return any The converted property value.
---
function GedPropTList:ConvertFromText(value)
	return GedTToPropValue(value, "")
end


----- GedPropListPicker, base class for picking item(s) from a list (GedPropTextPicker / GedPropTexturePicker)

DefineClass.GedPropListPicker = {
	__parents = {"GedPropEditor"},
}

---
--- Initializes the GedPropListPicker instance.
---
--- This function sets up the UI elements for the GedPropListPicker, including the list of items, the scroll bar, and the filtering functionality.
---
--- @param self GedPropListPicker The GedPropListPicker instance.
---
function GedPropListPicker:Init()
	local horizontal = self.prop_meta.horizontal
	if not horizontal then
		self.idLabelHost:SetDock("top")
	end
	self.idResetToDefault:SetVisibleInstant(false)
	
	XList:new({
		Id = "idList",
		VScroll = "idScroll",
		Padding = horizontal and box(2, 1, 2, 0) or empty_box,
		OnSelection = function(list, selected_item, selected_items)
			self:SetValue(selected_items)
		end,
		MultipleSelection = self.prop_meta.multiple or false,
		MaxRowsVisible = self.prop_meta.horizontal and 0 or (self.prop_meta.max_rows or 1),
		OnDoubleClick = function(list, idx)
			self.panel.app:Send("GedPickerItemDoubleClicked", self.panel.context, self.prop_meta.id, ItemId(list[idx].item))
		end,
	}, self)
	self:SpawnItems()
	if not self.prop_meta.horizontal then
		XSleekScroll:new({
			Id = "idScroll",
			Target = "node",
			Dock = "right",
			Margins = box(2, 0, 0, 0),
			AutoHide = true,
		}, self.idList)
	end
	
	-- filtering
	if self.prop_meta.filter_by_prop and self.prop_meta.filter_by_prop ~= "" then
		local filter_editor = self.panel:LocateEditorById(self.prop_meta.filter_by_prop)
		filter_editor.idEdit.OnTextChanged = function(edit)
			self:DeleteThread("filter_thread")
			self:CreateThread("filter_thread", function()
				Sleep(150)
				if self.window_state ~= "destroying" then
					self:FilterItems()
				end
			end)
		end
	end
end

---
--- Filters the items in the GedPropListPicker based on the input from a filter editor.
---
--- @param self GedPropListPicker The GedPropListPicker instance.
---
function GedPropListPicker:FilterItems()
	local filter_editor = self.panel:LocateEditorById(self.prop_meta.filter_by_prop)
	if not filter_editor then
		return false
	end

	local filter_string = filter_editor.idEdit:GetText()
	if (filter_string == "" or type(filter_string) ~= "string") and string.lower(filter_string) == self.last_filter_string then
		self.last_filter_string = filter_string
		return false
	end
	filter_string = string.lower(filter_string)
	
	-- Early return if the filter hasn't changed
	if filter_string == self.last_filter_string then
		return false
	end
	
	local fill_and_sort_cache = false
	if not self.sorted_items_cache then
		self.sorted_items_cache = {}
		fill_and_sort_cache = true
	end

	local starting_with = {}
	local idx = 1
	-- Item data is in self.idList[idx].item
	for item_idx, item in ipairs(self.idList) do
		if item.Id ~= "idScroll" then
			local item_text_lower = ItemText(item.item):strip_tags():lower()
			local visible = filter_string == "" or string.find(item_text_lower, filter_string, 1, true)
			
			if filter_string ~= "" and string.starts_with(item_text_lower, filter_string) then
				table.insert(starting_with, item)
			end

			item:SetVisible(visible)
			item:SetDock(not visible and "ignore" or false)
			idx = idx + 1
		end
		
		-- Fill items cache
		if fill_and_sort_cache then
			table.insert(self.sorted_items_cache, item)
		end
	end
	
	-- -- Reorder the items in the list
	
	-- Put items starting with the filter word first
	local starting_with_count = #starting_with
	for i = 1, starting_with_count do
		self.idList[i] = starting_with[i]
	end

	-- Then add the rest from the cache
	local cache_count = #self.sorted_items_cache
	local list_idx = 1
	for i = 1, cache_count do
		-- Skip the starting_with items that were prepended to the list
		local skip = false

		for _, item in ipairs(starting_with) do 
			if item == self.sorted_items_cache[i] then
				skip = true
				break
			end	
		end
		
		if not skip then
			self.idList[starting_with_count + list_idx] = self.sorted_items_cache[i]
			list_idx = list_idx + 1
		end
	end

	-- Reselect items that were selected before the reodering
	local selection = {}
	for idx, item in ipairs(self.idList) do
		if item.selected then
			table.insert(selection, idx)
			item:SetSelected(false)
		end
	end
	self.idList:SetSelection(selection, not "notify")
   
	-- Save the previous filter string
	self.last_filter_string = filter_string
end

---
--- Reverts changes made to the `idList` component during the `Layout` function, so that the height and row visibility can be recalculated when the component is reused.
---
--- @param self GedPropListPicker
function GedPropListPicker:DetachForReuse()
	-- revert changes made by Layout below, so it gets recalculated
	self.idList:SetMinHeight(nil)
	self.idList:SetMaxHeight(nil)
	self.idList:SetMaxRowsVisible(self.prop_meta.horizontal and 0 or (self.prop_meta.max_rows or 1))
	GedPropEditor.DetachForReuse(self)
end

---
--- Lays out the GedPropListPicker component, adjusting the height and row visibility based on the available space.
---
--- @param self GedPropListPicker
--- @param x number The x-coordinate of the component.
--- @param y number The y-coordinate of the component.
--- @param width number The width of the component.
--- @param height number The height of the component.
--- @return number, number, number, number The final x, y, width, and height of the component.
---
function GedPropListPicker:Layout(x, y, width, height)
	if not self.prop_meta.max_rows and not self.prop_meta.horizontal and self.idList.MaxHeight == XList.MaxHeight then
		-- size vertically up to take up all unused space
		local app = self.panel.app
		local new_height = MulDivTrunc(height + app.parent.content_box:sizey() - app.measure_height, 1000, self.scale:y())
		self.idList:SetMinHeight(new_height)
		self.idList:SetMaxHeight(new_height)
		self.idList:SetMaxRowsVisible(0)
	end
	return GedPropEditor.Layout(self, x, y, width, height)
end

---
--- Sets the value of the GedPropListPicker component based on the selected items.
---
--- @param selected table A table of indices of the selected items in the idList.
---
function GedPropListPicker:SetValue(selected)
	local texts = {}
	for _, idx in ipairs(selected) do
		-- Item data is in self.idList[idx].item
		texts[#texts + 1] =  ItemId(self.idList[idx].item)
	end
	self:SetProp(self.prop_meta.multiple and texts or texts[1] or "")
end

---
--- Updates the value of the GedPropListPicker component based on the selected items.
---
--- This function is responsible for updating the selection state of the idList component based on the current value of the property. It first finds the indices of the selected items in the idList, then sets the selection on the idList. Finally, it calls the FilterItems function to update the visibility of the items based on the new selection.
---
--- @param self GedPropListPicker The GedPropListPicker instance.
---
function GedPropListPicker:UpdateValue()
	-- Item data is in self.idList[idx].item
	local ui_items = self.idList or empty_table
	local tables = type(ui_items[1] and ui_items[1].item) == "table"
	local value = self.prop_meta.multiple and self:GetProp() or { self:GetProp() }
	local selection = {}
	for _, val in ipairs(value or empty_table) do
		local selection_idx
		
		-- Find the index of the item with the selected value
		for item_idx, ui_item in ipairs(ui_items) do
			if ui_item.Id ~= "idScroll" then
				if ui_item.item == val or tables and (ui_item.item.id == val or ui_item.item.value == val) then
					selection_idx = item_idx
					break
				end
			end
		end
		
		if selection_idx then
			selection[#selection + 1] = selection_idx
		end
	end
	self.idList:SetSelection(selection, not "notify")
	self:FilterItems()
	GedPropEditor.UpdateValue(self)
end

---
--- Spawns the items for the GedPropListPicker component.
---
--- This function is responsible for creating the XListItems that will be displayed in the idList component. It iterates over the items defined in the prop_meta.items table and creates a new XListItem for each one, setting the appropriate properties based on the item data and the prop_meta configuration.
---
--- @param self GedPropListPicker The GedPropListPicker instance.
---
function GedPropListPicker:SpawnItems()
	-- create the XListItems in self.idList here
end


----- GedPropTextPicker

GedPropEditors["text_picker"] = "GedPropTextPicker"
DefineClass.GedPropTextPicker = {
	__parents = { "GedPropListPicker" },
}

---
--- Initializes the GedPropTextPicker component.
---
--- This function sets the layout method of the idList component based on the prop_meta.horizontal property. If prop_meta.horizontal is true, the layout method is set to "HWrap", otherwise it is set to "VList".
---
--- @param self GedPropTextPicker The GedPropTextPicker instance.
---
function GedPropTextPicker:Init()
	self.idList:SetLayoutMethod(self.prop_meta.horizontal and "HWrap" or "VList")
end

---
--- Spawns the items for the GedPropTextPicker component.
---
--- This function is responsible for creating the XListItems that will be displayed in the idList component. It iterates over the items defined in the prop_meta.items table and creates a new XListItem for each one, setting the appropriate properties based on the item data and the prop_meta configuration.
---
--- @param self GedPropTextPicker The GedPropTextPicker instance.
---
function GedPropTextPicker:SpawnItems()
	local list = self.idList
	local selectable = not self.prop_meta.read_only
	local has_bookmarks = self.prop_meta.bookmark_fn
	local font = self.prop_meta.small_font and "GedSmall" or "GedDefault"
	list:Clear()
	for _, item in ipairs(self.prop_meta.items or empty_table) do
		local context = { text = ItemText(item), help = item.help, font = font, selectable = selectable, documentation = item.documentation }
		if has_bookmarks then
			context.bookmarked = item.bookmarked and true or false
		end
		local control
		if self.prop_meta.virtual_items then
			control = NewXVirtualContent(list, context, "GedTextPickerItem")
		else
			control = XTemplateSpawn("GedTextPickerItem", list, context)
		end
		control.item = item
	end
end


----- GedPropTexturePicker

GedPropEditors["texture_picker"] = "GedPropTexturePicker"
DefineClass.GedPropTexturePicker = {
	__parents = { "GedPropListPicker" },
}

---
--- Initializes the GedPropTexturePicker component.
---
--- This function sets the layout method of the idList component to "HWrap". If the prop_meta.alt_prop property is set, it also overrides the OnMouseButtonDown event handler for the idList to handle Alt+Left Click events, which will set the alt_prop property on the panel context.
---
--- @param self GedPropTexturePicker The GedPropTexturePicker instance.
--- @param parent table The parent component.
--- @param context table The context for the component.
--- @param prop_meta table The metadata for the property being edited.
---
function GedPropTexturePicker:Init(parent, context, prop_meta)
	self.idList:SetLayoutMethod("HWrap")
	
	if prop_meta.alt_prop then
		self.idList.OnMouseButtonDown = function(list, pt, button)
			if button == "L" and terminal.IsKeyPressed(const.vkAlt) then
				local item_idx = list:GetItemAt(pt)
				self.panel:Op("GedSetProperty", self.panel.context, prop_meta.alt_prop, ItemId(prop_meta.items[item_idx]))
				return "break"
			end
			return XList.OnMouseButtonDown(list, pt, button)
		end
	end
end

---
--- Spawns the items in the texture picker list.
---
--- This function is responsible for populating the texture picker list with the items defined in the `prop_meta.items` table. It creates a new `XListItem` for each item, sets its properties (such as rollover text, background colors, and padding), and adds it to the list. It also creates an `XImage` control within each list item to display the texture thumbnail, and sets the image properties based on the item metadata (such as `thumb_size`, `thumb_height`, and `base_color_map`). Finally, it adds a selected number text control to each list item to indicate the selection order.
---
--- @param self GedPropTexturePicker The GedPropTexturePicker instance.
---
function GedPropTexturePicker:SpawnItems()
	local list = self.idList
	local prop_meta = self.prop_meta
	local enabled = not prop_meta.read_only
	list:Clear()
	for _, item in ipairs(prop_meta.items or empty_table) do
		local listitem = XListItem:new({
			RolloverText = item.help,
			RolloverTemplate = "GedPropRollover",
			RolloverBackground = RGBA(24, 123, 197, 255),
			FocusedBackground = RGBA(24, 123, 197, 255),
			Padding = box(2, 2, 2, 0),
			selectable = enabled,
			SetSelected = function(self, selected)
				if selected and #list.selection > 1 then
					local idx = table.find(list, self)
					local sel_idx = table.find(list.selection, idx)
					self.idSelectedNumber:SetText(string.format("#%d", sel_idx))
				else
					self.idSelectedNumber:SetText("")
				end
				XListItem.SetSelected(self, selected)
			end,
		}, list)
		
		local image_parent = XWindow:new({ Dock = "top" }, listitem)
		
		local image = XImage:new({
			BorderWidth = 1,
			ImageFit = prop_meta.thumb_height and "largest" or "smallest",
			MinWidth = prop_meta.thumb_size or prop_meta.thumb_width or 60,
			MaxWidth = prop_meta.thumb_size or prop_meta.thumb_width or 60,
			MinHeight = prop_meta.thumb_height,
			MaxHeight = prop_meta.thumb_height,
			BaseColorMap = prop_meta.base_color_map,
		}, image_parent)
		image:SetImage(item.image or item.value)
		local width, height = UIL.MeasureImage(image.Image)
		local new_width = MulDivRound(width, prop_meta.thumb_zoom or 100, 100)
		local new_starting_point = (width - new_width) / 2
		image:SetImageRect(box(new_starting_point, new_starting_point, new_starting_point + new_width, new_starting_point + new_width))
		if item.color then
			image:SetImageColor(item.color)
		end
		
		-- selected # text
		XText:new({
			Id = "idSelectedNumber",
			TextStyle = "GedSmall",
			HAlign = "right",
			VAlign = "bottom",
		}, image_parent)
		
		XText:new({
			Dock = "bottom",
			TextStyle = prop_meta.small_font and "GedSmall" or "GedDefault",
			MaxWidth = prop_meta.thumb_size or prop_meta.thumb_width or 60,
			VAlign = "center",
			TextHAlign = "center",
			Padding = box(2, 2, 2, 0),
			RolloverText = item.text,
			RolloverTemplate = "GedPropRollover",
			RolloverBackground = RGBA(24, 123, 197, 255),
		}, listitem):SetText(item.text)
		
		listitem.item = item
	end
end


----- GedPropObjectPicker

GedPropEditors["object"] = "GedPropObjectPicker"
DefineClass.GedPropObjectPicker = {
	__parents = {"GedPropEditor"},
	last_object = false,
}

---
--- Initializes a GedPropObjectPicker instance.
---
--- @param parent table The parent object.
--- @param context table The context object.
--- @param prop_meta table The property metadata.
---
function GedPropObjectPicker:Init(parent, context, prop_meta)
	XCombo:new({
		Id = "idCombo",
		Items = false,
		RefreshItemsOnOpen = true,
		DefaultValue = self.prop_meta.default or "",
		ArbitraryValue = true,
		OnValueChanged = function(combo, value)
			self:ComboValueChanged(value)
		end,
		OnRequestItems = function(combo)
			return self.panel.connection:Call("rfnMapGetGameObjects", self.panel.context, self.prop_meta.id)
		end,
		MRUStorageId = self.prop_meta.mru_storage_id,
		MRUCount = self.prop_meta.show_recent_items,
		VirtualItems = true,
	}, self)
	self.idCombo:SetEnabled(not prop_meta.read_only)
	self.last_object = {}
	
	local inspect_button = XTemplateSpawn("GedToolbarButtonSmall", self)
	inspect_button:SetIcon("CommonAssets/UI/Ged/explorer.tga")
	inspect_button:SetRolloverText("Inspect Object")
	inspect_button.OnPress = function(button)
		button:SetFocus()
		self.panel.app:Send("GedRpcInspectObj", self.panel.context, prop_meta.id)
		button:SetFocus(false)
	end
end

---
--- Reassigns the focus order of the combo box.
---
--- @param x number The x-coordinate of the focus order.
--- @param y number The y-coordinate of the focus order.
--- @return number The next y-coordinate for focus order.
---
function GedPropObjectPicker:ReassignFocusOrders(x, y)
	self.idCombo:SetFocusOrder(point(x, y))
	return y + 1
end

---
--- Updates the value of the GedPropObjectPicker.
---
--- This function is responsible for updating the value of the GedPropObjectPicker
--- component. It sets the items of the combo box to false, indicating that the
--- list of items needs to be refetched. It then updates the last_object property
--- with the current property value, and sets the value and text of the combo box
--- accordingly. Finally, it calls the UpdateValue function of the parent
--- GedPropEditor class.
---
--- @param self table The GedPropObjectPicker instance.
---
function GedPropObjectPicker:UpdateValue()
	local combo = self.idCombo
	combo.Items = false -- list of items might have changed, must be refetched
	self.last_object = self:GetProp() or {}
	self.idCombo:SetValueWithText(self.last_object.handle, self.last_object.text)
	GedPropEditor.UpdateValue(self)
end

---
--- Handles the value change event of the combo box in the GedPropObjectPicker.
---
--- This function is called when the value of the combo box changes. It first
--- checks if the new value has leading or trailing spaces, and trims them if
--- necessary. It then checks if the new value is different from the last
--- selected object, and if so, updates the last_object property and sets the
--- new value as the property.
---
--- @param self table The GedPropObjectPicker instance.
--- @param value string The new value of the combo box.
---
function GedPropObjectPicker:ComboValueChanged(value)
	if type(value) == "string" and self.prop_meta.trim_spaces ~= false and string.trim_spaces(value) ~= value then
		value = string.trim_spaces(value)
		self.idCombo:SetValue(value)
	end
	if self.last_object.handle ~= value then
		self.last_object.handle = value
		self:SetProp({ handle = value })
	end
end

--- Detaches the GedPropObjectPicker instance from the UI and updates the most recently used (MRU) list.
---
--- This function is called when the GedPropObjectPicker instance is no longer needed and needs to be detached from the UI. It first updates the MRU list of the combo box, and then calls the `DetachForReuse` function of the parent `GedPropEditor` class.
---
--- @param self table The GedPropObjectPicker instance.
function GedPropObjectPicker:DetachForReuse()
	self.idCombo:UpdateMRUList()
	GedPropEditor.DetachForReuse(self)
end


----- GedPropHistogram

GedPropEditors["histogram"] = "GedPropHistogram"
DefineClass.GedPropHistogram = {
	__parents = {"GedPropEditorWithSubeditors"},
}

--- Initializes a new GedPropHistogram instance.
---
--- This function is called to initialize a new GedPropHistogram instance. It creates a new XHistogram instance and sets its properties, such as the minimum width and height. The idLabelHost property is also set to dock at the top of the subeditor_container.
---
--- @param self table The GedPropHistogram instance.
--- @param parent table The parent UI element.
--- @param context table The context in which the GedPropHistogram is being used.
--- @param prop_meta table The metadata for the property being edited.
function GedPropHistogram:Init(parent, context, prop_meta)
	local histogram = XHistogram:new({
		Id = "idHistogram",
		MinWidth = 200,
		MinHeight = 200,
	}, self.subeditor_container)

	self.idLabelHost:SetDock("top")
end

--- Updates the value of the histogram in the GedPropHistogram instance.
---
--- This function is called to update the value of the histogram displayed in the GedPropHistogram instance. It sets the value of the idHistogram XHistogram instance to the current property value, and then calls the UpdateValue function of the parent GedPropEditorWithSubeditors class.
---
--- @param self table The GedPropHistogram instance.
function GedPropHistogram:UpdateValue()
	self.idHistogram:SetValue(self:GetProp())
	GedPropEditorWithSubeditors.UpdateValue(self)
end

----- GedPropCurvePicker

GedPropEditors["packedcurve"] = "GedPropCurvePicker"
GedPropEditors["curve4"] = "GedPropCurvePicker"
DefineClass.GedPropCurvePicker = {
	__parents = {"GedPropEditorWithSubeditors"},

	default_scale = 1000,
	graph_max_value = 10,
	range_editor = false,

	color_args = false,
	control_points = 4,
}

--- Updates the dynamic graph parameters of the GedPropCurvePicker instance.
---
--- This function is called to update the dynamic parameters of the graph displayed in the GedPropCurvePicker instance. It sets the `graph_max_value` property to the value of the `subeditor_value` property of the `range_editor` subeditor, clamped between the `min_amplitude` and `max_amplitude` values from the `prop_meta` table. It then updates the `DisplayScaleY` property of the `idCurve` XCurveEditor instance to scale the graph based on the `graph_max_value` and the `scale` property from the `prop_meta` table.
---
--- @param self table The GedPropCurvePicker instance.
function GedPropCurvePicker:UpdateDynamicGraphParams()
	self.graph_max_value = self.range_editor.subeditor_value
	self.graph_max_value = Max(Min(self.graph_max_value, self.prop_meta.max_amplitude), self.prop_meta.min_amplitude)
	self.idCurve.DisplayScaleY = (self.prop_meta.scale or 1000) * 10 / self.graph_max_value
	self.idCurve.scale_texts = false
end

--- Draws the background of the graph in the GedPropCurvePicker instance.
---
--- This function is responsible for drawing the background of the graph displayed in the GedPropCurvePicker instance. It uses the `color_args` property to interpolate the colors of the background based on the vertical position within the graph. The background is drawn as a series of solid rectangles, with the color interpolated between the colors specified in `color_args`.
---
--- @param self table The GedPropCurvePicker instance.
--- @param editor table The XCurveEditor instance that the graph is being drawn in.
--- @param graph_box table The bounding box of the graph area.
--- @param points table The control points of the curve being displayed.
function GedPropCurvePicker:DrawGraphBackground(editor, graph_box, points)
	local color_args = self.color_args
	if not color_args then return end

	local step = 12
	local units_per_color = 1000 / (#color_args - 2)
	local DrawSolidRect = UIL.DrawSolidRect
	for y = graph_box:miny(), graph_box:maxy(), step do
		local percent = 1000 - MulDivRound(y - graph_box:miny(), 1000, graph_box:sizey())
		local i = percent / units_per_color
		local color_interp = percent % units_per_color
		local color = InterpolateRGB(color_args[i + 1], color_args[i + 2], color_interp, units_per_color)
		DrawSolidRect(box(graph_box:minx(), y, graph_box:maxx(), Min(graph_box:maxy(), y + step)), color, RGBA(0, 0, 0, 0))
	end
end

--- Initializes a GedPropCurvePicker instance.
---
--- This function is responsible for setting up the GedPropCurvePicker instance. It initializes the `idCurve` XCurveEditor instance with the appropriate settings based on the `prop_meta` table. It also creates a `range_editor` subeditor to control the maximum amplitude of the curve. The function sets up the necessary event handlers and other properties to ensure the proper functioning of the GedPropCurvePicker.
---
--- @param self table The GedPropCurvePicker instance.
--- @param parent table The parent container for the GedPropCurvePicker.
--- @param context table The context in which the GedPropCurvePicker is being used.
--- @param prop_meta table The metadata for the property being edited by the GedPropCurvePicker.
function GedPropCurvePicker:Init(parent, context, prop_meta)
	prop_meta.max_amplitude = prop_meta.max_amplitude or 10
	prop_meta.min_amplitude = prop_meta.min_amplitude or 10
	if prop_meta.scale then
		prop_meta.max_amplitude = prop_meta.max_amplitude or prop_meta.scale
		prop_meta.min_amplitude = prop_meta.min_amplitude or prop_meta.scale
	end
	self.control_points = prop_meta.control_points or 4

	local curve_editor = XCurveEditor:new({
		Id = "idCurve",
		ControlPoints = self.control_points,
		MaxX = prop_meta.max_x or 1000,
		MinX = prop_meta.min_x or 0,
		MaxY = prop_meta.max or 1000,
		MinY = prop_meta.min or 0,
		DisplayScaleX = prop_meta.scale_x or 1000,
		DisplayScaleY = prop_meta.scale or 1000,
		SnapX = 1,
		SnapY = 1,
		MinWidth = 500,
		MinHeight = 200,
		Smooth = false,
		FixedX = prop_meta.fixedx or false,
		OnCurveChanged = function(editor)
			if not self:IsThreadRunning("scroll_update_thread") then
				self:CreateThread("scroll_update_thread", function()
					Sleep(75)
					self:TrySetProp()
				end)
			end
		end,
		DrawGraphBackground = function(editor, graph_box, points)
			self:DrawGraphBackground(editor, graph_box, points)
		end,
		ReadOnly = prop_meta.read_only and true,
		MinMaxRangeMode = not prop_meta.no_minmax,
	}, self.subeditor_container)
	curve_editor.GridUnitY = curve_editor:GetRange():y() / 4
	curve_editor.GridUnitX = curve_editor:GetRange():x() / 4

	if prop_meta.color_args and #prop_meta.color_args > 0 then
		self.color_args = prop_meta.color_args
		table.insert(self.color_args, self.color_args[#self.color_args])
	end

	self.range_editor = self:MakeSubEditor(self.subeditor_container, GedPropNumber, {
		max = prop_meta.max_amplitude or 10,
		min = prop_meta.min_amplitude or 10,
		scale = 10,
		slider = true,
		default = 10,
		id = "range_editor",
		editor = "number"
	})
	if prop_meta.max_amplitude == prop_meta.min_amplitude then
		self.range_editor:SetVisible(false)
		self.range_editor:SetDock("ignore")
	end

	self.idLabelHost:SetDock("top")
end

---
--- Attempts to set the property value for the curve editor.
--- Copies the current points from the curve editor, sets the range_y and scale properties,
--- updates the graph max value, and then sets the updated property value.
---
--- @param self GedPropCurvePicker
function GedPropCurvePicker:TrySetProp()
	local result = table.copy(self.idCurve.points)
	result.range_y = self.range_editor.subeditor_value
	result.scale = self.prop_meta.scale or result.range_y
	self.graph_max_value = result.range_y or 10
	self:UpdateDynamicGraphParams()
	self:SetProp(result)
end

---
--- Updates the value of the curve editor.
--- Copies the current points from the curve editor, sets the range_y and scale properties,
--- updates the graph max value, and then sets the updated property value.
---
--- @param self GedPropCurvePicker
function GedPropCurvePicker:UpdateValue()
	GedPropEditorWithSubeditors.UpdateValue(self)
	
	local prop = self:GetProp()
	if not prop then return end

	if self.idCurve:IsFocused(true) then
		return
	end
	for i = 1, #prop do
		if IsPoint(prop[i]) then
			local pt = prop[i]
			if not pt:z() then
				pt = pt:SetZ(pt:y())
			end
			self.idCurve.points[i] = pt
		end
	end
	self.idCurve:ValidatePoints()
	self.graph_max_value = prop.range_y or 10
	self.range_editor.subeditor_value = self.graph_max_value
	self:UpdateDynamicGraphParams()
end

----- GedPropPointList

GedPropEditors["point_list"] = "GedPropPointList"
DefineClass.GedPropPointList = {
	__parents = { "GedPropPrimitiveList"},
}

--- Returns the default value for a point list property.
---
--- @return point The default point value.
function GedPropPointList:DefaultValue()
	return point30
end

---
--- Validates that the given value is a valid point.
---
--- @param self GedPropPointList
--- @param value point The value to validate.
--- @return boolean True if the value is a valid point, false otherwise.
---
function GedPropPointList:ValidateValue(value)
	return IsPoint(value)
end

---
--- Converts the given value from a string representation to a point.
---
--- @param self GedPropPointList
--- @param value string The string representation of a point.
--- @return point The point value.
---
function GedPropPointList:ConvertFromText(value)
	return GedPropPoint.ConvertFromText(self, value)
end

---
--- Converts the given point value to a string representation.
---
--- @param self GedPropPointList
--- @param value point The point value to convert.
--- @return string The string representation of the point.
---
function GedPropPointList:ConvertToText(value)
	return GedPropPoint.ConvertToText(self, value)
end

---
--- Applies the specified scale to the point list.
---
--- @param self GedPropPointList The GedPropPointList instance.
--- @param ... any Additional arguments to pass to GedPropPoint.ApplyScale.
--- @return any The result of calling GedPropPoint.ApplyScale.
---
function GedPropPointList:ApplyScale(...)
	return GedPropPoint.ApplyScale(self, ...)
end

---
--- Gets the display scale for the GedPropPointList.
---
--- @param self GedPropPointList The GedPropPointList instance.
--- @param ... any Additional arguments to pass to GedPropPoint.GetDisplayScale.
--- @return any The result of calling GedPropPoint.GetDisplayScale.
---
function GedPropPointList:GetDisplayScale(...)
	return GedPropPoint.GetDisplayScale(self, ...)
end

---
--- Gets the minimum and maximum values of the point list.
---
--- @param self GedPropPointList The GedPropPointList instance.
--- @param ... any Additional arguments to pass to GedPropPoint.GetMinMax.
--- @return any The result of calling GedPropPoint.GetMinMax.
---
function GedPropPointList:GetMinMax(...)
	return GedPropPoint.GetMinMax(self, ...)
end

---
--- Updates the value of the GedPropPointList.
---
--- If the keyboard focus is not within the GedPropPointList, the list_values are updated to be a table of points
--- from the data property. The UpdateControls function is then called.
---
--- Finally, the UpdateValue function of the GedPropEditor is called.
---
--- @param self GedPropPointList The GedPropPointList instance.
---
function GedPropPointList:UpdateValue()
	local data = self:GetProp() or {}
	if not terminal.desktop.keyboard_focus or not terminal.desktop.keyboard_focus:IsWithin(self) then
		self.list_values = table.map(data, function(p) return point(p:xyz()) end)
		self:WithItems(function()
			self:UpdateControls()
		end)
	end
	GedPropEditor.UpdateValue(self)
end