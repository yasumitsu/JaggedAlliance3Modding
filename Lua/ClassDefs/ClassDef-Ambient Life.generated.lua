-- ========== GENERATED BY ClassDef Editor (Ctrl-Alt-F3) DO NOT EDIT MANUALLY! ==========

DefineClass.AL_Carry = {
	__parents = { "AmbientLifeMarker", },
	__generated_by_class = "ClassDef",

	properties = {
		{ category = "Ambient Life", id = "VisitEnter", name = "Entering Visit", 
			editor = "combo", default = "civ_Walk_Carry_Start", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitIdle", name = "During Visit", 
			editor = "combo", default = "civ_Walk_Carry", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitExit", name = "Exit Visit", 
			editor = "combo", default = "civ_Walk_Carry_End", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "MoveStyle", name = "Move Style", 
			editor = "combo", default = false, items = function (self) return GetAnimationStyleCombo() end, },
		{ category = "Ambient Life", id = "CarryDestination", name = "Destination", help = "Where the load needs to be carry to", 
			editor = "point", default = false, 
			buttons = {{name = "View", func = function(self) ViewPos(self.CarryDestination) end}}, helper = "absolute_pos", },
		{ category = "Ambient Life", id = "Teleport", name = "Teleport", 
			editor = "bool", default = false, },
		{ category = "Ambient Life", id = "GameStatesFilter", name = "States Required for Activation", 
			editor = "set", default = set( {Conflict = false} ), three_state = true, items = function (self) return GetGameStateFilter end, },
	},
	VisitPose = 1912,
	Appearance = "Legion_Jose",
	ToolEntity = "Shanty_CardboardBox_Carry",
}

--- Generates a visitable object for the AL_Carry class.
---
--- This function is used to create a visitable object that represents the AL_Carry class instance. The visitable object includes the AL_Carry instance itself, its position, and a look-at position.
---
--- @return table The visitable object, containing the AL_Carry instance, its position, and a look-at position.
function AL_Carry:GenerateVisitable()
	local pos = self:GetPos()
	local lookat = pos
	
	return {self, pos, lookat}
end

--- Initializes the AL_Carry class instance.
---
--- This function is called during the initialization of the AL_Carry class instance. It checks if the ToolEntity property is valid, and if so, attaches the carry item to the object. If the ToolEntity is invalid, it stores an error source.
---
--- @return nil
function AL_Carry:GameInit()
	local valid = IsValidEntity(self.ToolEntity)
	if valid then
		if HasCollisions(self.ToolEntity) then
			StoreWarningSource(self, string.format("Spawn Tool '%s' has collision surfaces(or passability colliders) - they will bug the PF!", self.ToolEntity))
		end
		self:AttachCarryItem()
	else
		StoreErrorSource(self, string.format("Invalid ToolEntity '%s'!", self.ToolEntity))
	end
end

--- Handles updating the attached carry item when certain properties are changed in the editor.
---
--- This function is called when the "ToolEntity", "ToolAttachOffset", or "ToolColors" properties are changed in the editor. It calls the `AttachCarryItem()` function to update the attached carry item based on the new property values.
---
--- @param prop_id string The ID of the property that was changed.
--- @param old_value any The previous value of the property.
--- @param ged table The GED (Game Editor Data) object associated with the property.
--- @return nil
function AL_Carry:OnEditorSetProperty(prop_id, old_value, ged)
	if prop_id == "ToolEntity"  or prop_id == "ToolAttachOffset" or prop_id == "ToolColors" then
		self:AttachCarryItem()
	end
end

--- Attaches the carry item to the AL_Carry object.
---
--- This function is responsible for attaching the carry item to the AL_Carry object. It first checks if the ToolEntity property is valid, and if so, it destroys any existing attached objects and creates a new one with the specified ToolEntity, ToolColors, and ToolAttachOffset properties. The new attached object is then set to the `tool_attached` property of the AL_Carry object.
---
--- @return nil
function AL_Carry:AttachCarryItem()
	if not IsValidEntity(self.ToolEntity) then return end
	
	if self.tool_attached then
		self:DestroyAttaches(self.tool_attached.class)
	end
	local marker_attach = PlaceObject(self.ToolEntity)
	if self.ToolColors then
		marker_attach:SetColorization(self.ToolColors)
	end
	self:Attach(marker_attach, self:GetSpotBeginIndex(self.ToolSpot))
	if self.ToolAttachOffset then
		marker_attach:SetAttachOffset(self.ToolAttachOffset)
	end
	
	DoneObject(self.tool_attached)
	self.tool_attached = PlaceObject(self.ToolEntity)
	if self.ToolColors then
		self.tool_attached:SetColorization(self.ToolColors)
	end
	if self.ToolAutoAttachMode then
		self.tool_attached:SetAutoAttachMode(self.ToolAutoAttachMode)
	end
	self.tool_attached:SetPos(self:GetPos())
end

--- Checks if the AL_Carry object can be visited by a unit.
---
--- This function first checks if the ToolEntity attached to the AL_Carry object has been destroyed. If so, it returns `false` to indicate that the object cannot be visited.
---
--- If the ToolEntity is not destroyed, it calls the `CanVisit()` function of the parent `AmbientLifeMarker` class, passing the same parameters (`unit`, `for_perpetual`, and `dont_check_dist`). The result of this call is returned.
---
--- @param unit table The unit that is attempting to visit the AL_Carry object.
--- @param for_perpetual boolean Whether the visit is for a perpetual visit.
--- @param dont_check_dist boolean Whether to skip the distance check when determining if the unit can visit.
--- @return boolean Whether the unit can visit the AL_Carry object.
function AL_Carry:CanVisit(unit, for_perpetual, dont_check_dist)
	if self:IsToolDestroyed() then
		return false
	end
	
	return AmbientLifeMarker.CanVisit(self, unit, for_perpetual, dont_check_dist)
end

--- Overrides the `EditorGetText()` function from the `AmbientLifeMarker` class to provide additional information about the `AL_Carry` object.
---
--- If the `ToolEntity` attached to the `AL_Carry` object has been destroyed, this function will append the text "Carry Item is destroyed!" to the default text returned by the `AmbientLifeMarker.EditorGetText()` function.
---
--- @return string The editor text for the `AL_Carry` object, including information about the attached `ToolEntity`.
function AL_Carry:EditorGetText()
	local texts = AmbientLifeMarker.EditorGetText(self)
	if  self:IsToolDestroyed() then
		texts = (texts and (texts .. "\n") or "") .. "Carry Item is destroyed!"
	end
	
	return texts
end

--- Overrides the `EditorGetTextColor()` function from the `AmbientLifeMarker` class to provide a custom text color for the `AL_Carry` object.
---
--- If the `ToolEntity` attached to the `AL_Carry` object has been destroyed, this function will return the color `const.clrRed` to indicate that the object is in an invalid state. Otherwise, it will return the default text color from the `AmbientLifeMarker.EditorGetTextColor()` function.
---
--- @return color The text color to use for the `AL_Carry` object in the editor.
function AL_Carry:EditorGetTextColor()
	return self:IsToolDestroyed() and const.clrRed or AmbientLifeMarker.EditorGetTextColor(self)
end

DefineClass.AL_Cower = {
	__parents = { "AmbientLifeMarker", },
	__generated_by_class = "ClassDef",

	properties = {
		{ category = "Ambient Life", id = "VisitEnter", name = "Entering Visit", 
			editor = "combo", default = "", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitIdle", name = "During Visit", 
			editor = "combo", default = "civ_Standing_Fear", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitExit", name = "Exit Visit", 
			editor = "combo", default = "", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "GameStatesFilter", name = "States Required for Activation", help = "Map states requirements for the AL marker to be active.", 
			editor = "set", default = set( "Conflict" ), three_state = true, items = function (self) return GetGameStateFilter() end, },
	},
	VisitPose = 1424,
	VisitVariation = true,
	Appearance = "VillagerMale_01",
}

--- Generates a visitable object for the `AL_Cower` class.
---
--- This function returns a table containing the `AL_Cower` object itself, its position, and a look-at position. The look-at position is calculated by rotating a point with the X-coordinate set to the constant `const.SlabSizeX` around the `AL_Cower` object's angle.
---
--- @return table The visitable object for the `AL_Cower` class.
function AL_Cower:GenerateVisitable()
	local pos = self:GetPos()
	local lookat = pos + Rotate(point(const.SlabSizeX, 0), self:GetAngle())
	
	return {self, pos, lookat}
end

--- Checks if the `AL_Cower` object can be visited by the given `unit`.
---
--- This function overrides the `CanVisit()` function from the `AmbientLifeMarker` class to provide custom logic for determining if the `AL_Cower` object can be visited.
---
--- @param unit table The unit that wants to visit the `AL_Cower` object.
--- @param for_perpetual boolean Whether the visit is for a perpetual visit.
--- @param dont_check_dist boolean Whether to skip checking the distance between the unit and the `AL_Cower` object.
--- @return boolean True if the `AL_Cower` object can be visited, false otherwise.
function AL_Cower:CanVisit(unit, for_perpetual, dont_check_dist)
	return AmbientLifeMarker.CanVisit(self, unit, for_perpetual, dont_check_dist)
end

DefineClass.AL_Defender_PlayAnimVariation = {
	__parents = { "AmbientLifeMarker", },
	__generated_by_class = "ClassDef",

	properties = {
		{ category = "Ambient Life", id = "VisitEnter", name = "Entering Visit", 
			editor = "combo", default = "", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitIdle", name = "During Visit", 
			editor = "combo", default = "nw_Standing_Idle", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitExit", name = "Exit Visit", 
			editor = "combo", default = "", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "Teleport", name = "Teleport", 
			editor = "bool", default = false, },
		{ category = "Ambient Life", id = "AllowAL", name = "Allow AL", 
			editor = "bool", default = false, },
		{ category = "Ambient Life", id = "GameStatesFilter", name = "States Required for Activation", 
			editor = "set", default = set(), three_state = true, items = function (self) return GetGameStateFilter end, },
		{ category = "Ambient Life", id = "Groups", name = "Groups", 
			editor = "string_list", default = {"AL_Defender"}, item_default = "AL_Defender", items = function (self)
local items = table.keys2(Groups or empty_table, "sorted")
table.insert(items, 1, "Closest AmbientZoneMarker")
return items
end, arbitrary_value = true, },
	},
	VisitPose = 1912,
	VisitVariation = true,
	Appearance = "Commando_Foreign_01",
}

--- @return table The visitable object for the `AL_Defender_PlayAnimVariation` class.
function AL_Defender_PlayAnimVariation:GenerateVisitable()
	local pos = self:GetPos()
	local lookat = pos + Rotate(point(const.SlabSizeX, 0), self:GetAngle())
	
	return {self, pos, lookat}
end

DefineClass.AL_Football = {
	__parents = { "AmbientLifeMarker", "GameDynamicDataObject", },
	__generated_by_class = "ClassDef",

	properties = {
		{ category = "Ambient Life", id = "VisitEnter", name = "Entering Visit", 
			editor = "combo", default = "", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitIdle", name = "During Visit", 
			editor = "combo", default = "civ_Ambient_PlayFootball", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitExit", name = "Exit Visit", 
			editor = "combo", default = "", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "PartnerUnitDataDef", name = "Partner's Unit Data Def", 
			editor = "combo", default = false, items = function (self) return table.keys(UnitDataDefs, "sorted") end, },
		{ category = "Ambient Life", id = "PartnerLocation", name = "Partner Location", help = "The other player to pass to", 
			editor = "point", default = false, 
			buttons = {{name = "View", func = function(self) ViewPos(self.Partner) end}}, helper = "absolute_pos", helper_class = "PropertyHelper_AppearanceObjectAbsolutePos", use_object = true, },
		{ category = "Ambient Life", id = "BallSpeedMin", name = "Ball Speed Min", help = "Minimum speed of the ball", 
			editor = "number", default = 3000, scale = "m", },
		{ category = "Ambient Life", id = "BallSpeedMax", name = "Ball Speed Max", help = "Maximum speed of the ball", 
			editor = "number", default = 6000, scale = "m", },
		{ category = "Ambient Life", id = "BallRPMMin", name = "Ball RPM Min", help = "Minimum RPM of the ball", 
			editor = "number", default = 30, },
		{ category = "Ambient Life", id = "BallRPMMax", name = "Ball RPM Max", help = "Maximum RPM of the ball", 
			editor = "number", default = 80, },
		{ category = "Ambient Life", id = "unit", name = "Unit", help = "the visitor", 
			editor = "object", default = false, dont_save = true, 
			no_edit = true, base_class = "Object", format_func = function (gameobj)
	if gameobj and IsValid(gameobj) then
		local x, y = gameobj:GetPos():xy()
		local label = gameobj:GetProperty("EditorLabel") or gameobj.class
		return string.format("%s x:%d y:%d", label, x, y)
	else
		return ""
	end
end, 
},
		{ category = "Ambient Life", id = "partner", name = "Partner", help = "the actual unit - cloned from the visitor", 
			editor = "object", default = false, dont_save = true, 
			no_edit = true, base_class = "Object", format_func = function (gameobj)
	if gameobj and IsValid(gameobj) then
		local x, y = gameobj:GetPos():xy()
		local label = gameobj:GetProperty("EditorLabel") or gameobj.class
		return string.format("%s x:%d y:%d", label, x, y)
	else
		return ""
	end
end, 
},
		{ category = "Ambient Life", id = "ball", name = "Ball", help = "the ball - passed between the units", 
			editor = "object", default = false, dont_save = true, 
			no_edit = true, base_class = "Object", format_func = function (gameobj)
	if gameobj and IsValid(gameobj) then
		local x, y = gameobj:GetPos():xy()
		local label = gameobj:GetProperty("EditorLabel") or gameobj.class
		return string.format("%s x:%d y:%d", label, x, y)
	else
		return ""
	end
end, 
},
		{ category = "Ambient Life", id = "player_killed", name = "Player Killed", help = "the ball - passed between the units", 
			editor = "object", default = false, dont_save = true, 
			no_edit = true, base_class = "Object", format_func = function (gameobj)
	if gameobj and IsValid(gameobj) then
		local x, y = gameobj:GetPos():xy()
		local label = gameobj:GetProperty("EditorLabel") or gameobj.class
		return string.format("%s x:%d y:%d", label, x, y)
	else
		return ""
	end
end, 
},
	},
	Appearance = "Smiley",
	VisitPose = 2020,
}

--- Generates the visitable object, position, and look-at point for the AL_Football object.
---
--- @return table The visitable object, position, and look-at point.
function AL_Football:GenerateVisitable()
	local pos = self:GetPos()
	local lookat = pos + Rotate(point(const.SlabSizeX, 0), self:GetAngle())
	
	return {self, pos, lookat}
end

--- Despawns the AL_Football object, cleaning up any associated game objects.
---
--- If the unit is valid, it is set to the "Idle" behavior.
--- If the partner is valid, it is destroyed using `DoneObject`.
--- If the ball is valid, it is destroyed using `DoneObject`.
--- Finally, the `AmbientLifeMarker.Despawn` function is called to complete the despawn process.
function AL_Football:Despawn()
	if IsValid(self.unit) then
		self.unit:SetBehavior()
		self.unit:SetCommand("Idle")
	end
	if IsValid(self.partner) then
		DoneObject(self.partner)
		self.partner = false
	end
	if IsValid(self.ball) then
		DoneObject(self.ball)
		self.ball = false
	end
	AmbientLifeMarker.Despawn(self)
end

--- Starts the visit process for the AL_Football object.
---
--- This function performs the following actions:
--- - Spawns a tool object for the visiting unit
--- - Places a "Shanty_Ball_01" object and attaches it to the visiting unit
--- - Stores a reference to the visiting unit
--- - Spawns a partner unit and has the visiting unit face the partner
--- - Sets the visit animation for the visiting unit
--- - If the visiting unit has a perpetual marker, sets a random phase for the "hit" moment
---
--- @param unit The visiting unit
function AL_Football:StartVisit(unit)
	self:SpawnTool(unit)
	self.ball = PlaceObject("Shanty_Ball_01")
	unit:Attach(self.ball, unit:GetSpotBeginIndex("Ball1"))
	
	self.unit = unit
	self:SpawnPartner()
	self.partner:Face(unit)
	unit:Face(self.partner)
	self:SetVisitAnimation(unit)
	if unit.perpetual_marker then
		local phase = self:Random(unit:TimeToMoment(1, "hit"))
		unit:SetPhaseHighLevel(phase)
	end
end

--- Spawns a partner unit for the AL_Football object.
---
--- This function performs the following actions:
--- - Checks if a valid partner unit already exists, and returns if so
--- - Determines the unit data definition for the partner unit
--- - Generates a unique session ID for the partner unit
--- - Spawns the partner unit using the determined unit data definition and session ID
--- - Sets the partner unit's zone to the current AL_Football object
--- - Sets the partner unit's side to "neutral"
--- - Sets the partner unit's routine spawner to the visiting unit's routine spawner
--- - Chooses and applies an appearance for the partner unit
--- - Sets the partner unit's state to "civ_Standing_Idle"
--- - Sets the partner unit's position to the PartnerLocation
--- - Sets the partner unit's command to false and disables its SetCommand function
---
--- @param unit The visiting unit (not used)
function AL_Football:SpawnPartner(unit)
	if IsValid(self.partner) then return end
	
	local unit_def = UnitDataDefs[self.PartnerUnitDataDef]
	
	local pers_session_id = (unit_def and (unit_def.PersistentSessionId or "") ~= "") and  unit_def.PersistentSessionId
	local session_id = pers_session_id or GenerateUniqueUnitDataId("AmbientSpawnDef", gv_CurrentSectorId or "A1", "ClonedFootballPartner")
	local unitdatadef_id = unit_def and unit_def.id or self.unit.unitdatadef_id
	
	self.partner = SpawnUnit(unitdatadef_id, session_id)
	CheckUniqueSessionId(self.partner)
	self.partner.zone = self
	self.partner:SetSide("neutral")
	self.partner.routine_spawner = self.unit.routine_spawner
	
	local appearance = ChooseUnitAppearance(unitdatadef_id, self.partner.handle)
	self.partner:ApplyAppearance(appearance)
	self.partner:SetState("civ_Standing_Idle")
	self.partner:SetPos(self.PartnerLocation)
	self.partner:SetCommand(false)
	self.partner.SetCommand = empty_func
end

---
--- Sets the dynamic data for the AL_Football object.
---
--- This function performs the following actions:
--- - Sets the partner unit for the AL_Football object, if a valid partner exists in the provided data
--- - Checks if the partner unit is a valid Unit object, and sets it to false if not
--- - If a valid partner unit exists, sets its command to false and disables its SetCommand function
--- - Sets the player_killed flag for the AL_Football object based on the provided data
---
--- @param data A table containing the dynamic data for the AL_Football object
function AL_Football:SetDynamicData(data)
	self.partner = data.partner and HandleToObject[data.partner] or false
	if not IsKindOf(self.partner, "Unit") then
		self.partner = false
	end
	if self.partner then
		if not self:IsPartnerDead() then
			self.partner:SetCommand(false)
			self.partner.SetCommand = empty_func
		end
	end
	self.player_killed = data.player_killed or false
end

---
--- Retrieves the dynamic data for the AL_Football object.
---
--- This function performs the following actions:
--- - Sets the `partner` field in the provided `data` table to the handle of the partner unit, or `nil` if no partner exists
--- - Sets the `player_killed` field in the provided `data` table to the value of the `player_killed` field of the AL_Football object, or `nil` if the field is `false`
---
--- @param data A table to store the dynamic data for the AL_Football object
function AL_Football:GetDynamicData(data)
	data.partner = self.partner and self.partner.handle or nil
	data.player_killed = self.player_killed or nil
end

---
--- Visits the AL_Football object, performing various actions related to the football game.
---
--- This function performs the following actions:
--- - Moves the unit to the marker spot using `GotoEnterSpot`.
--- - Pushes a destructor function to the unit's stack, which is called when the visit is over. This function:
---   - Sets the `perpetual_unit` flag to `false` if it was set.
---   - Frees the unit's visitable state.
---   - Calls `ExitVisit` on the AL_Football object.
---   - Destroys the partner unit and the football object if they are valid.
--- - Calls `Enter` on the AL_Football object to start the visit.
--- - Enters a loop that continues until the partner unit is dead, the `perpetual_unit` flag is set to a different unit, or the minimum visit duration is reached.
---   - In each iteration of the loop, the function calls `PlayBall` on the AL_Football object, passing the unit and partner unit as arguments, along with a random animation index.
---   - The loop sleeps for a random duration between 50 and 100 milliseconds.
--- - Calls the destructor function pushed earlier to the unit's stack, which cleans up the visit.
---
--- @param unit The unit visiting the AL_Football object.
--- @param dest The destination position for the visit, or the object's position if not provided.
--- @param lookat The position the unit should look at during the visit.
function AL_Football:Visit(unit, dest, lookat)
	dest = dest or self:GetPos()
	
	-- going to the marker spot
	if not self:GotoEnterSpot(unit, dest) then return end
	
	-- prepare the unbreakable exit from the marker
	local tool
	unit:PushDestructor(function()
		if self.perpetual_unit then
			self.perpetual_unit = false
		end
		unit:FreeVisitable()
		if not IsValid(unit) then return end
		self:ExitVisit(unit)
		if not self:IsPartnerDead() then
			DoneObject(self.partner)
			self.partner = false
		end
		DoneObject(self.ball)
		self.ball = false
	end)
	
	local start_time = GameTime()
	self:Enter(unit, dest, lookat)
	local visit_duration = GameTime() - start_time
	if self.VisitMinDuration and visit_duration >= self.VisitMinDuration then return end
	
	-- actual visit
	self:StartVisit(unit)
	repeat
		local start_time = GameTime()
		if IsValid(unit) and not self:IsPartnerDead() then
			local _, ball_spot_index = unit:GetRandomAnim(self.VisitIdle)
			self:PlayBall(unit, self.partner, ball_spot_index)
		end
		if IsValid(unit) and not self:IsPartnerDead() then
			local _, ball_spot_index = self.partner:GetRandomAnim(self.VisitIdle)
			self:PlayBall(self.partner, unit, ball_spot_index)
		end
		Sleep(50 + self:Random(50))
		visit_duration = visit_duration + (GameTime() - start_time)
	until self:IsPartnerDead() or (self.perpetual_unit and self.perpetual_unit ~= unit) or (self.VisitMinDuration and visit_duration >= self.VisitMinDuration)
	
	-- unbreakable exit from the marker
	unit:PopAndCallDestructor()
end

--- Plays a ball between the given unit and its partner.
---
--- @param unit The unit that is playing the ball.
--- @param partner The partner unit that the ball is being played to.
--- @param ball_spot_index The index of the spot on the partner unit where the ball should be played to.
function AL_Football:PlayBall(unit, partner, ball_spot_index)
	Sleep(unit:TimeToMoment(1, "hit") or 0)
	self.ball:Detach()
	if not self:IsPartnerDead() then
		self:ShootBall(partner, ball_spot_index, unit, unit:TimeToAnimEnd())
	end
end

--- Checks if the partner of this AL_Football instance is dead.
---
--- @return boolean True if the partner is dead, false otherwise.
function AL_Football:IsPartnerDead()
	return IsValid(self.partner) and self.partner:IsDead()
end

---
--- Returns the editor text for this AL_Football instance.
---
--- If the player has been killed, returns "AL CAN'T Visit(Inactive do the dead player)". Otherwise, returns the editor text from the base AmbientLifeMarker class.
---
--- @return string The editor text for this AL_Football instance.
function AL_Football:EditorGetText()
	if self.player_killed then
		return "AL CAN'T Visit(Inactive do the dead player)"
	end
	
	return AmbientLifeMarker.EditorGetText(self)
end

---
--- Returns the editor text color for this AL_Football instance.
---
--- If the player has been killed, returns the red color. Otherwise, returns the editor text color from the base AmbientLifeMarker class.
---
--- @return number The editor text color for this AL_Football instance.
function AL_Football:EditorGetTextColor()
	if self.player_killed then
		return const.clrRed
	end
	
	return AmbientLifeMarker.EditorGetTextColor(self)
end

--- Checks if the current AL_Football instance can be visited by the given unit.
---
--- @param unit The unit that is attempting to visit the AL_Football instance.
--- @param for_perpetual Whether the visit is for a perpetual activity.
--- @param dont_check_dist Whether to skip checking the distance to the partner.
--- @return boolean True if the AL_Football instance can be visited, false otherwise.
function AL_Football:CanVisit(unit, for_perpetual, dont_check_dist)
	if self.player_killed or not IsValid(self.partner) then
		return false
	end
	
	return AmbientLifeMarker.CanVisit(self, unit, for_perpetual, dont_check_dist)
end

---
--- Shoots a football from the AL_Football instance to a target position.
---
--- @param target The target object to shoot the ball at.
--- @param ball_spot_index The index of the ball spot on the target object.
--- @param ball_dest The destination position for the ball.
--- @param kicker The unit kicking the ball.
--- @param kicker_time_end The time when the kicker's animation should end.
---
function AL_Football:ShootBall(target, ball_spot_index, ball_dest, kicker, kicker_time_end)
	if target:GetEnumFlags(const.efVisible) ~= 0 then
		self.ball:SetEnumFlags(const.efVisible)
	else
		self.ball:ClearEnumFlags(const.efVisible)
	end
	
	local target_spot = "Ball" .. ball_spot_index
	local ball_spot = target:GetSpotBeginIndex(target_spot)
	local ball_dest = target:GetSpotPos(ball_spot)
	local ball_start = self.ball:GetPos()
	local ball_dir = ball_dest - ball_start
	local ball_speed = self.BallSpeedMin + self:Random(self.BallSpeedMax - self.BallSpeedMin)
	local ball_travel_time = MulDivTrunc(ball_dir:Len(), 1000, ball_speed)
	local rpm = self.BallRPMMin * 360+ self:Random((self.BallRPMMax - self.BallRPMMin) * 360)
	local angle = MulDivTrunc(rpm, ball_travel_time, 1000)
	local axis = Rotate(ball_dir, 90 * 60)
	self.ball:SetAxis(axis)
	self.ball:SetPos(ball_dest, ball_travel_time)
	
	local suffix = (ball_spot_index == 1) and "" or tostring(ball_spot_index)
	local target_football_anim = self.VisitIdle .. suffix
	local recieve_moment = target:GetAnimMoment(target_football_anim, "start")
	ball_travel_time = (ball_travel_time < recieve_moment) and recieve_moment or ball_travel_time
	local target_time_recieve = ball_travel_time - recieve_moment
	local time, dt_sleep = 0, 10
	while not self:IsPartnerDead() and time < ball_travel_time do
		local dt = Min(dt_sleep, ball_travel_time - time)
		dt = kicker_time_end and Min(dt, kicker_time_end - time) or dt
		dt = target_time_recieve and Min(dt, target_time_recieve - time) or dt
		self.ball:SetAngle(self.ball:GetAngle() + MulDivTrunc(dt, angle, ball_travel_time))
		Sleep(dt)
		time = time + dt
		if kicker_time_end and time >= kicker_time_end then
			local idle_base = (self:Random(100) < 50) and "civ_Standing_Idle" or "civ_Standing_IdlePassive"
			local idle_anim = kicker:GetNearbyUniqueRandomAnim(idle_base)
			kicker:SetState(idle_anim)
			kicker_time_end = false
		end
		if target_time_recieve and time >= target_time_recieve then
			target:SetState(target_football_anim)
			target_time_recieve = false
		end
	end
	self.ball:SetAxis(axis_z)
	self.ball:SetPos(ball_dest)
end

--- Applies the appearance of the AL_Football instance to the given helper object.
---
--- @param helper AmbientLifeHelper The helper object to apply the appearance to.
function AL_Football:OnHelperCreated(helper)
	helper:ApplyAppearance(self.Appearance)
end

DefineClass.AL_Maraud = {
	__parents = { "AmbientLifeMarker", },
	__generated_by_class = "ClassDef",

	properties = {
		{ category = "Ambient Life", id = "VisitEnter", name = "Entering Visit", 
			editor = "combo", default = "", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitIdle", name = "During Visit", 
			editor = "combo", default = "civ_Ambient_FindSomething", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitExit", name = "Exit Visit", 
			editor = "combo", default = "", items = function (self) return GetStates("Male") end, },
		{ id = "corspe", name = "Corspe", 
			editor = "object", default = false, dont_save = true, read_only = true, base_class = "Object", format_func = function (gameobj)
	if gameobj and IsValid(gameobj) then
		local x, y = gameobj:GetPos():xy()
		local label = gameobj:GetProperty("EditorLabel") or gameobj.class
		return string.format("%s x:%d y:%d", label, x, y)
	else
		return ""
	end
end, 
},
	},
	VisitPose = 912,
	VisitVariation = true,
	IgnoreGroupsMatch = true,
}

--- Generates a visitable object for the AL_Maraud class.
---
--- @return table The visitable object, containing the AL_Maraud instance, its position, and a look-at position.
function AL_Maraud:GenerateVisitable()
	local pos = self:GetPos()
	local lookat = pos + Rotate(point(const.SlabSizeX, 0), self:GetAngle())
	
	return {self, pos, lookat}
end

--- Determines whether the AL_Maraud instance can be visited by the given unit.
---
--- @param unit Unit The unit that wants to visit the AL_Maraud instance.
--- @param for_perpetual boolean Whether the visit is for a perpetual visit.
--- @param dont_check_dist boolean Whether to skip checking the distance between the unit and the AL_Maraud instance.
--- @return boolean True if the AL_Maraud instance can be visited, false otherwise.
function AL_Maraud:CanVisit(unit, for_perpetual, dont_check_dist)
	if unit.ImportantNPC then
		return false
	end
	
	if self.corpse and unit:GetSide() == "neutral" then
		if not IsKindOf(self.corpse, "Unit") then
			-- Somehow Units becomes an ItemDropContainer
			return false
		end
		local side = self.corpse:GetSide()
		if not (side == "enemy1" or side == "enemy2" or side == "player1" or side == "player2") then
			return false
		end
	end
	
	return AmbientLifeMarker.CanVisit(self, unit, for_perpetual, dont_check_dist)
end

--- Provides the editor text for the AL_Maraud class.
---
--- If the corpse associated with the AL_Maraud instance is not valid or not a Unit, returns an error message. Otherwise, delegates to the AmbientLifeMarker.EditorGetText function.
---
--- @return string The editor text for the AL_Maraud instance.
function AL_Maraud:EditorGetText()
	if not IsValid(self.corpse) then
		return "AL CAN'T Visit(Corpse is missing)"
	end
	if not IsKindOf(self.corpse, "Unit") then
		return "AL CAN'T Visit(Corpse is not Unit?!?)"
	end
	
	return AmbientLifeMarker.EditorGetText(self)
end

--- Provides the editor text color for the AL_Maraud class.
---
--- If the corpse associated with the AL_Maraud instance is not valid or not a Unit, returns the red color. Otherwise, delegates to the AmbientLifeMarker.EditorGetTextColor function.
---
--- @return color The editor text color for the AL_Maraud instance.
function AL_Maraud:EditorGetTextColor()
	if not IsValid(self.corpse) or not IsKindOf(self.corpse, "Unit") then
		return const.clrRed
	end
	
	return AmbientLifeMarker.EditorGetTextColor(self)
end

--- Stores the dynamic data for the AL_Maraud class.
---
--- This function is used to store the corpse associated with the AL_Maraud instance in the provided data table. If the corpse is valid, its handle is stored in the `corpse` field of the data table. Otherwise, `false` is stored.
---
--- @param data table The data table to store the dynamic data in.
function AL_Maraud:GetDynamicData(data)
	data.corpse = self.corpse and self.corpse.handle or false
end

--- Sets the dynamic data for the AL_Maraud class.
---
--- This function is used to set the corpse associated with the AL_Maraud instance from the provided data table. If the `corpse` field in the data table is valid, the corresponding object handle is stored in the `corpse` field of the AL_Maraud instance. Otherwise, `false` is stored.
---
--- @param data table The data table containing the dynamic data to set.
function AL_Maraud:SetDynamicData(data)
	self.corpse = data.corpse and HandleToObject[data.corpse] or false
end

--- Called when the visit animation for the AL_Maraud class has ended.
---
--- This function is responsible for handling the loot drop from the corpse associated with the AL_Maraud instance. It first tries to find a Valuables item in the corpse's inventory, and if successful, removes the item from the corpse and adds it to the visiting unit's inventory. If no Valuables item is found, it looks for any other item in the corpse's inventory and adds it to the visiting unit's inventory. Finally, it creates a floating text message to indicate that the unit has picked up something.
---
--- @param unit Unit The unit that is visiting the AL_Maraud instance.
function AL_Maraud:OnVisitAnimEnded(unit)
	local item = self.corpse:FindItemInSlot("InventoryDead", function(item, self)
		if IsKindOf(item, "Valuables") then
			if self:Random(100) < item.drop_chance then
				return item
			end
		end
	end, self)
	if not item then
		item = self.corpse:FindItemInSlot("InventoryDead", function(item, self)
			if not IsKindOf(item, "Valuables") then
				if self:Random(100) < item.drop_chance then
					return item
				end
			end
		end, self)
	end
	if item then
		self.corpse:RemoveItem("InventoryDead", item)
		unit:AddItem("Inventory", item)
		CreateFloatingText(unit:GetVisualPos(),  T(911186423849, "Picked up something"))
	end
end

DefineClass.AL_MineWorkPick = {
	__parents = { "AmbientLifeMarker", },
	__generated_by_class = "ClassDef",

	properties = {
		{ category = "Ambient Life", id = "VisitEnter", name = "Entering Visit", 
			editor = "combo", default = "", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitIdle", name = "During Visit", 
			editor = "combo", default = "civ_Work_Pick", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitExit", name = "Exit Visit", 
			editor = "combo", default = "", items = function (self) return GetStates("Male") end, },
	},
	ToolEntity = "Mine_PickAxe",
	VisitPose = 1912,
}

--- Generates a visitable object for the AL_MineWorkPick class.
---
--- This function is responsible for generating the position and look-at point for the visitable object associated with the AL_MineWorkPick class. It retrieves the current position of the object and calculates the look-at point by rotating a point with the X-coordinate equal to the slab size along the object's angle.
---
--- @return table The visitable object, containing the object itself, the position, and the look-at point.
function AL_MineWorkPick:GenerateVisitable()
	local pos = self:GetPos()
	local lookat = pos + Rotate(point(const.SlabSizeX, 0), self:GetAngle())
	
	return {self, pos, lookat}
end

DefineClass.AL_MineWorkShovel = {
	__parents = { "AmbientLifeMarker", },
	__generated_by_class = "ClassDef",

	properties = {
		{ category = "Ambient Life", id = "VisitEnter", name = "Entering Visit", 
			editor = "combo", default = "", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitIdle", name = "During Visit", 
			editor = "combo", default = "civ_Work_Shovel", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitExit", name = "Exit Visit", 
			editor = "combo", default = "", items = function (self) return GetStates("Male") end, },
	},
	ToolEntity = "Mine_Shovel",
	VisitPose = 8154,
}

--- Generates a visitable object for the AL_MineWorkShovel class.
---
--- This function is responsible for generating the position and look-at point for the visitable object associated with the AL_MineWorkShovel class. It retrieves the current position of the object and calculates the look-at point by rotating a point with the X-coordinate equal to the slab size along the object's angle.
---
--- @return table The visitable object, containing the object itself, the position, and the look-at point.
function AL_MineWorkShovel:GenerateVisitable()
	local pos = self:GetPos()
	local lookat = pos + Rotate(point(const.SlabSizeX, 0), self:GetAngle())
	
	return {self, pos, lookat}
end

DefineClass.AL_MineWorkSift = {
	__parents = { "AmbientLifeMarker", },
	__generated_by_class = "ClassDef",

	properties = {
		{ category = "Ambient Life", id = "VisitEnter", name = "Entering Visit", 
			editor = "combo", default = "", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitIdle", name = "During Visit", 
			editor = "combo", default = "civ_Work_Sift", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitExit", name = "Exit Visit", 
			editor = "combo", default = "", items = function (self) return GetStates("Male") end, },
	},
	ToolEntity = "Mine_WoodenTray",
	VisitPose = 8154,
}

--- Generates a visitable object for the AL_MineWorkSift class.
---
--- This function is responsible for generating the position and look-at point for the visitable object associated with the AL_MineWorkSift class. It retrieves the current position of the object and calculates the look-at point by rotating a point with the X-coordinate equal to the slab size along the object's angle.
---
--- @return table The visitable object, containing the object itself, the position, and the look-at point.
function AL_MineWorkSift:GenerateVisitable()
	local pos = self:GetPos()
	local lookat = pos + Rotate(point(const.SlabSizeX, 0), self:GetAngle())
	
	return {self, pos, lookat}
end

DefineClass.AL_Mourn = {
	__parents = { "AmbientLifeMarker", },
	__generated_by_class = "ClassDef",

	properties = {
		{ category = "Ambient Life", id = "VisitEnter", name = "Entering Visit", 
			editor = "combo", default = "", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitIdle", name = "During Visit", 
			editor = "combo", default = "civ_Ambient_SadCrying", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitExit", name = "Exit Visit", 
			editor = "combo", default = "", items = function (self) return GetStates("Male") end, },
		{ id = "corspe", name = "Corspse", 
			editor = "object", default = false, dont_save = true, read_only = true, base_class = "Object", format_func = function (gameobj)
	if gameobj and IsValid(gameobj) then
		local x, y = gameobj:GetPos():xy()
		local label = gameobj:GetProperty("EditorLabel") or gameobj.class
		return string.format("%s x:%d y:%d", label, x, y)
	else
		return ""
	end
end, 
},
	},
	VisitPose = 1312,
	VisitVariation = true,
	IgnoreGroupsMatch = true,
}

--- Generates a visitable object for the AL_MineWorkSift class.
---
--- This function is responsible for generating the position and look-at point for the visitable object associated with the AL_MineWorkSift class. It retrieves the current position of the object and calculates the look-at point by rotating a point with the X-coordinate equal to the slab size along the object's angle.
---
--- @return table The visitable object, containing the object itself, the position, and the look-at point.
function AL_Mourn:GenerateVisitable()
	local pos = self:GetPos()
	local lookat = pos + Rotate(point(const.SlabSizeX, 0), self:GetAngle())
	
	return {self, pos, lookat}
end

--- Determines whether the AL_Mourn object can be visited by a given unit.
---
--- This function checks various conditions to determine if the AL_Mourn object can be visited by the given unit. It first checks if the unit is an ImportantNPC, in which case it cannot be visited. It then checks if the AL_Mourn object has a corpse associated with it, and if the unit's side is "neutral". If the corpse is not a Unit, or if the corpse's side is "enemy1", "enemy2", or "neutral", the function returns false, indicating that the unit cannot visit the AL_Mourn object.
---
--- If the above conditions are not met, the function calls the CanVisit function of the parent AmbientLifeMarker class to perform additional checks.
---
--- @param unit table The unit that is attempting to visit the AL_Mourn object.
--- @param for_perpetual boolean Whether the visit is for a perpetual visit.
--- @param dont_check_dist boolean Whether to skip checking the distance between the unit and the AL_Mourn object.
--- @return boolean True if the unit can visit the AL_Mourn object, false otherwise.
function AL_Mourn:CanVisit(unit, for_perpetual, dont_check_dist)
	if unit.ImportantNPC then
		return false
	end
	
	if self.corpse and unit:GetSide() == "neutral" then
		if not IsKindOf(self.corpse, "Unit") then
			-- Somehow Units becomes an ItemDropContainer
			return false
		end
		local side = self.corpse:GetSide()
		if side == "enemy1" or side == "enemy2" or side == "neutral" then
			return false
		end
	end
	
	return AmbientLifeMarker.CanVisit(self, unit, for_perpetual, dont_check_dist)
end

--- Provides a custom text representation for the AL_Mourn class in the editor.
---
--- This function is responsible for generating the text that will be displayed for the AL_Mourn object in the editor. It first checks if the object's `corpse` property is valid and if it is an instance of the `Unit` class. If the `corpse` is missing or not a `Unit`, the function returns a custom error message. Otherwise, it calls the `EditorGetText` function of the parent `AmbientLifeMarker` class to get the default text representation.
---
--- @return string The text representation of the AL_Mourn object in the editor.
function AL_Mourn:EditorGetText()
	if not IsValid(self.corpse) then
		return "AL CAN'T Visit(Corpse is missing)"
	end
	if not IsKindOf(self.corpse, "Unit") then
		return "AL CAN'T Visit(Corpse is not Unit?!?)"
	end
	
	return AmbientLifeMarker.EditorGetText(self)
end

--- Determines the text color to be used for displaying the AL_Mourn object in the editor.
---
--- This function checks if the `corpse` property of the AL_Mourn object is valid and if it is an instance of the `Unit` class. If the `corpse` is missing or not a `Unit`, the function returns the red color constant `const.clrRed`, indicating that there is an issue with the object. Otherwise, it calls the `EditorGetTextColor` function of the parent `AmbientLifeMarker` class to get the default text color.
---
--- @return color The text color to be used for displaying the AL_Mourn object in the editor.
function AL_Mourn:EditorGetTextColor()
	if not IsValid(self.corpse) or not IsKindOf(self.corpse, "Unit") then
		return const.clrRed
	end
	
	return AmbientLifeMarker.EditorGetTextColor(self)
end

--- Stores the dynamic data for the AL_Mourn object.
---
--- This function is responsible for storing the dynamic data for the AL_Mourn object, specifically the `corpse` property. If the `corpse` property is valid, its handle is stored in the `data.corpse` field. Otherwise, `data.corpse` is set to `false`.
---
--- @param data table The table to store the dynamic data in.
function AL_Mourn:GetDynamicData(data)
	data.corpse = self.corpse and self.corpse.handle or false
end

--- Sets the dynamic data for the AL_Mourn object.
---
--- This function is responsible for setting the `corpse` property of the AL_Mourn object based on the `data.corpse` field. If `data.corpse` is valid, the corresponding `Unit` object is assigned to `self.corpse`. Otherwise, `self.corpse` is set to `false`.
---
--- @param data table The table containing the dynamic data to be set.
function AL_Mourn:SetDynamicData(data)
	self.corpse = data.corpse and HandleToObject[data.corpse] or false
end

DefineClass.AL_PlayAnimVariation = {
	__parents = { "AmbientLifeMarker", },
	__generated_by_class = "ClassDef",

	properties = {
		{ category = "Ambient Life", id = "VisitEnter", name = "Entering Visit", 
			editor = "combo", default = "", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitIdle", name = "During Visit", 
			editor = "combo", default = "nw_Standing_Idle", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitExit", name = "Exit Visit", 
			editor = "combo", default = "", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "Teleport", name = "Teleport", 
			editor = "bool", default = false, },
		{ category = "Ambient Life", id = "GameStatesFilter", name = "States Required for Activation", 
			editor = "set", default = set( {Conflict = false} ), three_state = true, items = function (self) return GetGameStateFilter end, },
	},
	VisitPose = 1912,
	VisitVariation = true,
	Appearance = "Legion_Jose",
}

--- Generates the visitable data for the AL_PlayAnimVariation object.
---
--- This function calculates the position and look-at point for the AL_PlayAnimVariation object. The position is simply the object's current position, and the look-at point is calculated by rotating a point with the constant `const.SlabSizeX` along the object's angle.
---
--- @return table The visitable data, containing the object itself, the position, and the look-at point.
function AL_PlayAnimVariation:GenerateVisitable()
	local pos = self:GetPos()
	local lookat = pos + Rotate(point(const.SlabSizeX, 0), self:GetAngle())
	
	return {self, pos, lookat}
end

DefineClass.AL_Prostitute_Idle = {
	__parents = { "AmbientLifeMarker", },
	__generated_by_class = "ClassDef",

	properties = {
		{ category = "Ambient Life", id = "VisitEnter", name = "Entering Visit", 
			editor = "combo", default = "", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitIdle", name = "During Visit", 
			editor = "combo", default = "civ_Seduce_Idle", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitExit", name = "Exit Visit", 
			editor = "combo", default = "", items = function (self) return GetStates("Male") end, },
	},
	VisitPose = 1912,
	VisitVariation = true,
	Appearance = "VillagerFemale_01",
}

--- Generates the visitable data for the AL_Prostitute_Idle object.
---
--- This function calculates the position and look-at point for the AL_Prostitute_Idle object. The position is simply the object's current position, and the look-at point is calculated by rotating a point with the constant `const.SlabSizeX` along the object's angle.
---
--- @return table The visitable data, containing the object itself, the position, and the look-at point.
function AL_Prostitute_Idle:GenerateVisitable()
	local pos = self:GetPos()
	local lookat = pos + Rotate(point(const.SlabSizeX, 0), self:GetAngle())
	
	return {self, pos, lookat}
end

--- Checks if the given unit can visit this AL_Prostitute_Idle object.
---
--- This function first calls the base `AmbientLifeMarker:CanVisit()` function to perform the default checks. It then additionally checks if the given unit is a prostitute.
---
--- @param unit table The unit that wants to visit this object.
--- @param for_perpetual boolean Whether the visit is for a perpetual visit.
--- @param dont_check_dist boolean Whether to skip the distance check.
--- @return boolean True if the unit can visit this object, false otherwise.
function AL_Prostitute_Idle:CanVisit(unit, for_perpetual, dont_check_dist)
	return AmbientLifeMarker.CanVisit(self, unit, for_perpetual, dont_check_dist) and unit:IsProstitute()
end

DefineClass.AL_Prostitute_Parade = {
	__parents = { "AmbientLifeMarker", },
	__generated_by_class = "ClassDef",

	properties = {
		{ category = "Ambient Life", id = "VisitEnter", name = "Entering Visit", 
			editor = "combo", default = "", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitIdle", name = "During Visit", 
			editor = "combo", default = "civ_Seduce_Parade", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitExit", name = "Exit Visit", 
			editor = "combo", default = "", items = function (self) return GetStates("Male") end, },
	},
	VisitPose = 11477,
	VisitVariation = true,
	Appearance = "VillagerFemale_01",
}

--- Generates the visitable data for the AL_Prostitute_Parade object.
---
--- This function calculates the position and look-at point for the AL_Prostitute_Parade object. The position is simply the object's current position, and the look-at point is calculated by rotating a point with the constant `const.SlabSizeX` along the object's angle.
---
--- @return table The visitable data, containing the object itself, the position, and the look-at point.
function AL_Prostitute_Parade:GenerateVisitable()
	local pos = self:GetPos()
	local lookat = pos + Rotate(point(const.SlabSizeX, 0), self:GetAngle())
	
	return {self, pos, lookat}
end

--- Checks if the given unit can visit this AL_Prostitute_Parade object.
---
--- This function first calls the base `AmbientLifeMarker:CanVisit()` function to perform the default checks. It then additionally checks if the given unit is a prostitute.
---
--- @param unit table The unit that wants to visit this object.
--- @param for_perpetual boolean Whether the visit is for a perpetual visit.
--- @param dont_check_dist boolean Whether to skip the distance check.
--- @return boolean True if the unit can visit this object, false otherwise.
function AL_Prostitute_Parade:CanVisit(unit, for_perpetual, dont_check_dist)
	return AmbientLifeMarker.CanVisit(self, unit, for_perpetual, dont_check_dist) and unit:IsProstitute()
end

DefineClass.AL_Roam = {
	__parents = { "AmbientLifeMarker", },
	__generated_by_class = "ClassDef",

	properties = {
		{ category = "Ambient Life", id = "VisitEnter", name = "Entering Visit", 
			editor = "combo", default = "", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitIdle", name = "During Visit", 
			editor = "combo", default = "civ_Standing_Idle", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitExit", name = "Exit Visit", 
			editor = "combo", default = "", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "Teleport", name = "Teleport", 
			editor = "bool", default = false, },
		{ category = "Ambient Life", id = "DontReorient", name = "Don't Reorient", help = "Does not reorient the unit to marker position", 
			editor = "bool", default = false, },
		{ category = "Ambient Life", id = "GameStatesFilter", name = "States Required for Activation", 
			editor = "set", default = set( {Conflict = false} ), three_state = true, items = function (self) return GetGameStateFilter end, },
	},
	VisitPose = 1912,
	VisitVariation = true,
	Appearance = "VillagerFemale_01",
}

--- Applies the specified appearance to the AL_Roam object and sets a green color modifier on the object and its parts.
---
--- @param appearance string The appearance to apply to the object.
--- @param force boolean Whether to force the appearance change.
function AL_Roam:ApplyAppearance(appearance, force)
	AppearanceObject.ApplyAppearance(self, appearance, force)
	
	local clr = const.clrGreen
	self:SetColorModifier(clr)
	for _, part in ipairs(self.parts) do
		part:SetColorModifier(clr)
	end
end

DefineClass.AL_SitChair = {
	__parents = { "AmbientLifeMarker", },
	__generated_by_class = "ClassDef",

	properties = {
		{ category = "Ambient Life", id = "VisitEnter", name = "Entering Visit", 
			editor = "combo", default = "civ_Sit_Start", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitIdle", name = "During Visit", 
			editor = "combo", default = "civ_Sit_Idle", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitExit", name = "Exit Visit", 
			editor = "combo", default = "civ_Sit_End", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "Teleport", name = "Teleport", 
			editor = "bool", default = false, },
		{ category = "Ambient Life", id = "GameStatesFilter", name = "States Required for Activation", 
			editor = "set", default = set( {Conflict = false} ), three_state = true, items = function (self) return GetGameStateFilter end, },
		{ category = "Ambient Life", id = "EditorMarkerVisitAnim", name = "Editor Marker Visit Anim", 
			editor = "combo", default = "editorMarkerAnim_Sit", items = function (self) return GetStates("Male") end, },
	},
	VisitPose = 16,
	Appearance = "Legion_Jose",
	VisitSupportCollectionVME = true,
}

--- Checks if the given unit can visit the AL_SitChair object.
---
--- @param unit table The unit that wants to visit the AL_SitChair object.
--- @param for_perpetual boolean Whether the visit is for a perpetual visit.
--- @param dont_check_dist boolean Whether to skip checking the distance to the nearest enemy.
--- @return boolean True if the unit can visit the AL_SitChair object, false otherwise.
function AL_SitChair:CanVisit(unit, for_perpetual, dont_check_dist)
	local enemy, dist = GetNearestEnemy(unit, "ignore awareness")
	if enemy and dist <= const.AmbientLife.ForbidSitChairEnemyDist then
		return false
	end
	
	return AmbientLifeMarker.CanVisit(self, unit, for_perpetual, dont_check_dist)
end

DefineClass.AL_SitChair_SleepingAtTable = {
	__parents = { "AL_SitChair", },
	__generated_by_class = "ClassDef",

	properties = {
		{ category = "Ambient Life", id = "VisitEnter", name = "Entering Visit", 
			editor = "combo", default = "civ_Ambient_SleepingAtTable_Start", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitIdle", name = "During Visit", 
			editor = "combo", default = "civ_Ambient_SleepingAtTable", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitExit", name = "Exit Visit", 
			editor = "combo", default = "civ_Ambient_SleepingAtTable_End", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "Teleport", name = "Teleport", 
			editor = "bool", default = false, },
		{ category = "Ambient Life", id = "GameStatesFilter", name = "States Required for Activation", 
			editor = "set", default = set( {Conflict = false} ), three_state = true, items = function (self) return GetGameStateFilter end, },
		{ category = "Ambient Life", id = "EditorMarkerVisitAnim", name = "Editor Marker Visit Anim", 
			editor = "combo", default = "editorMarkerAnim_Sit", items = function (self) return GetStates("Male") end, },
	},
	VisitPose = 16,
	Appearance = "Legion_Jose",
	VisitSupportCollectionVME = true,
}

--- Checks if the given unit can visit the AL_SitChair_SleepingAtTable object.
---
--- @param unit table The unit that wants to visit the AL_SitChair_SleepingAtTable object.
--- @param for_perpetual boolean Whether the visit is for a perpetual visit.
--- @param dont_check_dist boolean Whether to skip checking the distance to the nearest enemy.
--- @return boolean True if the unit can visit the AL_SitChair_SleepingAtTable object, false otherwise.
function AL_SitChair_SleepingAtTable:CanVisit(unit, for_perpetual, dont_check_dist)
	local enemy, dist = GetNearestEnemy(unit, "ignore awareness", dont_check_dist)
	if enemy and dist <= const.AmbientLife.ForbidSitChairEnemyDist then
		return false
	end
	
	return AmbientLifeMarker.CanVisit(self, unit, for_perpetual, dont_check_dist)
end

DefineClass.AL_Talk = {
	__parents = { "AmbientLifeMarker", },
	__generated_by_class = "ClassDef",

	properties = {
		{ category = "Ambient Life", id = "VisitEnter", name = "Entering Visit", 
			editor = "combo", default = "", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitIdle", name = "During Visit", 
			editor = "combo", default = "nw_Standing_IdlePassive", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitAlternate", name = "During Visit Alternate", help = 'There is some chance to play this animation instead of the original "During Visit" one', 
			editor = "combo", default = "civ_Talking", 
			no_edit = function(self) return self.VisitAlternateChance == 0 end, items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitExit", name = "Exit Visit", 
			editor = "combo", default = "", items = function (self) return GetStates("Male") end, },
	},
	VisitPose = 8866,
	VisitVariation = true,
	VisitAlternateVariation = true,
	VisitAlternateChance = 50,
	EmotionChance = 10,
	Appearance = "VillagerMale_02",
}

--- Generates a visitable object for the AL_Talk ambient life marker.
---
--- @return table The visitable object, containing the marker itself, the position, and the look-at point.
function AL_Talk:GenerateVisitable()
	local pos = self:GetPos()
	local lookat = pos + Rotate(point(const.SlabSizeX, 0), self:GetAngle())
	
	return {self, pos, lookat}
end

DefineClass.AL_WallLean = {
	__parents = { "AmbientLifeMarker", "GroundAlignedObj", },
	__generated_by_class = "ClassDef",

	properties = {
		{ category = "Ambient Life", id = "VisitEnter", name = "Entering Visit", 
			editor = "combo", default = "civ_Wall_Start", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitIdle", name = "During Visit", 
			editor = "combo", default = "civ_Wall_Idle", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitExit", name = "Exit Visit", 
			editor = "combo", default = "civ_Wall_End", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "Teleport", name = "Teleport", 
			editor = "bool", default = false, },
		{ category = "Ambient Life", id = "GameStatesFilter", name = "States Required for Activation", 
			editor = "set", default = set( {Conflict = false} ), three_state = true, items = function (self) return GetGameStateFilter end, },
		{ category = "Ambient Life", id = "EditorMarkerVisitAnim", name = "Editor Marker Visit Anim", 
			editor = "combo", default = "editorMarkerAnim_Wall", items = function (self) return GetStates("Male") end, },
	},
	VisitPose = 16,
	Appearance = "Legion_Jose",
	VisitSupportCollectionVME = true,
}

--- Checks if the AL_WallLean marker can be visited by a unit.
---
--- @param unit table The unit that wants to visit the marker.
--- @param for_perpetual boolean Whether the visit is for a perpetual animation.
--- @param dont_check_dist boolean Whether to skip checking the distance to the nearest enemy.
--- @return boolean True if the marker can be visited, false otherwise.
function AL_WallLean:CanVisit(unit, for_perpetual, dont_check_dist)
	local enemy, dist = GetNearestEnemy(unit, "ignore awareness")
	if enemy and dist <= const.AmbientLife.ForbidWallLeanEnemyDist then
		return false
	end
	
	return AmbientLifeMarker.CanVisit(self, unit, for_perpetual, dont_check_dist)
end

--- Callback function called when the AL_WallLean marker is placed in the editor.
---
--- This function aligns the marker to the ground and calls the corresponding callback functions
--- from the parent classes AmbientLifeMarker and AlignedObj.
---
--- @param ... Any additional arguments passed to the callback function.
function AL_WallLean:EditorCallbackPlace(...)
	AlignedObj.EditorCallbackPlace(self, ...)
	AmbientLifeMarker.EditorCallbackPlace(self, ...)
end

--- Callback function called when the AL_WallLean marker is rotated in the editor.
---
--- This function calls the corresponding callback functions from the parent classes
--- AlignedObj and AmbientLifeMarker to handle the rotation of the marker.
---
--- @param ... Any additional arguments passed to the callback function.
function AL_WallLean:EditorCallbackRotate(...)
	AlignedObj.EditorCallbackRotate(self, ...)
	AmbientLifeMarker.EditorCallbackRotate(self, ...)
end

--- Callback function called when the AL_WallLean marker is scaled in the editor.
---
--- This function calls the corresponding callback functions from the parent classes
--- AlignedObj and AmbientLifeMarker to handle the scaling of the marker.
---
--- @param ... Any additional arguments passed to the callback function.
function AL_WallLean:EditorCallbackScale(...)
	AlignedObj.EditorCallbackScale(self, ...)
	AmbientLifeMarker.EditorCallbackScale(self, ...)
end

--- Callback function called when the AL_WallLean marker is moved in the editor.
---
--- This function calls the corresponding callback functions from the parent classes
--- AlignedObj and AmbientLifeMarker to handle the movement of the marker.
---
--- @param ... Any additional arguments passed to the callback function.
function AL_WallLean:EditorCallbackMove(...)
	AlignedObj.EditorCallbackMove(self, ...)
	AmbientLifeMarker.EditorCallbackMove(self, ...)
end

DefineClass.AL_WallLean_NoSnap = {
	__parents = { "AmbientLifeMarker", },
	__generated_by_class = "ClassDef",

	properties = {
		{ category = "Ambient Life", id = "VisitEnter", name = "Entering Visit", 
			editor = "combo", default = "civ_Wall_Start", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitIdle", name = "During Visit", 
			editor = "combo", default = "civ_Wall_Idle", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitExit", name = "Exit Visit", 
			editor = "combo", default = "civ_Wall_End", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "Teleport", name = "Teleport", 
			editor = "bool", default = false, },
		{ category = "Ambient Life", id = "GameStatesFilter", name = "States Required for Activation", 
			editor = "set", default = set( {Conflict = false} ), three_state = true, items = function (self) return GetGameStateFilter end, },
		{ category = "Ambient Life", id = "EditorMarkerVisitAnim", name = "Editor Marker Visit Anim", 
			editor = "combo", default = "editorMarkerAnim_Wall", items = function (self) return GetStates("Male") end, },
	},
	VisitPose = 16,
	Appearance = "Legion_Jose",
	VisitSupportCollectionVME = true,
}

--- Checks if the given unit can visit the AL_WallLean_NoSnap marker.
---
--- This function first checks if there is an enemy unit within a certain distance of the given unit. If an enemy is found within the forbidden distance, the function returns false, indicating that the unit cannot visit the marker.
---
--- If no enemy is found within the forbidden distance, the function calls the `CanVisit` function of the parent `AmbientLifeMarker` class to perform additional checks and determine if the unit can visit the marker.
---
--- @param unit The unit that is attempting to visit the marker.
--- @param for_perpetual Whether the visit is for a perpetual visit.
--- @param dont_check_dist Whether to skip the distance check.
--- @return true if the unit can visit the marker, false otherwise.
function AL_WallLean_NoSnap:CanVisit(unit, for_perpetual, dont_check_dist)
	local enemy, dist = GetNearestEnemy(unit, "ignore awareness")
	if enemy and dist <= const.AmbientLife.ForbidWallLeanEnemyDist then
		return false
	end
	
	return AmbientLifeMarker.CanVisit(self, unit, for_perpetual, dont_check_dist)
end

DefineClass.AL_WallLean_Prostitute = {
	__parents = { "AmbientLifeMarker", "GroundAlignedObj", },
	__generated_by_class = "ClassDef",

	properties = {
		{ category = "Ambient Life", id = "VisitEnter", name = "Entering Visit", 
			editor = "combo", default = "", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitIdle", name = "During Visit", 
			editor = "combo", default = "civ_Seduce_Wall", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitExit", name = "Exit Visit", 
			editor = "combo", default = "", items = function (self) return GetStates("Male") end, },
	},
	VisitPose = 3267,
	VisitVariation = true,
	Appearance = "VillagerFemale_01",
	VisitSupportCollectionVME = true,
}

--- Checks if the given unit can visit the AL_WallLean_Prostitute marker.
---
--- This function first checks if the given unit is a prostitute. If the unit is not a prostitute, the function returns false, indicating that the unit cannot visit the marker.
---
--- If the unit is a prostitute, the function then checks if there is an enemy unit within a certain distance of the given unit. If an enemy is found within the forbidden distance, the function returns false, indicating that the unit cannot visit the marker.
---
--- If no enemy is found within the forbidden distance, the function calls the `CanVisit` function of the parent `AmbientLifeMarker` class to perform additional checks and determine if the unit can visit the marker.
---
--- @param unit The unit that is attempting to visit the marker.
--- @param for_perpetual Whether the visit is for a perpetual visit.
--- @param dont_check_dist Whether to skip the distance check.
--- @return true if the unit can visit the marker, false otherwise.
function AL_WallLean_Prostitute:CanVisit(unit, for_perpetual, dont_check_dist)
	if not  unit:IsProstitute() then
		return false
	end
	
	local enemy, dist = GetNearestEnemy(unit, "ignore awareness")
	if enemy and dist <= const.AmbientLife.ForbidWallLeanEnemyDist then
		return false
	end
	
	return AmbientLifeMarker.CanVisit(self, unit, for_perpetual, dont_check_dist)
end

--- Callback function for when the AL_WallLean_Prostitute object is placed in the editor.
---
--- This function calls the `EditorCallbackPlace` functions of the parent `AlignedObj` and `AmbientLifeMarker` classes to handle the placement of the object in the editor.
---
--- @param ... Additional arguments passed to the parent `EditorCallbackPlace` functions.
function AL_WallLean_Prostitute:EditorCallbackPlace(...)
	AlignedObj.EditorCallbackPlace(self, ...)
	AmbientLifeMarker.EditorCallbackPlace(self, ...)
end

--- Callback function for when the AL_WallLean_Prostitute object is rotated in the editor.
---
--- This function calls the `EditorCallbackRotate` functions of the parent `AlignedObj` and `AmbientLifeMarker` classes to handle the rotation of the object in the editor.
---
--- @param ... Additional arguments passed to the parent `EditorCallbackRotate` functions.
function AL_WallLean_Prostitute:EditorCallbackRotate(...)
	AlignedObj.EditorCallbackRotate(self, ...)
	AmbientLifeMarker.EditorCallbackRotate(self, ...)
end

--- Callback function for when the AL_WallLean_Prostitute object is scaled in the editor.
---
--- This function calls the `EditorCallbackScale` functions of the parent `AlignedObj` and `AmbientLifeMarker` classes to handle the scaling of the object in the editor.
---
--- @param ... Additional arguments passed to the parent `EditorCallbackScale` functions.
function AL_WallLean_Prostitute:EditorCallbackScale(...)
	AlignedObj.EditorCallbackScale(self, ...)
	AmbientLifeMarker.EditorCallbackScale(self, ...)
end

--- Callback function for when the AL_WallLean_Prostitute object is moved in the editor.
---
--- This function calls the `EditorCallbackMove` functions of the parent `AlignedObj` and `AmbientLifeMarker` classes to handle the movement of the object in the editor.
---
--- @param ... Additional arguments passed to the parent `EditorCallbackMove` functions.
function AL_WallLean_Prostitute:EditorCallbackMove(...)
	AlignedObj.EditorCallbackMove(self, ...)
	AmbientLifeMarker.EditorCallbackMove(self, ...)
end

DefineClass.AL_WeaponAim = {
	__parents = { "AmbientLifeMarker", },
	__generated_by_class = "ClassDef",

	properties = {
		{ category = "Ambient Life", id = "VisitEnter", name = "Entering Visit", 
			editor = "combo", default = "", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitIdle", name = "During Visit", 
			editor = "combo", default = "ar_Standing_Aim", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitExit", name = "Exit Visit", 
			editor = "combo", default = "", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "Weapon", name = "Weapon", 
			editor = "combo", default = "DoubleBarrelShotgun", items = function (self) return InventoryItemWeaponsCombo end, },
	},
	VisitPose = 1912,
	VisitVariation = true,
}

--- Generates a visitable object for the AL_WeaponAim class.
---
--- This function returns a table containing the AL_WeaponAim object, its position, and a look-at position. The look-at position is calculated by rotating the point (const.SlabSizeX, 0) by the object's angle and adding it to the object's position.
---
--- @return table The visitable object, its position, and look-at position.
function AL_WeaponAim:GenerateVisitable()
	local pos = self:GetPos()
	local lookat = pos + Rotate(point(const.SlabSizeX, 0), self:GetAngle())
	
	return {self, pos, lookat}
end

DefineClass.AL_WeaponIdle = {
	__parents = { "AmbientLifeMarker", },
	__generated_by_class = "ClassDef",

	properties = {
		{ category = "Ambient Life", id = "VisitEnter", name = "Entering Visit", 
			editor = "combo", default = "", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitIdle", name = "During Visit", 
			editor = "combo", default = "ar_Standing_Idle", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "VisitExit", name = "Exit Visit", 
			editor = "combo", default = "", items = function (self) return GetStates("Male") end, },
		{ category = "Ambient Life", id = "Weapon", name = "Weapon", 
			editor = "combo", default = "DoubleBarrelShotgun", items = function (self) return InventoryItemWeaponsCombo end, },
	},
	VisitPose = 1912,
	VisitVariation = true,
}

--- Generates a visitable object for the AL_WeaponIdle class.
---
--- This function returns a table containing the AL_WeaponIdle object, its position, and a look-at position. The look-at position is calculated by rotating the point (const.SlabSizeX, 0) by the object's angle and adding it to the object's position.
---
--- @return table The visitable object, its position, and look-at position.
function AL_WeaponIdle:GenerateVisitable()
	local pos = self:GetPos()
	local lookat = pos + Rotate(point(const.SlabSizeX, 0), self:GetAngle())
	
	return {self, pos, lookat}
end

