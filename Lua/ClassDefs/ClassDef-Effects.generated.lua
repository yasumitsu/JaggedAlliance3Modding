-- ========== GENERATED BY ClassDef Editor (Ctrl-Alt-F3) DO NOT EDIT MANUALLY! ==========

DefineClass.ApplyGuiltyOrRighteous = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "effectType", name = "effectType", help = "Whether the effect is possive or negative (proud or guilty)", 
			editor = "combo", default = "positive", items = function (self) return { "positive", "negative" } end, },
	},
	EditorView = Untranslated("Apply guilty or righteous effect on unit"),
	Documentation = "Apply guilty or righteous effect on unit",
}

--- Applies the guilty or righteous effect on the specified object based on the effect type.
---
--- @param obj table The object to apply the effect to.
--- @param context table The context in which the effect is being applied.
function ApplyGuiltyOrRighteous:__exec(obj, context)
	ApplyGuiltyOrRighteousEffect(self.effectType)
end

---
--- Returns the UI text to display based on the effect type.
---
--- @param effect table The effect object.
--- @return string The UI text to display.
function ApplyGuiltyOrRighteous:GetUIText(effect)
	if  self.effectType == "positive" then
		return T(235589045798, "Some mercs may <em>approve</em> of this.")
	else
		return T(596690068964, "Some mercs may <em>regret</em> this.")
	end
end

---
--- Returns the UI text to display based on the effect type.
---
--- @param effect table The effect object.
--- @return string The UI text to display.
function ApplyGuiltyOrRighteous:GetEditorView()
	local helperText =  self.effectType == "positive" and "positive(righteous)" or "negative(guilty)"
	return Untranslated("Apply " .. helperText  .. " effect on unit" )
end

DefineClass.BanterSetUnitInteraction = {
	__parents = { "Effect", "UnitTarget", "BanterFunctionObjectBase", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Banters", name = "Banters", help = "List of banters to play.", 
			editor = "preset_id_list", default = {}, preset_class = "BanterDef", item_default = "", },
		{ id = "Enabled", name = "Enabled", help = "Whether the banter is enabled.", 
			editor = "bool", default = true, },
	},
	EditorView = Untranslated("Set banters to play when interacting with unit."),
	Documentation = "Set banters to play when interacting with unit.",
	EditorNestedObjCategory = "Interactions",
}

---
--- Checks if the `Banters` property is valid.
---
--- @return string|nil An error message if the `Banters` property is invalid, or `nil` if it is valid.
function BanterSetUnitInteraction:GetError()
	if not self.Banters then
		return "No banters"
	end
	
	for i,banter_id in ipairs(self.Banters) do
		if not Banters[banter_id] then
			return "Invalid banter ID " .. banter_id
		end
	end
end

---
--- Executes the BanterSetUnitInteraction effect.
---
--- This function is called when the BanterSetUnitInteraction effect is applied. It checks if the effect matches the target units, and if so, sets the `banters` property of each target unit to a copy of the `Banters` property of the effect, if the `Enabled` property is true.
---
--- @param obj table The object the effect is applied to.
--- @param context table The context in which the effect is applied.
---
function BanterSetUnitInteraction:__exec(obj, context)
	context = type(context) == "table" and context or {}
	local triggered = self:MatchMapUnits(obj, context)
	if not triggered or not context.target_units then return end
	for i,unit in ipairs(context.target_units) do
		unit.banters = self.Enabled and table.copy(self.Banters)
	end
end

DefineClass.BobbyRayConsumeStock = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "ItemConsumeProbability", help = "Probability of each item to get picked for consumption", 
			editor = "number", default = 13, 
			default = const.BobbyRay.FakePurchase_PickProbability, scale = "%", slider = true, min = 0, max = 100, modifiable = true, },
		{ id = "MinimumStockConsumption", help = "Minimum percentage of available stock consumed", 
			editor = "number", default = 25, 
			default = const.BobbyRay.FakePurchase_StockConsumedMin, scale = "%", slider = true, min = 0, max = 100, modifiable = true, },
		{ id = "MaximumStockConsumption", help = "Maximum percentage of available stock consumed (if only one unit is available, it is always consumed)", 
			editor = "number", default = 50, 
			default = const.BobbyRay.FakePurchase_StockConsumedMax, scale = "%", slider = true, min = 0, max = 100, modifiable = true, },
	},
	EditorNestedObjCategory = "Bobby Ray",
	EditorView = Untranslated("Consumes some of Bobby Ray's stock"),
	Documentation = "Consumes some of Bobby Ray's stock to simulate other buyers.\n\nEach item is evaluated independently.\nA roll with ItemConsumeProbability change determines whether an item will be purchased or not.\nIf chosen, a percentage of its stock is consumed (at least one unit is always consumed), between Min and Max StockConsumption values.",
}

---
--- Executes the BobbyRayConsumeStock effect.
---
--- This function is called when the BobbyRayConsumeStock effect is applied. It consumes a random amount of Bobby Ray's stock, based on the configured probabilities and consumption limits.
---
--- @param obj table The object the effect is applied to.
--- @param context table The context in which the effect is applied.
---
function BobbyRayConsumeStock:__exec(obj, context)
	BobbyRayStoreConsumeRandomStock(self.ItemConsumeProbability, self.MinimumStockConsumption, self.MaximumStockConsumption)
end

DefineClass.BobbyRayRestockShop = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "RestockModifier_Standard", help = "Modifier to the number of standard items chosen for restock per event (applied to the Restock_StandardPercentage variables defined in the const editor).\n\n100 causes no change.", 
			editor = "number", default = 100, scale = "%", slider = true, min = 10, max = 500, modifiable = true, },
		{ id = "RestockModifier_Used", help = "Modifier to the number of used items chosen for restock per event (applied to the Restock_UsedPercentage variables defined in the const editor).\n\n100 causes no change.", 
			editor = "number", default = 100, scale = "%", slider = true, min = 10, max = 500, modifiable = true, },
	},
	EditorNestedObjCategory = "Bobby Ray",
	EditorView = Untranslated("Restocks Bobby Ray's Shop"),
	Documentation = "Restocks Bobby Ray's Shop\n\nFrom the whole pool of items that can appear in the shop (with respect to tier), a percentage between Restock_PercentageMin and Restock_PercentageMax (see the const editor, with separate variables controlling standard and used items) is restocked.\n\nThe above values are further multiplied by this effect's RestockModifier. Values below 100 decrease the number of items picked for restocking, values above 100 increase it.\n\nItems already present in the shop get their stock recalculated (never decreased, but restocking may have no effect), otherwise a new entry is created.",
}

---
--- Restocks Bobby Ray's Shop.
---
--- This function is called when the BobbyRayRestockShop effect is applied. It restocks Bobby Ray's shop by modifying the number of standard and used items based on the configured restock modifiers.
---
--- @param obj table The object the effect is applied to.
--- @param context table The context in which the effect is applied.
---
function BobbyRayRestockShop:__exec(obj, context)
	BobbyRayStoreRestock(self.RestockModifier_Standard, self.RestockModifier_Used)
end

DefineClass.BobbyRaySetState = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "State", 
			editor = "combo", default = "Closed", items = function (self) return {"Closed", 1, 2, 3, 4, 5, 6, 7, 8} end, },
	},
	EditorNestedObjCategory = "Bobby Ray",
	EditorView = Untranslated("Sets shop tier availability"),
	Documentation = "Possible values are:\nClosed (default, 0)\nTier-i unlocked (i>=1)",
}

---
--- Sets the state of Bobby Ray's shop by updating the quest variable for the unlocked tier.
---
--- @param obj table The object the effect is applied to.
--- @param context table The context in which the effect is applied.
---
function BobbyRaySetState:__exec(obj, context)
	SetQuestVar(QuestGetState("BobbyRayQuest"), "UnlockedTier", self.State == "Closed" and 0 or self.State)
end

DefineClass.ChangeTiredness = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "delta", name = "Delta", 
			editor = "number", default = 0, },
	},
	RequiredObjClasses = {
	"Unit",
	"UnitData",
},
	EditorView = Untranslated("Changes a unit's Energy"),
	Documentation = "Changes a unit's Energy",
	EditorNestedObjCategory = "Units",
}

---
--- Changes a unit's Energy by the specified delta value.
---
--- @param obj table The unit object to change the Energy of.
--- @param context table The context in which the effect is applied.
---
function ChangeTiredness:__exec(obj, context)
	if IsKindOfClasses(obj, "Unit", "UnitData") and not obj:IsDead() then
		obj:ChangeTired(self.delta)
	end
end

DefineClass.CityGrantLoyalty = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "City", help = "Change loyalty of the specified city", 
			editor = "choice", default = false, items = function (self) return table.map(GetCurrentCampaignPreset().Cities, "Id") end, },
		{ id = "Amount", help = "Amount of loyalty to change with.", 
			editor = "number", default = 0, },
		{ id = "SpecialConversationMessage", name = "Special Conversation Message", help = "The message to display in the log when the effect is executed from a conversation phrase.", 
			editor = "text", default = false, translate = true, },
	},
	EditorView = Untranslated("Add <Amount> to city <u(City)> loyalty."),
	Documentation = "Grants a given value of loyalty to a given city. The loyalty can be negative.",
}

---
--- Checks if the `City` property is set for the `CityGrantLoyalty` effect.
---
--- @return string|nil The error message if the `City` property is missing, or `nil` if it is set.
---
function CityGrantLoyalty:GetError()
	if not self.City then
		return "Missing City"
	end
end

---
--- Executes the CityGrantLoyalty effect, modifying the loyalty of the specified city by the given amount.
---
--- @param obj table The object on which the effect is being executed (typically a QuestsDef object).
--- @param context table The context in which the effect is being executed.
---
function CityGrantLoyalty:__exec(obj, context)
	local msgPrefix = false
	if IsKindOf(obj, "QuestsDef") and QuestIsBoolVar(obj,"Completed",true) then
		msgPrefix = T{858740141061, "Mission <DisplayName> completed", DisplayName = obj.DisplayName}
	else 
		msgPrefix = self.SpecialConversationMessage or ""
	end
	
	CityModifyLoyalty(self.City, self.Amount, msgPrefix)
end

---
--- Gets the top rollover text for the CityGrantLoyalty effect.
---
--- @param negative boolean Whether the loyalty change is negative.
--- @param template string The template to use for the rollover text.
--- @param game table The game object.
--- @return string The formatted rollover text.
---
function CityGrantLoyalty:GetPhraseTopRolloverText(negative, template, game)
	local city = gv_Cities and gv_Cities[self.City]
	local city_name =city and city.DisplayName or Untranslated(self.City)
	
	if self.Amount>0 then
		return T{571842717111, "Gained <em><Amount> Loyalty</em> with <em><City></em>",Amount = self.Amount, City = city_name}
	elseif self.Amount<0 then
		return T{749649970601, "Lost <em><Amount> Loyalty</em> with <em><City></em>",Amount = -self.Amount, City = city_name}
	end
end

DefineClass.CompleteGuardpostObjective = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "GuardpostObjective", name = "GuardpostObjective", 
			editor = "preset_id", default = false, preset_class = "GuardpostObjective", },
	},
	EditorView = Untranslated("Complete guardpost objective <u(GuardpostObjective)>"),
	Documentation = "Complete a guardpost objective, weakening the guardpost.",
	EditorNestedObjCategory = "Sectors",
}

---
--- Completes the specified guardpost objective, weakening the guardpost.
---
--- @param obj table The object on which the effect is being executed (typically a QuestsDef object).
--- @param context table The context in which the effect is being executed.
---
function CompleteGuardpostObjective:__exec(obj, context)
	SetGuardpostObjectiveCompleted(self.GuardpostObjective)
end

DefineClass.ConversateWithUnit = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Group", name = "Group", help = "The group to affect. If left as default (empty) the interactable the effect is attached to will be affected.", 
			editor = "combo", default = "", items = function (self) return GridMarkerGroupsCombo() end, },
	},
	EditorView = Untranslated("Start a conversation with the unit of group"),
	Documentation = "Start a conversation with the unit of group",
	EditorNestedObjCategory = "Interactions",
}

--- Returns an error message if the Group property is not set.
---
--- @return string The error message.
function ConversateWithUnit:GetError()
	if not self.Group then
		return "No group"
	end
end

---
--- Executes the ConversateWithUnit effect, which starts a conversation with the unit of the specified group.
---
--- @param obj table The object on which the effect is being executed (typically a QuestsDef object).
--- @param context table The context in which the effect is being executed.
---
function ConversateWithUnit:__exec(obj, context)
	local interactable = false
	local allInGroup = Groups[self.Group]
	
	for i, obj in ipairs(allInGroup) do
		if IsKindOf(obj, "Interactable") then
			interactable = obj
			break
		end
	end
	
	if not interactable then return end
	
	local unitsOnMap = GetAllPlayerUnitsOnMap()
	local closestUnit = false
	local closestDistance = false
	for i, u in ipairs(unitsOnMap) do
		if not CanInteractWith_SyncHelper(u, interactable) then goto continue end
		local dist = IsValid(u) and u:GetDist(interactable)
		if not closestDistance or dist < closestDistance then
			closestDistance = dist
			closestUnit = u
		end
		
		::continue::
	end
	
	if closestUnit then
		local conversation = FindEnabledConversation(interactable)
		if conversation then
			OpenConversationDialog(closestUnit, conversation, false, "interaction", interactable)
		end
	end
end

DefineClass.CustomCodeEffect = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "custom_code", name = "Custom Code", help = "Runs this code.", 
			editor = "text", default = false, },
	},
	EditorView = Untranslated("Execute custom code"),
	Documentation = "Executes custom code",
}

--- Executes custom code defined in the `custom_code` property of the `CustomCodeEffect` class.
---
--- This function is called when the `CustomCodeEffect` is executed. It first checks if the `custom_code` property is set, and if so, it attempts to load and execute the custom code. If the custom code fails to load, it prints the error message.
---
--- @param obj table The object on which the effect is being executed (typically a QuestsDef object).
--- @param context table The context in which the effect is being executed.
function CustomCodeEffect:__exec(obj, context)
	if not self.custom_code then return end
	local custom_code_func, err = load(self.custom_code)
	if custom_code_func then
		-- Procall to ensure there isnt a yield (it cant be saved)
		procall(custom_code_func)
	else
		assert(custom_code_func)
		print(err)
	end
end

--- Returns the error message if the custom code fails to load.
---
--- This function is called to get the error message when the `custom_code` property of the `CustomCodeEffect` class fails to load. It attempts to load the custom code using `load()` and returns the error message if the load fails.
---
--- @return string|nil The error message if the custom code fails to load, or `nil` if the custom code loads successfully.
function CustomCodeEffect:GetError()
	if self.custom_code then
		local func, err = load(self.custom_code)
		if not func then
			return err
		end
	end
end

DefineClass.DisableInteractionMarkerEffect = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Group", name = "Group", help = "The group to affect. If left as default (empty) the interactable the effect is attached to will be affected.", 
			editor = "combo", default = "", items = function (self) return GridMarkerGroupsCombo() end, },
		{ id = "Negate", name = "Negate", help = "Enable interaction markers instead.", 
			editor = "bool", default = false, },
	},
	Documentation = "Disable interaction markers of a specific group.",
	EditorNestedObjCategory = "Interactable",
}

--- Executes the DisableInteractionMarkerEffect.
---
--- This function is called when the DisableInteractionMarkerEffect is executed. It first checks if the Group property is empty, and if so, it enables or disables the interaction marker of the attached interactable object based on the Negate property. If the Group property is not empty, it iterates through all interactable objects in the map and enables or disables the interaction markers of the objects that belong to the specified group based on the Negate property.
---
--- @param obj table The object on which the effect is being executed (typically a QuestsDef object).
--- @param context table The context in which the effect is being executed.
function DisableInteractionMarkerEffect:__exec(obj, context)
	local groupName = self.Group
	if groupName == "" then
		if context and context.interactable and IsKindOf(context.interactable, "Interactable") then
			context.interactable.enabled = self.Negate
		elseif IsKindOf(obj, "Interactable") then
			obj.enabled = self.Negate
		else
			assert(not "Non interactable object with DisableInteractionMarker effect and no group.")
		end
		return
	end
	
	MapForEach("map", "Interactable", function(m)
		if table.find(m.Groups, groupName) then
			m.enabled = self.Negate
		end
	end)
end

--- Returns the editor view text for the DisableInteractionMarkerEffect.
---
--- If the Group property is empty, the editor view text will indicate whether the effect is enabling or disabling the attached interaction marker.
---
--- If the Group property is not empty, the editor view text will indicate whether the effect is enabling or disabling the interaction markers of the specified group.
---
--- @return string The editor view text for the DisableInteractionMarkerEffect.
function DisableInteractionMarkerEffect:GetEditorView()
	if self.Group == "" then
		if self.Negate then
			return T(299761711576, "Enable attached interaction marker.")
		else
			return T(311484226676, "Disable attached interaction marker.")
		end
	end
	
	if self.Negate then
		return T{697268621451, "Enable interaction markers of group <u(Group)>", self}
	else
		return T{571476004863, "Disable interaction markers of group <u(Group)>", self}
	end
end

DefineClass.EndSectorWarningState = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	EditorView = Untranslated("End the current sector's Warning State"),
	Documentation = "End the Warning State for the current sector.",
	EditorNestedObjCategory = "Sector effects",
}

--- Ends the current sector's warning state.
---
--- This function is called to end the warning state for the current sector. It checks if the satellite view is active, and if not, calls the `EndWarningState()` function to end the warning state.
---
--- @param obj table The object that this effect is attached to.
--- @param context table The context in which this effect is being executed.
function EndSectorWarningState:__exec(obj, context)
	if gv_SatelliteView then return end
	
	EndWarningState()
end

DefineClass.ExecForEachUnitInSector = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Sector", help = "Sector id", 
			editor = "combo", default = false, items = function (self) return GetCampaignSectorsCombo() end, },
		{ id = "Effects", name = "Effects", help = "Effects to execute.", 
			editor = "nested_list", default = false, base_class = "Effect", },
	},
	Documentation = 'Executes effects for all units in all squads in the given sector. Target unit effects must be with TargetUnit = "current unit"',
	EditorView = Untranslated("For each unit from sector '<u(Sector)>' execute all nested effects."),
	EditorNestedObjCategory = "Units",
}

--- Executes all nested effects for each unit in the given sector.
---
--- This function is called to execute all nested effects for each unit in the given sector. It first checks if there are any effects to execute, and if so, it gets all the squads in the specified sector and iterates through each unit in those squads, executing the nested effects for each unit.
---
--- @param obj table The object that this effect is attached to.
--- @param context table The context in which this effect is being executed.
function ExecForEachUnitInSector:__exec(obj, context)
	local effects =  self.Effects
	if not effects or #effects == 0 then return true end
	if not context then context = {} end
	context.is_sector_unit = true
	context.target_units = {}
	
	local squads = GetSquadsInSector(self.Sector)
	for i, squad in ipairs(squads) do
		for j, unit_id in ipairs(squad.units) do
			local unit = gv_UnitData[unit_id]
			context.target_units[1] = unit
			for _, effect in ipairs(effects) do
				effect:__exec(unit, context)
			end
		end
	end
	context.is_sector_unit = false
end

DefineClass.Explosion = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "LocationGroup", name = "Location Group", help = "Object group defining the location of the effect.", 
			editor = "combo", default = false, items = function (self) return table.keys2(Groups) end, },
		{ id = "ExplosionType", help = "What kind of grenade/mine is the explosion caused by.", 
			editor = "combo", default = "Landmine", items = function (self) return GrenadesComboItems({"Landmine"}) end, },
		{ id = "Damage", help = "Damage to be done.", 
			editor = "number", default = 30, min = 0, max = 200, },
		{ id = "AreaOfEffect", name = "Area of Effect", help = "the blast range (radius) in number of tiles.", 
			editor = "number", default = 3, min = 0, max = 20, },
		{ id = "Noise", name = "Noise", help = "Range (in tiles) in which the explosion alerts unaware enemies.", 
			editor = "number", default = 20, template = true, min = 0, max = 100, modifiable = true, },
		{ id = "AppliedEffect", name = "Applied Effect", help = "What effect to be applied on the victim when the damage is dealt.", 
			editor = "preset_id", default = false, preset_class = "CharacterEffectCompositeDef", preset_group = "Default", },
		{ id = "aoeType", name = "AOE Type", help = "additional effect that happens after the explosion (optional)", 
			editor = "choice", default = "none", template = true, items = function (self) return {"none", "fire", "smoke", "teargas", "toxicgas"} end, },
	},
	EditorView = T(892386429862, --[[EffectDef Effects Explosion value]] "Create an explosion"),
	Documentation = "Create an explosion",
}

---
--- Checks if the Location Group property is set for the Explosion effect.
---
--- @return string|nil An error message if the Location Group is not set, or nil if it is set.
function Explosion:GetError()
	if not self.LocationGroup then
		return  "Set the Location Group"
	end
end

---
--- Executes the Explosion effect by creating an explosion at the specified location.
---
--- @param obj table The object on which the effect is being executed.
--- @param context table The context in which the effect is being executed.
---
function Explosion:__exec(obj, context)
	local objs = Groups and self.LocationGroup and Groups[self.LocationGroup] or empty_table
	if #objs <= 0 then
		return
	end
	
	local pos = AveragePoint(objs)
	local weapon = PlaceObject((self.ExplosionType == "Landmine") and "Landmine" or "Grenade")
	weapon.AreaOfEffect = self.AreaOfEffect
	weapon.BaseDamage = self.Damage
	weapon.Noise = self.Noise
	weapon.AppliedEffect = self.AppliedEffect
	weapon.aoeType = self.aoeType
	local proj = PlaceObject("FXGrenade")
	proj:SetPos(pos)
	proj.fx_actor_class = self.ExplosionType
	CreateGameTimeThread(function()
		ExplosionDamage(nil, weapon, pos, proj)
		DoneObject(proj)
		DoneObject(weapon)
	end)
end

DefineClass.FailGuardpostObjective = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "GuardpostObjective", name = "GuardpostObjective", 
			editor = "preset_id", default = false, preset_class = "GuardpostObjective", },
	},
	EditorView = Untranslated("Fail guardpost objective <u(GuardpostObjective)>"),
	Documentation = "Fail a guardpost objective",
	EditorNestedObjCategory = "Sectors",
}

---
--- Executes the FailGuardpostObjective effect by setting the specified guardpost objective as failed.
---
--- @param obj table The object on which the effect is being executed.
--- @param context table The context in which the effect is being executed.
---
function FailGuardpostObjective:__exec(obj, context)
	SetGuardpostObjectiveFailed(self.GuardpostObjective)
end

DefineClass.ForceResetAmbientLife = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	EditorView = Untranslated("Forces Reset of Ambient Life Behavior(Alt-Shift-A cheat)"),
	Documentation = "Does the same thing as the Alt + Shift + A which resets the Ambient life",
}

---
--- Forces a reset of the ambient life behavior.
---
--- This function sends the following messages:
--- - "AmbientLifeDespawn" to despawn all ambient life objects
--- - "WallVisibilityChanged" to update wall visibility
--- - Sets the global `g_AmbientLifeSpawn` flag to `true`
--- - Sends the "AmbientLifeSpawn" message to respawn ambient life objects
---
--- @param obj table The object on which the effect is being executed.
--- @param context table The context in which the effect is being executed.
---
function ForceResetAmbientLife:__exec(obj, context)
	Msg("AmbientLifeDespawn")
	Msg("WallVisibilityChanged")
	g_AmbientLifeSpawn = true
	Msg("AmbientLifeSpawn")
end

---
--- Waits for the "AmbientLifeSpawned" message to be received, then executes the ForceResetAmbientLife effect.
---
--- This function is used to reset the ambient life behavior, waiting for the ambient life objects to be respawned before continuing.
---
--- @param obj table The object on which the effect is being executed.
--- @param context table The context in which the effect is being executed.
---
function ForceResetAmbientLife:__waitexec(obj, context)
	self:__exec(obj, context)
	WaitMsg("AmbientLifeSpawned")
end

---
--- Skips the execution of the ForceResetAmbientLife effect and directly executes the __exec function.
---
--- This function is used to bypass the waiting for the "AmbientLifeSpawned" message before executing the effect.
---
--- @param obj table The object on which the effect is being executed.
--- @param context table The context in which the effect is being executed.
---
function ForceResetAmbientLife:__skip(obj, context)
	self:__exec(obj, context)
end

DefineClass.GoBerserk = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	RequiredObjClasses = {
	"Unit",
},
	EditorView = Untranslated("Go Berserk"),
	Documentation = "Go Berserk",
	EditorNestedObjCategory = "Units",
}

---
--- Executes the "Go Berserk" effect on a unit.
---
--- This function is called when the "Go Berserk" effect is applied to a unit. It checks if the unit is valid (not dead) and performs the necessary actions to make the unit go berserk.
---
--- @param obj table The unit on which the effect is being executed.
--- @param context table The context in which the effect is being executed.
---
function GoBerserk:__exec(obj, context)
	if IsKindOf(obj, "Unit") and not obj:IsDead() then
	
	end
end

DefineClass.GrantExperienceEffect = {
	__parents = { "UnitTarget", "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Amount", name = "Amount", help = "Choose one of the predefined amounts", 
			editor = "combo", default = "XPQuestReward_Small", items = function (self) return GetQuestRewardConstItems() end, },
		{ id = "logImportant", name = "Log as Important", help = "Whther to show the XP gain as important message in the combat log.", 
			editor = "bool", default = false, },
	},
	EditorView = T(785742586188, --[[EffectDef Effects GrantExperienceEffect value]] "Grant <u(Amount)> to unit <u(TargetUnit)>"),
	Documentation = "Grant experience to units. This is to be used when a map is loaded, for satellite view use GrantExperienceSector",
	EditorNestedObjCategory = "Units",
}

---
--- Executes the "Grant Experience" effect on a set of units.
---
--- This function is called when the "Grant Experience" effect is applied. It checks if the effect has a valid target and then rewards the specified amount of experience to the target units.
---
--- @param obj table The object on which the effect is being executed.
--- @param context table The context in which the effect is being executed. This should contain a "target_units" field with the units to receive the experience.
---
function GrantExperienceEffect:__exec(obj, context)
	if not context then context = {} end
	
	local units = self:MatchMapUnits(obj, context)
	if units and context.target_units then
		local amount = self.Amount
		if type(amount) == "string" then
			if const[amount] then
				amount = const[amount]
			else
				amount = tonumber(amount)
			end
		end
		RewardTeamExperience({ RewardExperience = amount }, { units = context.target_units }, self.logImportant)
	end
end

---
--- Checks if the given unit is valid for the "Grant Experience" effect.
---
--- This function is called to determine if a unit should receive the experience granted by the "Grant Experience" effect. It always returns true, as there are no additional checks performed.
---
--- @param unit table The unit to check.
--- @param obj table The object on which the effect is being executed.
--- @param context table The context in which the effect is being executed.
--- @return boolean true
---
function GrantExperienceEffect:UnitCheck(unit, obj, context)
	return true
end

DefineClass.GrantExperienceSector = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Sector", name = "Sector", help = "Sector", 
			editor = "combo", default = "current", items = function (self) return table.iappend({{text="current",value="current"}}, GetCampaignSectorsCombo()) end, },
		{ id = "Amount", name = "Amount", help = "Choose one of the predefined amounts", 
			editor = "combo", default = "XPQuestReward_Small", items = function (self) return GetQuestRewardConstItems() end, },
		{ id = "logImportant", name = "Log as Important", help = "Whther to show the XP gain as important message in the combat log.", 
			editor = "bool", default = false, },
	},
	EditorView = T(990833526031, --[[EffectDef Effects GrantExperienceSector value]] "Grant <u(Amount)> to all player units on sector <u(Sector)>"),
	Documentation = "Grant experience to all player mercs on the specified sector.",
	EditorNestedObjCategory = "Units",
}

---
--- Executes the "Grant Experience Sector" effect, granting experience to all player units on the specified sector.
---
--- @param obj table The object on which the effect is being executed.
--- @param context table The context in which the effect is being executed. This should contain a "target_units" field with the units to receive the experience.
---
function GrantExperienceSector:__exec(obj, context)
	local sector_id
	local getUnits = false
	if self.Sector == "current"  then
		sector_id = gv_CurrentSectorId
		getUnits = not gv_SatelliteView
	else
		sector_id = self.Sector
	end
	local units = GetPlayerSectorUnits(sector_id, getUnits)
	if units then
		local amount = self.Amount
		if type(amount) == "string" then
			if const[amount] then
				amount = const[amount]
			else
				amount = tonumber(amount)
			end
		end
		RewardTeamExperience({ RewardExperience = amount }, { units = units, sector = sector_id }, self.logImportant)
	end
end

---
--- Checks if the `Amount` property of the `GrantExperienceSector` effect is valid.
---
--- @return string|nil An error message if the `Amount` is invalid, or `nil` if it is valid.
---
function GrantExperienceSector:GetError()
	local amount = self.Amount
	if type(amount) == "string" and not const[amount] and not tonumber(amount) then
		return "Invalid amount " .. tostring(amount) .. " - should be a number or a const"
	end
end

---
--- Checks if the given unit is valid for the effect.
---
--- @param unit table The unit to check.
--- @param obj table The object on which the effect is being executed.
--- @param context table The context in which the effect is being executed.
--- @return boolean true if the unit is valid, false otherwise.
---
function GrantExperienceSector:UnitCheck(unit, obj, context)
	return true
end

---
--- Gets the top rollover text for the GrantExperienceSector effect.
---
--- @param negative boolean Whether the experience amount is negative.
--- @param template table The translation template to use.
--- @param game boolean Whether the game context is available.
--- @return string The top rollover text.
---
function GrantExperienceSector:GetPhraseTopRolloverText(negative, template, game)
	local sector_id
	local getUnits = false
	if self.Sector == "current"  then
		sector_id = gv_CurrentSectorId
		getUnits = not gv_SatelliteView
	else
		sector_id = self.Sector
	end
	local units = game and  GetPlayerSectorUnits(sector_id, getUnits) or T(111137020067, "[Mercs]")
	local names = game and  ConcatListWithAnd(table.map(units, function(o) return o.Nick; end)) or units
	local amount = self.Amount
		if type(amount) == "string" then
			if const[amount] then
				amount = const[amount]
			else
				amount = tonumber(amount)
			end
		end
	if amount>0 then
		return T{894599074999, "Gained XP: <unit> (<Amount>)",Amount = amount, unit =  names}
	elseif amount<0 then
		return T{955913519115, "Lost XP: <unit> (<Amount>)",Amount = amount, unit =  names}
	end
end

DefineClass.GroupAddStatusEffect = {
	__parents = { "Effect", "UnitTarget", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Status", name = "Status", 
			editor = "preset_id", default = false, preset_class = "CharacterEffectCompositeDef", },
	},
	EditorView = Untranslated("Add <u(Status)> effect to units in group <u(TargetUnit)>"),
	Documentation = "Add status effect to units in group",
	EditorNestedObjCategory = "Units",
}

---
--- Applies a status effect to all units in the specified group.
---
--- @param obj table The object that the effect is being applied to.
--- @param context table The context in which the effect is being applied.
---
function GroupAddStatusEffect:__exec(obj, context)
	context = type(context) == "table" and context or {}
	self:MatchMapUnits(obj, context)
	
	for _, unit in ipairs(context.target_units) do
		if IsKindOf(unit, "StatusEffectObject") then
			unit:AddStatusEffect(self.Status)
		end
	end
	
	if not next(context.target_units) then
		print("GroupAddStatusEffect couldn't find group", self.TargetUnit)
		return
	end
end

DefineClass.GroupAlert = {
	__parents = { "Effect", "UnitTarget", },
	__generated_by_class = "EffectDef",

	EditorView = Untranslated("Alert units from <u(TargetUnit)>"),
	Documentation = "Alert units from given group",
	EditorNestedObjCategory = "Units",
}

---
--- Applies an alert effect to all units in the specified group.
---
--- @param obj table The object that the effect is being applied to.
--- @param context table The context in which the effect is being applied.
---
function GroupAlert:__exec(obj, context)
	context = type(context) == "table" and context or {}
	self:MatchMapUnits(obj, context)
	local units = {}
	for _, unit in ipairs(context.target_units) do
		if IsKindOf(unit, "Unit") then
			units[#units + 1] = unit
		end
	end	
	
	if not next(units) then
		print("GroupAlert couldn't find group", self.TargetUnit)
		return
	end
	
	CreateGameTimeThread(function() 
		gv_CombatStartFromConversation = true
		TriggerUnitAlert("script", units, "aware")
	end, units)
end

DefineClass.GroupAssignToArea = {
	__parents = { "Effect", "UnitTarget", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Mode", name = "Assign Mode", 
			editor = "combo", default = "overwrite", items = function (self) return { "overwrite", "add", "clear" } end, },
		{ id = "IndividualAreas", 
			editor = "string_list", default = {}, 
			no_edit = function(self) return self.Mode == "clear" end, no_validate = true, item_default = "", items = function (self) return GridMarkerFightAreaCombo("") end, max_items = 64, },
	},
	EditorView = Untranslated("Assign units from <u(TargetUnit)> to tactical area(s)"),
	Documentation = "Assigns units from given group to tactical area(s)",
	EditorNestedObjCategory = "Units",
}

---
--- Assigns units from the specified group to tactical area(s).
---
--- @param obj table The object that the effect is being applied to.
--- @param context table The context in which the effect is being applied.
---
function GroupAssignToArea:__exec(obj, context)
	if not g_TacticalMap then return end
	context = type(context) == "table" and context or {}
	self:MatchMapUnits(obj, context)
	
	local reset = self.Mode == "overwrite"
	local area
	if self.Mode ~= "clear" and (#(self.IndividualAreas or empty_table) > 0) then
		area = self.IndividualAreas
	end
	
	for _, unit in ipairs(context.target_units) do
		if IsKindOf(unit, "Unit") then
			g_TacticalMap:AssignUnit(unit, area, reset)
		end
	end
end

---
--- Gets the editor view text for the GroupAssignToArea effect.
---
--- The editor view text depends on the Mode property and the contents of the IndividualAreas property.
--- If Mode is "clear" or IndividualAreas is empty, the editor view will indicate that the assignment is being cleared.
--- If Mode is "add", the editor view will indicate that areas are being added to the assignment.
--- Otherwise, the editor view will indicate that units are being assigned to the specified areas.
---
--- @param self table The GroupAssignToArea effect instance.
--- @return string The editor view text.
---
function GroupAssignToArea:GetEditorView()
	if self.Mode == "clear" or #(self.IndividualAreas or empty_table) == 0 then
		return Untranslated("Clear assignment for units from <u(TargetUnit)>")
	else
		local areas = ""
		for _, area in ipairs(self.IndividualAreas) do
			if #areas == 0 then
				areas = area
			else
				areas = areas .. ", " .. area
			end
		end
		if self.Mode == "add" then
			return Untranslated(string.format("Add areas to assignement for units from <u(TargetUnit)>: [%s]", areas))
		end
		return Untranslated(string.format("Assign units from <u(TargetUnit)> to areas [%s]", areas))
	end
	return self.EditorView
end

DefineClass.GroupChangeName = {
	__parents = { "Effect", "UnitTarget", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "ChangeName", name = "Change Name", help = "Name to be changed to", 
			editor = "text", default = false, translate = true, },
	},
	EditorView = Untranslated("Change the name for units from <u(TargetUnit)> to <u(ChangeName)>"),
	Documentation = "Change the name of units from given group",
	EditorNestedObjCategory = "Units",
}

---
--- Executes the GroupChangeName effect, changing the name of units in the target group.
---
--- @param obj table The GroupChangeName effect instance.
--- @param context table The execution context, containing the target units.
---
function GroupChangeName:__exec(obj, context)
	context = type(context) == "table" and context or {}
	self:MatchMapUnits(obj, context)
	
	for _, unit in ipairs(context.target_units) do
		if IsKindOf(unit, "Unit") then
			unit.Name = self.ChangeName
			ObjModified(unit)
		end
	end
	
	if not next(context.target_units) then
		print(self.id, " couldn't find any units of: ", self.TargetUnit)
		return
	end
end

---
--- Returns an error message if the Change Name property is not set.
---
--- @param self table The GroupChangeName effect instance.
--- @return string|nil The error message, or nil if no error.
---
function GroupChangeName:GetError()
	if not self.ChangeName then
		return "Set Change Name"
	end
end

DefineClass.GroupChangeTiredness = {
	__parents = { "Effect", "UnitTarget", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Mode", 
			editor = "choice", default = "Absolute", items = function (self) return { "Absolute", "Delta" } end, },
		{ id = "Level", 
			editor = "choice", default = 0, 
			no_edit = function(self) return self.Mode ~= "Absolute" end, items = function (self) return UnitTirednessComboItems end, },
		{ id = "Delta", 
			editor = "number", default = 1, 
			no_edit = function(self) return self.Mode == "Absolute" end, },
	},
	EditorView = Untranslated("Change Energy for units from <u(TargetUnit)>"),
	Documentation = "Change Energy for units from given group",
	EditorNestedObjCategory = "Units",
}

---
--- Changes the tiredness level of units in the target group.
---
--- @param obj table The effect object.
--- @param context table The execution context, containing the target units.
---
function GroupChangeTiredness:__exec(obj, context)
	context = type(context) == "table" and context or {}
	self:MatchMapUnits(obj, context)
	
	for _, unit in ipairs(context.target_units) do
		if IsKindOf(unit, "Unit") then
			if self.Mode == "Absolute" then
				unit:SetTired(self.Level)
			else
				unit:ChangeTired(self.Delta)
			end
		end
	end
	
	if not next(context.target_units) then
		print("GroupChangeTiredness couldn't find any units of: ", self.TargetUnit)
		return
	end
end

---
--- Checks if the GroupChangeTiredness effect has an error condition.
---
--- @return string|nil The error message if an error condition exists, or nil if no error.
---
function GroupChangeTiredness:GetError()
	if self.Mode == "Delta" and self.Delta == 0 then
		return "No effect"
	end
end

DefineClass.GroupRemoveStatusEffect = {
	__parents = { "Effect", "UnitTarget", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Status", name = "Status", 
			editor = "preset_id", default = false, preset_class = "CharacterEffectCompositeDef", },
	},
	EditorView = Untranslated("Remove <u(Status)> effect from units in group <u(TargetUnit)>"),
	Documentation = "Remove status effect from units in group",
	EditorNestedObjCategory = "Units",
}

---
--- Removes a status effect from units in the target group.
---
--- @param obj table The effect object.
--- @param context table The execution context, containing the target units.
---
function GroupRemoveStatusEffect:__exec(obj, context)
	context = type(context) == "table" and context or {}
	self:MatchMapUnits(obj, context)
	
	for _, o in ipairs(context.target_units) do
		if IsKindOf(o, "StatusEffectObject") then
			o:RemoveStatusEffect(self.Status)
		end
	end
	
	if not next(context.target_units) then
		print("GroupRemoveStatusEffect couldn't find any units of: ", self.TargetUnit)
		return
	end
end

DefineClass.GroupSetAITargetModifier = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Group", name = "Group", help = "Unit group that will receive the modifier", 
			editor = "combo", default = "false", items = function (self) return GetUnitGroups() end, },
		{ id = "Target", help = "Target unit group subject to the modifier", 
			editor = "combo", default = "false", items = function (self) return GetUnitGroups() end, },
		{ id = "Modifier", help = "Modifier value, 100% means no modification (reset to default)", 
			editor = "number", default = 100, scale = "%", },
	},
	EditorView = Untranslated("AI target modifier for <u(Group)> against <u(Target)> <Modifier>%"),
	Documentation = "Set AI Targeting modifier of a group of units against another group",
	EditorNestedObjCategory = "Units",
}

---
--- Sets the AI target modifier for a group of units against another group.
---
--- If the `Modifier` is 100%, the modifier is removed for the specified `Group` and `Target`.
--- Otherwise, the modifier is set in the `gv_AITargetModifiers` table, with the `Group` as the key
--- and the `Target` and `Modifier` as the value.
---
--- @param obj table The effect object.
--- @param context table The execution context, containing the target units.
---
function GroupSetAITargetModifier:__exec(obj, context)
	if self.Modifier == 100 then
		if gv_AITargetModifiers[self.Group] then
			gv_AITargetModifiers[self.Group][self.Target] = nil
			if next(gv_AITargetModifiers[self.Group]) == nil then
				gv_AITargetModifiers[self.Group] = nil
			end
		end	
	else
		gv_AITargetModifiers[self.Group] = gv_AITargetModifiers[self.Group] or {}
		gv_AITargetModifiers[self.Group][self.Target] = self.Modifier
	end
end

DefineClass.GroupSetArchetype = {
	__parents = { "Effect", "UnitTarget", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Archetype", 
			editor = "choice", default = "<default>", items = function (self) return table.keys2(Archetypes, true, "<default>") end, },
	},
	EditorView = Untranslated("Change archetype for units from <u(TargetUnit)>"),
	Documentation = "Change archetype for units from given group",
	EditorNestedObjCategory = "Units",
}

---
--- Changes the archetype for units from the given group.
---
--- If the `Archetype` is set to "<default>", the archetype is reset to the default value.
--- Otherwise, the archetype is set for each unit in the `context.target_units` table.
---
--- @param obj table The effect object.
--- @param context table The execution context, containing the target units.
---
function GroupSetArchetype:__exec(obj, context)
	context = type(context) == "table" and context or {}
	self:MatchMapUnits(obj, context)
	local units = {}
	local archetype = self.Archetype
	if archetype == "<default>" then
		archetype = nil
	end
	for _, unit in ipairs(context.target_units) do
		if IsKindOf(unit, "Unit") then
			unit.script_archetype = archetype
		end
	end
end

DefineClass.GroupSetBehaviorAdvanceTo = {
	__parents = { "Effect", "AnimParams", "UnitTarget", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "MarkerId", help = "Marker description: can specify an id.", 
			editor = "text", default = false, },
		{ id = "MarkerGroup", help = "Marker description: marker group.", 
			editor = "combo", default = "", items = function (self) return GetBehaviorGroups end, },
		{ id = "MarkerType", help = "Marker description: markers type.", 
			editor = "combo", default = "Position", items = function (self) return GetGridMarkerTypesCombo end, },
		{ id = "PropagateAnimParams", help = "AdvanceTo behavior passes the control to Roam behavior on finish and if this checked all the AnimParams here will be propagated to Roam", 
			editor = "bool", default = false, },
	},
	EditorView = Untranslated("<u(TargetUnit)> Advance(s) to the marker"),
	Documentation = "Set units behavior to Advance towar a map marker.",
	EditorNestedObjCategory = "Units",
}

---
--- Executes the GroupSetBehaviorAdvanceTo effect, which sets the behavior of the target units to advance towards a specified map marker.
---
--- The function first retrieves the relevant map markers based on the MarkerType, MarkerGroup, and MarkerId properties of the effect object. If no markers are found, a warning message is printed and the function returns.
---
--- If the game is not in combat mode, the function then matches the target units specified in the context, and sets the AdvanceTo command for each valid unit, passing the AnimParams and PropagateAnimParams properties as command parameters.
---
--- @param obj table The effect object.
--- @param context table The execution context, containing the target units.
---
function GroupSetBehaviorAdvanceTo:__exec(obj, context)
	local markers = MapGetMarkers(self.MarkerType, self.MarkerGroup, function(o)
		return o:IsMarkerEnabled() and ((self.MarkerId or "" == "") or o.ID == self.MarkerID)
	end)
	
	if #(markers or empty_table) == 0 then
		printf("SetBehaviorAdvanceTo didn't find any markers (type %s, group %s, id %s)", tostring(self.MarkerType), tostring(self.MarkerGroup), tostring(self.MarkerId))
		return
	end
	
	if g_Combat then return end
	
	context = type(context) == "table" and context or {}
	self:MatchMapUnits(obj, context)
	
	local params = self:GetAnimParams()
	params.PropagateAnimParams = self.PropagateAnimParams
	for _, o in ipairs(context.target_units) do
		if IsKindOf(o, "Unit") and not o:IsDead() then
			local marker = table.interaction_rand(markers, "GridMarker", o)
			o:SetCommandParams("AdvanceTo", params)
			o:SetCommand("AdvanceTo", marker:GetHandle())
		end
	end
end

DefineClass.GroupSetBehaviorExit = {
	__parents = { "Effect", "AnimParams", "UnitTarget", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "MarkerGroup", help = "Exit marker group.", 
			editor = "combo", default = "", 
			no_edit = function(self) return self.closest end, items = function (self) return GetBehaviorGroups end, },
		{ id = "closest", name = "Closest Available", 
			editor = "bool", default = false, },
		{ id = "delay", name = "Delay", 
			editor = "number", default = 0, scale = "sec", min = 0, },
	},
	EditorView = Untranslated("<u(TargetUnit)> exit the map via <u(MarkerGroup)> marker"),
	Documentation = "Units exit the map using a specified marker",
	EditorNestedObjCategory = "Units",
}

---
--- Executes the GroupSetBehaviorExit effect, which sets the behavior of the target units to "ExitMap" using a specified marker group.
---
--- @param obj table The effect object.
--- @param context table The execution context, containing the target units.
---
function GroupSetBehaviorExit:__exec(obj, context)
	context = type(context) == "table" and context or {}
	self:MatchMapUnits(obj, context)
	local units = context.target_units or empty_table
	for i = #units, 1, -1 do
		if not IsKindOf(units[i], "Unit") then
			table.remove(units, i)
		end
	end
	if #units == 0 then
		return
	end
	local marker_group = not self.closest and self.MarkerGroup or ""
	local markers = MapGetMarkers("Entrance", marker_group)
	if not markers or #markers == 0 then
		return
	end
	
	local marker
	if marker_group == "" then
		-- pick nearest
		local ucenter = AveragePoint2D(units)
		marker = ChooseClosestObject(markers, ucenter)
	else
		-- pick random
		marker = table.interaction_rand(markers, "GridMarker")
	end
	
	local start_time = self.delay + GameTime()
	if g_Combat then
		for _, unit in ipairs(units) do
			if not unit:IsDead() then
				unit:SetBehavior("ExitMap", { marker, start_time })
			end
		end
	else
		local params = self:GetAnimParams()
		for _, unit in ipairs(units) do
			if unit.command == "ExplosionFly" then
				unit:SetCommandParams("ExitMap", params)
				unit:SetBehavior("ExitMap", { marker, start_time })
			elseif not unit:IsDead() then
				unit:SetCommandParams("ExitMap", params)
				unit:SetCommand("ExitMap", marker, start_time)
			end
		end
	end
end

---
--- Sets the behavior of the target units to ExitMap at the specified marker group.
---
--- @param obj table The effect object.
--- @param context table The context for the effect execution.
---
function GroupSetBehaviorExit:GetEditorView()
	return Untranslated("Set behavior of <u(TargetUnit)> to ExitMap at <u(MarkerGroup)>")
end

DefineClass.GroupSetBehaviorIdle = {
	__parents = { "Effect", "AnimParams", "UnitTarget", },
	__generated_by_class = "EffectDef",

	EditorView = Untranslated("Set behavior of <u(TargetUnit)> to Idle"),
	Documentation = "Set units behavior to Idle",
	EditorNestedObjCategory = "Units",
}

---
--- Sets the behavior of the target units to Idle.
---
--- @param obj table The effect object.
--- @param context table The context for the effect execution.
---
function GroupSetBehaviorIdle:__exec(obj, context)
	context = type(context) == "table" and context or {}
	self:MatchMapUnits(obj, context)
	local params = self:GetAnimParams()
	for _, o in ipairs(context.target_units) do
		if IsKindOf(o, "Unit") and not o:IsDead() then
			o:SetBehavior()
			o:SetCommandParams("Idle", params)
			o:SetCommand("Idle")
		end
	end
end

DefineClass.GroupSetBehaviorPatrol = {
	__parents = { "Effect", "AnimParams", "UnitTarget", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "MarkerGroup", help = "Patrol markers group", 
			editor = "combo", default = "", items = function (self) return GetBehaviorGroups end, },
		{ id = "Repeat", name = "Repeat Route", help = "Repeat route?", 
			editor = "bool", default = false, },
		{ id = "Orient", name = "End Orient", help = "Use marker orientation on the end", 
			editor = "bool", default = true, },
	},
	EditorView = Untranslated("<u(TargetUnit)> patrol(s) between <u(MarkerGroup)> markers"),
	Documentation = "Set unit behavior to Patrol between markers",
	EditorNestedObjCategory = "Units",
}

---
--- Sets the behavior of the target units to Patrol between markers.
---
--- @param obj table The effect object.
--- @param context table The context for the effect execution.
---
function GroupSetBehaviorPatrol:__exec(obj, context)
	context = type(context) == "table" and context or {}
	self:MatchMapUnits(obj, context)
	local params = self:GetAnimParams()
	for _, o in ipairs(context.target_units) do
		if IsKindOf(o, "Unit") and not o:IsDead() then
			o:SetCommandParams("Patrol", params)
			
			local behaviorParams = {self.MarkerGroup, 1, self.Repeat, self.Orient}
			if g_Combat then
				o:SetBehavior("Patrol", behaviorParams)
			elseif o.being_interacted_with then
				o:QueueCommand("Patrol", unpack_params(behaviorParams))
			else
				o:SetCommand("Patrol", unpack_params(behaviorParams))
			end
		end
	end
end

DefineClass.GroupSetBehaviorRoam = {
	__parents = { "Effect", "AnimParams", "UnitTarget", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "MarkerId", help = "Marker description: can specify an id.", 
			editor = "text", default = false, },
		{ id = "MarkerGroup", help = "Marker description: marker group.", 
			editor = "combo", default = "", items = function (self) return GetBehaviorGroups end, },
		{ id = "MarkerType", help = "Marker description: markers type.", 
			editor = "combo", default = "Position", items = function (self) return GetGridMarkerTypesCombo end, },
		{ id = "Orient", name = "End Orient", help = "Use marker orientation on the end", 
			editor = "bool", default = true, },
	},
	EditorView = Untranslated("<u(TargetUnit)> roam(s) around marker"),
	Documentation = "Set units behavior to Roam around a map's marker.",
	EditorNestedObjCategory = "Units",
}

---
--- Sets the behavior of the target units to Roam around a map marker.
---
--- @param obj table The effect object.
--- @param context table The context for the effect execution.
---
function GroupSetBehaviorRoam:__exec(obj, context)
	context = type(context) == "table" and context or {}
	self:MatchMapUnits(obj, context)
	local markers = MapGetMarkers(self.MarkerType, self.MarkerGroup, function(o)
		return o:IsMarkerEnabled() and ((self.MarkerId or "" == "") or o.ID == self.MarkerID)
	end)
	
	if #(markers or empty_table) == 0 then
		printf("SetBehaviorRoam didn't find any markers (type %s, group %s, id %s)", tostring(self.MarkerType), tostring(self.MarkerGroup), tostring(self.MarkerId))
		return
	end
	
	local params = self:GetAnimParams()
	for _, o in ipairs(context.target_units) do
		if IsKindOf(o, "Unit") and not o:IsDead() then
			local marker = table.interaction_rand(markers, "GridMarker", o)
			o:SetCommandParams("Roam", params)
	
			if g_Combat then
				o:SetBehavior("Roam", { marker, self.Orient })
			elseif o.being_interacted_with then
				o:QueueCommand("Roam", marker, self.Orient)
			else
				o:SetCommand("Roam", marker, self.Orient)
			end
		end
	end
end

DefineClass.GroupSetImmortal = {
	__parents = { "Effect", "UnitTarget", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "setImmortal", name = "Set immortal to", 
			editor = "bool", default = false, },
	},
	EditorView = Untranslated("Set the immortal property of units from <u(TargetUnit)> to <select(setImmortal, 'false', 'true')>"),
	Documentation = "Set the immortal property of units from a given group.",
	EditorNestedObjCategory = "Units",
}

---
--- Sets the immortal property of units from a given group.
---
--- @param obj table The effect object.
--- @param context table The context for the effect execution.
---
function GroupSetImmortal:__exec(obj, context)
	context = type(context) == "table" and context or {}
	self:MatchMapUnits(obj, context)
	
	for _, unit in ipairs(context.target_units) do
		if IsKindOf(unit, "Unit") then
			unit.immortal = self.setImmortal
			ObjModified(unit)
		end
	end
	
	if not next(context.target_units) then
		print(self.id, " couldn't find any units of: ", self.TargetUnit)
		return
	end
end

DefineClass.GroupSetInfected = {
	__parents = { "Effect", "UnitTarget", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "setInfected", name = "Set infected to", 
			editor = "bool", default = false, },
	},
	EditorView = Untranslated("Set the infected property of units from <u(TargetUnit)> to <select(setInfected, 'false', 'true')>"),
	Documentation = "Set the infected property of units from a given group. (Some animations change based on this property)",
	EditorNestedObjCategory = "Units",
}

---
--- Sets the infected property of units from a given group.
---
--- @param obj table The effect object.
--- @param context table The context for the effect execution.
---
function GroupSetInfected:__exec(obj, context)
	context = type(context) == "table" and context or {}
	self:MatchMapUnits(obj, context)
	
	for _, unit in ipairs(context.target_units) do
		if IsKindOf(unit, "Unit") then
			unit.infected = self.setInfected
			ObjModified(unit)
		end
	end
	
	if not next(context.target_units) then
		print(self.id, " couldn't find any units of: ", self.TargetUnit)
		return
	end
end

DefineClass.GroupSetRoutine = {
	__parents = { "Effect", "AnimParams", "UnitTarget", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Routine", help = "Set units of group to particular routine, or the one from their spawner.", 
			editor = "combo", default = "spawner", items = function (self) local r = table.copy(UnitRoutines) r[#r+1] = "spawner" return r end, },
		{ id = "RoutineArea", help = "Area to play the routine in, or use the one from the spawner.", 
			editor = "combo", default = "spawner", items = function (self) local g = table.copy(GridMarkerGroupsCombo()) g[1+#g] = "spawner" return g end, },
		{ id = "PropagateAnimParams", help = "AdvanceTo behavior passes the control to Roam behavior on finish and if this checked all the AnimParams here will be propagated to Roam", 
			editor = "bool", default = false, },
	},
	EditorView = Untranslated("Set routine of <u(TargetUnit)> to <u(Routine)>"),
	Documentation = "Set routine of units",
	EditorNestedObjCategory = "Units",
}

---
--- Sets the routine of units from a given group.
---
--- @param obj table The effect object.
--- @param context table The context for the effect execution.
---
function GroupSetRoutine:__exec(obj, context)
	context = type(context) == "table" and context or {}
	self:MatchMapUnits(obj, context)
	local params = self:GetAnimParams()
	params.PropagateAnimParams = self.PropagateAnimParams
	for _, o in ipairs(context.target_units) do
		if IsKindOf(o, "Unit") then
			o.routine = self.Routine == "spawner" and o.routine_spawner.Routine or self.Routine
			o.routine_area = self.RoutineArea == "spawner" and "self" or self.RoutineArea
			o.behavior = false
			o:SetCommandParams("Idle", params)
			o:SetCommand("Idle")
		end
	end
end

DefineClass.GroupSetSide = {
	__parents = { "Effect", "UnitTarget", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Side", help = "The new side of group.", 
			editor = "choice", default = false, items = function (self) return Sides end, },
		{ id = "CreateSquad", help = "If set to false the units will not create a new squad. Keep in mind they will be ejected from their old squad so they will despawn on the next presence check.", 
			editor = "bool", default = true, },
	},
	EditorView = Untranslated("Change the side of <u(TargetUnit)> to <u(Side)>"),
	Documentation = "Change groups side",
	EditorNestedObjCategory = "Units",
}

---
--- Sets the side of a group of units.
---
--- @param obj table The effect object.
--- @param context table The context for the effect execution.
---
--- This function sets the side of a group of units. It can optionally create a new squad for the units if the `CreateSquad` property is set to `true`. If `CreateSquad` is `false`, the units will be ejected from their old squad, which may cause them to despawn on the next presence check.
---
--- If the `Side` property is set to `"neutral"`, a dirty hack is used to prevent the units from instantly despawning.
---
--- The function also sends a `"GroupChangeSide"` message with the target unit, the new side, and the list of target units.
---
--- Finally, it calls `CheckGameOver()` to check if the game is over after the side change.
function GroupSetSide:__exec(obj, context)
	context = type(context) == "table" and context or {}
	self:MatchMapUnits(obj, context)
	
	if not next(context.target_units) then
		print("GroupSetSide couldn't find group", self.TargetUnit)
		return
	end
	
	if self.CreateSquad then
		local squads = {}
		for _, o in ipairs(context.target_units) do
			if IsKindOf(o, "Unit") and o.Squad then
				table.insert_unique(squads, o.Squad)
				local memberArrayName = "members" .. o.Squad
				local memberArray = squads[memberArrayName]
				if not memberArray then
					memberArray = {}
					squads[memberArrayName] = memberArray
				end
				memberArray[#memberArray + 1] = o.session_id
			end
		end
		
		for i, s in ipairs(squads) do
			local squadObj = gv_Squads[s]
			local createNew = false
			if squadObj.Side ~= self.Side then -- If squad is not of this side already
				-- Check all units in the squad.
				local units = squadObj.units
				for _, u in ipairs(units) do
					-- If any of the units in the squad are not part of the group,
					-- they must remain on their old side in the old squad.
					local unit = g_Units[u]
					if not table.find(context.target_units, unit) then
						createNew = true
						break
					end
				end
			end
			
			if createNew then
				local unitsToChangeSide = squads["members" .. s]
				CreateNewSatelliteSquad({
					Side = self.Side,
					CurrentSector = squadObj.CurrentSector,
					Name = SquadName:GetNewSquadName(self.Side, unitsToChangeSide)
				}, unitsToChangeSide)
			else
				SetSatelliteSquadSide(s, self.Side)
			end
		end
	else
		for _, o in ipairs(context.target_units) do
			if IsKindOf(o, "Unit") then
				local ud = gv_UnitData[o.session_id]
				RemoveUnitFromSquad(ud, "script")
				
				-- Dirty hack to prevent instant despawn when setting side to neutral.
				if self.Side == "neutral" then
					o.IsMerc = function() return false end
				end
			end
		end
	end
	
	for _, o in ipairs(context.target_units) do
		if IsKindOf(o, "Unit") then
			o:SetSide(self.Side)
		end
	end
	Msg("GroupChangeSide", self.TargetUnit, self.Side, context.target_units)
	CheckGameOver()
end

---
--- Executes the GroupSetSide effect, which sets the side of a group of units.
--- This function is called after the effect has finished waiting, and performs the actual execution of the effect.
---
--- @param obj table The object that the effect is being executed on.
--- @param context table The context in which the effect is being executed.
---
function GroupSetSide:__waitexec(obj, context)
	self:__exec(obj, context)
end

---
--- Returns an error message if the `Side` property is not set.
---
--- @return string The error message, or `nil` if `Side` is set.
---
function GroupSetSide:GetError()
	if not self.Side then
		return "Set the new side!"
	end
end

DefineClass.GroupTeleport = {
	__parents = { "Effect", "AnimParams", "UnitTarget", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "MarkerGroup", help = "Marker group where the units should be teleported to.", 
			editor = "combo", default = "", items = function (self) return GetBehaviorGroups end, },
	},
	EditorView = Untranslated("<u(TargetUnit)> will be teleported to <u(MarkerGroup)> marker"),
	Documentation = "Units group teleports to a specified marker",
	EditorNestedObjCategory = "Units",
}

---
--- Executes the GroupTeleport effect, which teleports a group of units to a specified marker group.
---
--- @param obj table The object that the effect is being executed on.
--- @param context table The context in which the effect is being executed.
---
--- @return string An error message if the teleport could not be completed, or a success message.
---
function GroupTeleport:__exec(obj, context)
	context = type(context) == "table" and context or {}
	self:MatchMapUnits(obj, context)
	
	local units = context.target_units or empty_table
	for i = #units, 1, -1 do
		if not IsKindOf(units[i], "Unit") then
			table.remove(units, i)
		end
	end
	if #(units or empty_table) == 0 then
		return string.format("No units from group '%s' to teleport", self.TargetUnit)
	end
	local markers = MapGetMarkers(nil, self.MarkerGroup)
	if not markers or #markers == 0 then
		return string.format("No markets in '%s' to teleport group '%s' to", self.MarkerGroup, self.TargetUnit)
	end
	
	local unit_pos, units_left = {}
	for _, marker in ipairs(markers) do
		units_left = {}
		local dest = GetUnitsDestinations(units, marker)
		for idx, unit in ipairs(units) do
			if dest[idx] then
				table.insert(unit_pos, unit)
				unit_pos[unit] = point(point_unpack(dest[idx]))
			else
				table.insert(units_left, unit)
			end
		end
		if #units_left == 0 then break end
		units = units_left
	end
	if #units_left > 0 then
		for _, unit in ipairs(units_left) do
			StoreErrorSource(unit, string.format("No position found for group '%s' teleport to markers '%s'!", self.TargetUnit, self.MarkerGroup))
		end
	end
	
	for _, unit in ipairs(unit_pos) do
		NetSyncEvent("StartCombatAction", netUniqueId, "Teleport", unit, g_Combat and 0 or false, unit_pos[unit])
	end	
	
	return string.format("%d unit(s) from '%s' teleported to '%s'", #units, self.TargetUnit, self.MarkerGroup)
end

--- Returns a string that represents the editor view for the GroupTeleport effect.
---
--- @return string The editor view string for the GroupTeleport effect.
function GroupTeleport:GetEditorView()
	return Untranslated("Teleport <u(TargetUnit)> to <u(MarkerGroup)>")
end

DefineClass.Heal = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	RequiredObjClasses = {
	"Unit",
	"UnitData",
},
	EditorView = Untranslated("Restore unit's health"),
	Documentation = "Restores unit's health",
	EditorNestedObjCategory = "Units",
}

--- Executes the Heal effect on the provided object.
---
--- @param obj UnitData|Unit The object to heal.
--- @param context table The execution context.
function Heal:__exec(obj, context)
	if IsKindOf(obj, "UnitData") then
		HealUnitData(obj)
	else	
		obj:ReviveOnHealth()
	end
end

DefineClass.HealWounds = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	RequiredObjClasses = {
	"Unit",
},
	EditorView = Untranslated("Heal unit's wounds"),
	Documentation = "Heals unit's wounds",
	EditorNestedObjCategory = "Units",
}

--- Removes the "Wounded" status effect from the provided unit.
---
--- @param obj Unit The unit to remove the "Wounded" status effect from.
--- @param context table The execution context.
function HealWounds:__exec(obj, context)
	obj:RemoveStatusEffect("Wounded", "all")
end

DefineClass.HerbalMedicineEffect = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "berserkChance", name = "Berserk Chance", 
			editor = "number", default = 15, },
		{ id = "apChance", name = "AP Chance", 
			editor = "number", default = 15, },
	},
	RequiredObjClasses = {
	"Unit",
	"UnitData",
},
	EditorView = Untranslated("Grant AP or Go Berserk"),
	Documentation = "Grant AP or Go Berserk",
	EditorNestedObjCategory = "Units",
}

---
--- Executes the Herbal Medicine effect on the provided unit.
---
--- If the unit is not dead, it will have a chance to either gain additional action points or go berserk, based on the configured probabilities.
---
--- @param obj Unit The unit to apply the Herbal Medicine effect to.
--- @param context table The execution context.
function HerbalMedicineEffect:__exec(obj, context)
	if IsKindOf(obj, "Unit") and not obj:IsDead() then
		local berserkRoll = InteractionRand(100, "HerbalMedicine")
		local apRoll = InteractionRand(100, "HerbalMedicine")
		if berserkRoll < self.berserkChance then
			
		end
		if apRoll < self.apChance then
			
		end
	end
end

DefineClass.HideQuestBadge = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Show", help = "Show the badge instead. (if it was hidden with this effect)", 
			editor = "bool", default = false, },
		{ id = "Quest", name = "Quest", help = "Which quest to associate this badge with. If the effect is placed on a quest it will attempt to find it itself.", 
			editor = "preset_id", default = false, preset_class = "QuestsDef", },
		{ id = "BadgeIdx", name = "Badge Id", 
			editor = "number", default = 1, 
			sort_order = 9, min = 1, },
		{ id = "Preview", 
			editor = "text", default = false, dont_save = true, read_only = true, 
			sort_order = 10, },
		{ id = "LogLine", name = "Log Line", help = "Change the state of that line.", 
			editor = "choice", default = false, items = function (self) return GetQuestNoteLinesCombo(self.Quest) end, },
	},
	Documentation = "Hide a quest badge",
	EditorNestedObjCategory = "Units",
}

---
--- Executes the HideQuestBadge effect on the provided object.
---
--- If the object is a QuestsDef, it will attempt to hide or show a quest badge based on the configured properties.
--- The badge to be hidden/shown is identified by the Quest, LogLine, and BadgeIdx properties.
---
--- @param obj Unit|QuestsDef The object to apply the HideQuestBadge effect to.
--- @param context table The execution context.
---
function HideQuestBadge:__exec(obj, context)
	local questState = (self.Quest and gv_Quests[self.Quest]) or (IsKindOf(obj, "QuestsDef") and obj) or false
	assert(questState)
	if not questState then return end
	
	local magicParam = badgeHideIdentifierNote
	local preset, index = self:GetLinePreset()
	assert(preset) -- Missing quest probably
	if not preset then return end
	magicParam = magicParam .. tostring(index) .. "@" .. tostring(self.BadgeIdx)
	
	if self.Show then
		questState[magicParam] = nil
	else
		questState[magicParam] = true
	end
	UpdateQuestBadges(questState)
	if g_SatelliteUI then
		local badge = preset.Badges[self.BadgeIdx]
		if badge and badge.Sector then
			g_SatelliteUI:UpdateSectorVisuals(badge.Sector)
		end
	end
end

---
--- Checks for errors in the HideQuestBadge effect configuration.
---
--- This function checks the following conditions:
--- - The `Quest` property is specified and the quest exists.
--- - The `LogLine` property is specified.
--- - The `LogLine` property refers to a valid line that places badges.
--- - The `BadgeIdx` property refers to a valid badge index within the line.
---
--- @return string|nil The error message if any of the conditions are not met, or `nil` if the configuration is valid.
---
function HideQuestBadge:GetError()
	if not self.Quest or self.Quest=="" then
		return "Specify the quest!"
	end
	if not Quests[self.Quest] then
		return "Missing quest!"
	end
	if not self.LogLine then
		return "Specify the line!"
	end
	local preset = self:GetLinePreset()
	if not preset then
		return "Invalid line!"
	end
	if not preset.Badges or #preset.Badges == 0 then
		return "This line doesn't place badges."
	end
	if self.BadgeIdx > #preset.Badges then
		return "Badge id out of range"
	end
end

---
--- Gets the preset for the log line specified in the HideQuestBadge effect.
---
--- @param self HideQuestBadge The HideQuestBadge effect instance.
--- @return table|nil The preset for the log line, or `nil` if the quest or log line is not found.
---
function HideQuestBadge:GetLinePreset()
	local line = self.LogLine
	local quest = Quests[self.Quest]
	
	if not quest or not line then return end
	local notePreset = table.find_value(quest.NoteDefs, "Idx", line)
	if not notePreset then return end
	return notePreset, line
end

---
--- Gets the editor view for the HideQuestBadge effect.
---
--- The editor view displays a preview of the effect, including the quest name, log line text, and the badge index that will be hidden or shown.
---
--- @param self HideQuestBadge The HideQuestBadge effect instance.
--- @return string The editor view text.
---
function HideQuestBadge:GetEditorView()
	local actionWord = self.Show and "Show " or "Hide "
	actionWord = actionWord .. self.BadgeIdx .. " "
	
	--Hide quest badge placed by <LogLine>
	if self.LogLine then
		local linePreset = self:GetLinePreset()
		if not linePreset then
			return Untranslated("Hide Badge: Missing quest!")
		end
		local text = linePreset and linePreset.Text or "log line not found"
		if linePreset.Badges then
			local badge = linePreset.Badges[self.BadgeIdx]
			self.Preview = "Badge on " .. (badge.BadgeUnit or "") .. " in " .. (badge.Sector or "")
			return Untranslated(actionWord .. "badge placed by <u(Quest)>: ").. Untranslated(text)
		else
			self.Preview = "Invalid badge"
			return Untranslated("Invalid badge")
		end
	else
		self.Preview = ""
		return Untranslated(actionWord .. "badge placed by <u(Quest)>: invalid log line specified")
	end
end

DefineClass.InteractingMercReduceItemCondition = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "ItemId", 
			editor = "combo", default = false, items = function (self) return ClassDescendantsCombo("InventoryItem") end, },
		{ id = "Equipped", 
			editor = "bool", default = false, },
		{ id = "ReduceAmount", 
			editor = "number", default = 1, min = 1, },
	},
	Documentation = "Reduce the condition of an interaction merc's item",
	EditorView = Untranslated("Reduce the condition of interaction merc's <u(ItemId)> by <ReduceAmount>"),
}

---
--- Reduces the condition of an item carried by the interacting merc.
---
--- @param obj table The object instance.
--- @param context table The execution context.
---
function InteractingMercReduceItemCondition:__exec(obj, context)
	local unit = context and context.target_units
	unit = unit and unit[1]
	if not unit then return end
	
	local item = false
	if self.Equipped then
		item = unit:GetItemInSlot("Handheld A", self.ItemId) or
					unit:GetItemInSlot("Handheld B", self.ItemId)
	else
		item = unit:GetItemInSlot("Inventory", self.ItemId)
	end
	if not item then return end
	unit:ItemModifyCondition(item, -self.ReduceAmount)
	CombatLog("short", T{597332256786, "<DisplayName> condition decreased by <dmg>.", DisplayName = item.DisplayName, dmg = self.ReduceAmount})
end

---
--- Checks if the `ItemId` property is set. If not, returns an error message.
---
--- @param self table The `InteractingMercReduceItemCondition` instance.
--- @return string|nil The error message if `ItemId` is not set, otherwise `nil`.
---
function InteractingMercReduceItemCondition:GetError()
	if not self.ItemId then
		return "Set Item!"
	end
end

DefineClass.KillTimer = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Name", name = "Name", help = "Name of the timer.", 
			editor = "text", default = false, },
		{ id = "StopTCE", name = "Stop TCE", help = "Wether to execute the effects after the timer or not.", 
			editor = "bool", default = false, },
	},
	EditorView = Untranslated("Kill timer <Name>"),
	Documentation = "Kills the visual UI timer displayed in the upper center of the screen",
	EditorNestedObjCategory = "UI & Log",
}

---
--- Executes the `KillTimer` effect, which stops the visual UI timer displayed in the upper center of the screen.
---
--- @param quest table The quest object.
--- @param context table The execution context.
--- @param TCE table The TCE (Tactical Combat Engine) object.
---
function KillTimer:__exec(quest, context, TCE)
	local data = TimerGetData(self.Name)
	if data then
		data.time = 0
		data.StopTCE = self.StopTCE
		Msg("TimerFinished", data.id)
	end
end

---
--- Checks if the `Name` property is set. If not, returns an error message. This function is skipped if the object is part of a `TestHarness`.
---
--- @param self table The `KillTimer` instance.
--- @return string|nil The error message if `Name` is not set, otherwise `nil`.
---
function KillTimer:GetError()
	if not self.Name then
		return "KillTimer needs a name!"
	end
	if GetParentTableOfKindNoCheck(self, "TestHarness") then
		return
	end
end

DefineClass.LightsSetState = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "MarkerId", help = "Marker description: can specify an id.", 
			editor = "text", default = false, },
		{ id = "MarkerGroup", help = "Marker description: marker group.", 
			editor = "combo", default = "", items = function (self) return LightsMarkerGroups end, },
		{ id = "MarkerType", help = "Marker description: markers type.", 
			editor = "combo", default = "Position", items = function (self) return GetGridMarkerTypesCombo end, },
		{ id = "TurnOn", 
			editor = "bool", default = true, },
		{ id = "EssentialLights", 
			editor = "bool", default = true, },
		{ id = "OptionalLights", 
			editor = "bool", default = true, },
		{ id = "AttachedLights", 
			editor = "bool", default = true, },
	},
	Documentation = "Turns ON/OFF Lights inside marker's area",
	EditorNestedObjCategory = "Interactions",
}

---
--- Returns a string describing the editor view for the LightsSetState effect.
---
--- @return string The editor view description.
---
function LightsSetState:GetEditorView()
	return string.format("Turns Lights %s in %s marker(s) area(s)", self.TurnOn and "ON" or "OFF", self.MarkerGroup)
end

---
--- Executes the LightsSetState effect by turning on or off lights within the specified marker areas.
---
--- @param obj table The object instance of the LightsSetState effect.
--- @param context table The context in which the effect is being executed.
---
function LightsSetState:__exec(obj, context)
	local markers = MapGetLightsMarkers(self.MarkerType, self.MarkerGroup, function(o)
		return o:IsMarkerEnabled() and ((self.MarkerId or "" == "") or o.ID == self.MarkerID)
	end)
	
	if #(markers or empty_table) == 0 then
		printf("%s didn't find any markers (type %s, group %s, id %s)", self.class, tostring(self.MarkerType), tostring(self.MarkerGroup), tostring(self.MarkerId))
		return
	end
	
	local lights = GetLights(function(light)
		local detail = light:GetDetailClass()
		if not self.EssentialLights and detail == "Essential" then
			return false
		end
		if not self.OptionalLights and detail == "Optional" then
			return false
		end
		if not self.AttachedLights and light:GetParent() then
			return false
		end
		
		return true
	end)
	
	for _, marker in ipairs(markers) do
		marker.lights_off = not self.TurnOn
		for _, light in ipairs(lights) do	
			if marker:IsInsideArea2D(light) then
				if marker.lights_off then
					marker:TurnLightOff(light)
				else
					marker:TurnLightOn(light)
				end
			end
		end
	end
	
	Msg("LightsStateUpdated")
end

DefineClass.LockpickableSetState = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Group", name = "Group", help = "The group in which the lockpick resides.", 
			editor = "combo", default = false, items = function (self) return GridMarkerGroupsCombo() end, },
		{ id = "State", help = "The state to set the locking in.", 
			editor = "choice", default = false, items = function (self) return { "unlocked", "locked", "change-difficulty" } end, },
		{ id = "NewDifficulty", name = "New Difficulty", help = 'The difficulty to change to if the state is "change-difficulty".', 
			editor = "choice", default = "None", items = function (self) return const.DifficultyPresetsNew end, },
	},
	EditorView = Untranslated("Change the state of lockpickables in <u(Group)> to <u(State)>"),
	Documentation = "Change lockpickable (containers, doors) state.",
}

---
--- Sets the state of lockpickable objects (containers, doors) in the specified group.
---
--- @param obj table The object that the effect is being applied to.
--- @param context table The context in which the effect is being executed.
function LockpickableSetState:__exec(obj, context)
	for _, o in ipairs(Groups[self.Group]) do
		if o:IsKindOf("Lockpickable") then
			if self.State == "change-difficulty" then
				o.lockpickDifficulty = self.NewDifficulty
			else
				o:SetLockpickState(self.State == "unlocked" and "closed" or self.State)
			end
		end
	end
end

---
--- Checks if the required properties for the LockpickableSetState effect are set.
---
--- @return string|nil The error message if any required properties are missing, or nil if all required properties are set.
function LockpickableSetState:GetError()
	if not self.State then
		return "Set the new state!"
	end
	if not self.Group then
		return  "Set the group"
	end
end

DefineClass.LogMessageAdd = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "message", name = "Message", help = "The message to display.", 
			editor = "text", default = false, translate = true, },
	},
	EditorView = Untranslated("Log:<message>"),
	Documentation = "Add a short message in game log",
	EditorNestedObjCategory = "UI & Log",
}

---
--- Adds a short message to the game log.
---
--- @param obj table The object that the effect is being applied to.
--- @param context table The context in which the effect is being executed.
function LogMessageAdd:__exec(obj, context)
	CombatLog("important", self.message)
end

---
--- Checks if the required properties for the LogMessageAdd effect are set.
---
--- @return string|nil The error message if the message property is missing or empty, or nil if the message property is set.
function LogMessageAdd:GetError()
	if not self.message or self.message == "" then
		return "Add a message"
	end
end

DefineClass.ModifySatelliteAggro = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Halt", help = "Stop passive aggro increase", 
			editor = "bool", default = false, },
		{ id = "AggroAmount", 
			editor = "number", default = 0, },
		{ id = "HaltDays", 
			editor = "number", default = false, },
		{ id = "AmountIsPercent", 
			editor = "bool", default = true, },
	},
	Documentation = "Modify Satellite aggro",
}

---
--- Generates a description of the effect of the ModifySatelliteAggro effect based on its properties.
---
--- @return string The description of the effect.
function ModifySatelliteAggro:GetEditorView()
	if self.Halt then
		if self.HaltDays then
			return Untranslated("Halt satellite aggro for " .. self.HaltDays .. " days.")
		end
		return Untranslated("Halt satellite aggro")
	elseif self.AggroAmount == 0 and not self.Halt then
		return Untranslated("Unhalt satellite aggro")
	elseif self.AmountIsPercent then
		return Untranslated("Add " .. self.AggroAmount / 100 .. "% satellite aggro")
	else
		return Untranslated("Add " .. self.AggroAmount .. " satellite aggro")
	end
end

---
--- Executes the ModifySatelliteAggro effect.
---
--- If the Halt property is true, it sets the global variable gv_SatelliteAttacksHalted to true and resets the gv_SatelliteAggro and gv_SatelliteAttacksHaltedFor variables.
---
--- If the Halt property is false, it calls the ModifySatelliteAggression function with the AggroAmount and AmountIsPercent properties.
---
--- @param obj table The object the effect is being applied to.
--- @param context table The context in which the effect is being executed.
---
function ModifySatelliteAggro:__exec(obj, context)
	gv_SatelliteAttacksHalted = self.Halt
	
	-- When halting reset.
	if gv_SatelliteAttacksHalted then
		gv_SatelliteAggro = 0
		gv_SatelliteAttacksHaltedFor = self.HaltDays
		return
	end
	
	ModifySatelliteAggression(self.AggroAmount, self.AmountIsPercent)
end

---
--- Checks if the AggroAmount property is set. If not, returns an error message.
---
--- @return string The error message if AggroAmount is not set.
function ModifySatelliteAggro:GetError()
	if not self.AggroAmount then
		return "No amount specified"
	end
end

DefineClass.ModifyTrapSpawnersEffect = {
	__parents = { "Effect", "TrapSpawnProperties", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Group", name = "Spawner Group", help = "The spawner group to affect.", 
			editor = "combo", default = "", items = function (self) return GridMarkerGroupsCombo() end, },
		{ category = "Spawner", id = "SpawnActive", name = "Override Spawner Status", help = "Override whether the spawner is active. If disabled any spawned traps will be despawned.", 
			editor = "combo", default = "don't change", items = function (self) return {"don't change", "enable", "disable"} end, },
	},
	EditorView = Untranslated("Change trap spawners of group <u(Group)>"),
	Documentation = "Change the properties of trap spawners in a specific group.",
	EditorNestedObjCategory = "Traps",
}

---
--- Executes the ModifyTrapSpawnersEffect.
---
--- This function applies the properties defined in the ModifyTrapSpawnersEffect to the trap spawners in the specified group. If the SpawnActive property is set, it will override the active state of the trap spawners.
---
--- @param obj table The object the effect is being applied to.
--- @param context table The context in which the effect is being executed.
---
function ModifyTrapSpawnersEffect:__exec(obj, context)
	local props = self:GetPropertyList()
	for i, s in ipairs(Groups[self.Group]) do
		if s:IsKindOf("TrapSpawnMarker") then
			s:ApplyPropertyList(props)
		end
	end
	if self.SpawnActive ~= "dont change" then
		for i, s in ipairs(Groups[self.Group]) do
			if s:IsKindOf("TrapSpawnMarker") then
				s:SetActive(self.SpawnActive == "enable")
			end
		end
	end
end

DefineClass.MusicSetPlaylist = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Playlist", name = "Playlist", 
			editor = "combo", default = false, items = function (self) return PresetsCombo("RadioStationPreset", "Default") end, },
	},
	EditorView = Untranslated("Changes the current playlist"),
	Documentation = "Changes the current playlist",
}

---
--- Plays the specified radio station playlist.
---
--- @param obj table The object the effect is being applied to.
--- @param context table The context in which the effect is being executed.
---
function MusicSetPlaylist:__exec(obj, context)
	StartRadioStation(self.Playlist)
end

DefineClass.MusicSetSectorPlaylist = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "SectorID", help = "Sector id.", 
			editor = "combo", default = false, items = function (self) return GetCampaignSectorsCombo() end, },
		{ id = "MusicExploration", name = "Exploration Music", 
			editor = "combo", default = false, items = function (self) return PresetsCombo("RadioStationPreset", "Default") end, },
		{ id = "MusicConflict", name = "Conflict Music", 
			editor = "combo", default = false, items = function (self) return PresetsCombo("RadioStationPreset", "Default") end, },
		{ id = "MusicCombat", name = "Combat Music", 
			editor = "combo", default = false, items = function (self) return PresetsCombo("RadioStationPreset", "Default") end, },
	},
	EditorView = Untranslated("Changes the playlists of a sector"),
	Documentation = "Changes the playlists of a sector",
}

---
--- Sets the music playlists for a specific sector.
---
--- @param obj table The object the effect is being applied to.
--- @param context table The context in which the effect is being executed.
---
function MusicSetSectorPlaylist:__exec(obj, context)
	if GetSectorMusicOverride("MusicExploration") ~= self.MusicExploration then
		SetSectorMusicOverride(self.SectorID, "MusicExploration", self.MusicExploration)
	end
	if GetSectorMusicOverride("MusicConflict") ~= self.MusicConflict then
		SetSectorMusicOverride(self.SectorID, "MusicConflict", self.MusicConflict)
	end
	if GetSectorMusicOverride("MusicCombat") ~= self.MusicCombat then
		SetSectorMusicOverride(self.SectorID, "MusicCombat", self.MusicCombat)
	end
	ResetSectorStation()
end

DefineClass.MusicSetTrack = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Playlist", name = "Playlist", 
			editor = "combo", default = false, items = function (self) return PresetsCombo("RadioStationPreset", "Default") end, },
		{ id = "Track", name = "Track", 
			editor = "combo", default = false, items = function (self) return RadioPlaylistCombo(self.Playlist) end, },
	},
	EditorView = Untranslated("Plays a track and then continues with the current playlist(radio station)"),
	Documentation = "Plays a track and then continues with the current playlist(radio station)",
}

---
--- Plays a track from the specified playlist and then continues with the current playlist (radio station).
---
--- @param obj table The object the effect is being applied to.
--- @param context table The context in which the effect is being executed.
---
function MusicSetTrack:__exec(obj, context)
	local _, playlist = RadioPlaylistCombo(self.Playlist)
	local track = table.find_value(playlist, "path", self.Track)
	MusicPlayTrack(track)
end

DefineClass.NeutralNPCDontMove = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "TargetUnit", name = "NPC Name", help = "The name of the NPC to associate.", 
			editor = "combo", default = false, items = function (self) return GetUnitGroups() end, },
	},
	EditorView = Untranslated("Prevent neutral unit from moving in combat."),
	Documentation = "Prevents neutral unit from moving in combat.",
	EditorNestedObjCategory = "",
	EditorNestedObjCategory = "Units",
}

---
--- Prevents neutral units from moving in combat.
---
--- @param obj table The object the effect is being applied to.
--- @param context table The context in which the effect is being executed.
---
function NeutralNPCDontMove:__exec(obj, context)
	local units = Groups[self.TargetUnit] or empty_table
	
	for _, unit in ipairs(units) do
		unit.neutral_ai_dont_move = true
	end
end

---
--- Returns an error message if the `TargetUnit` property is not set.
---
--- @return string|nil The error message, or `nil` if the `TargetUnit` property is set.
---
function NeutralNPCDontMove:GetError()
	if not self.TargetUnit then
		return  "Specify Target Unit"
	end
end

DefineClass.NpcUnitGiveItem = {
	__parents = { "Effect", "LootTableFunctionObjectBase", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "ItemId", name = "Item", 
			editor = "preset_id", default = false, preset_class = "InventoryItemCompositeDef", },
		{ id = "LootTableId", name = "LootTable", 
			editor = "preset_id", default = false, preset_class = "LootDef", },
		{ id = "DontDrop", 
			editor = "bool", default = false, },
		{ id = "TargetUnit", name = "NPC Name", help = "The name of the NPC to associate.", 
			editor = "combo", default = false, items = function (self) return GetUnitGroups() end, },
	},
	EditorView = Untranslated("Give <u(ItemId)>/<u(LootTableId)> to <u(TargetUnit)>"),
	Documentation = "Give an item to an npc, and have them equip items",
	EditorNestedObjCategory = "Units",
}

---
--- Executes the NpcUnitGiveItem effect, which gives an item or a set of items from a loot table to a specified NPC unit.
---
--- @param obj table The object the effect is being applied to.
--- @param context table The context in which the effect is being executed.
---
function NpcUnitGiveItem:__exec(obj, context)
	local units = empty_table
	local group = Groups[self.TargetUnit] 
	if group then
		local unitClass = {}
		for i, obj in ipairs(group) do
			if IsKindOf(obj, "Unit") then
				unitClass[#unitClass + 1] = obj
			end
		end
		units = unitClass
	else
		units = context.target_units or units
	end
	if not units or not units[1] then return end
	
	local items = {}
	if self.ItemId and self.ItemId~="" then
		table.insert(items, PlaceInventoryItem(self.ItemId))	
	end
	
	if self.LootTableId then
		local loot_tbl = LootDefs[self.LootTableId]
		if loot_tbl then
			loot_tbl:GenerateLoot(self, {}, InteractionRand(nil, "NpcGive"), items)
		end
	end
	
	local unit = units[1]
	for i, item in ipairs(items) do
		item.drop_chance = self.DontDrop and 0 or 100
		if unit:CanAddItem("Handheld A", item) then
			unit:AddItem("Handheld A", item)
		elseif unit:CanAddItem("Head", item) then
			unit:AddItem("Head", item)
		elseif unit:CanAddItem("Torso", item) then
			unit:AddItem("Torso", item)
		elseif unit:CanAddItem("Legs", item) then
			unit:AddItem("Legs", item)
		else
			unit:AddItem("Inventory", item)
		end
	end
	unit:UpdateOutfit()
end

---
--- Checks if the NpcUnitGiveItem effect is valid.
---
--- @return string|nil The error message if the effect is invalid, or nil if it is valid.
---
function NpcUnitGiveItem:GetError()
	if not self.ItemId and not self.LootTableId then
		return "No items set"
	end
	if not self.TargetUnit then
		return "No target unit"
	end
end

DefineClass.NpcUnitTakeItem = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "ItemId", name = "Item", 
			editor = "preset_id", default = false, preset_class = "InventoryItemCompositeDef", },
		{ id = "TargetUnit", name = "NPC Name", help = "The name of the NPC to associate.", 
			editor = "combo", default = false, items = function (self) return GetUnitGroups() end, },
	},
	EditorView = Untranslated("Take <u(ItemId)> from <u(TargetUnit)>"),
	Documentation = "Take an item from an NPC",
	EditorNestedObjCategory = "Units",
}

---
--- Executes the NpcUnitTakeItem effect, which removes an item from the target NPC unit.
---
--- @param obj table The object that the effect is attached to.
--- @param context table The execution context for the effect.
---
function NpcUnitTakeItem:__exec(obj, context)
	local units = empty_table
	local group = Groups[self.TargetUnit] 
	if group then
		local unitClass = {}
		for i, obj in ipairs(group) do
			if IsKindOf(obj, "Unit") then
				unitClass[#unitClass + 1] = obj
			end
		end
		units = unitClass
	else
		units = context.target_units or units
	end
	if not units or not units[1] then return end
	
	local unit = units[1]
	local itemsToRemove = {}
	local itemsToRemoveSlots = {}
	unit:ForEachItem(false, function(item, slot)
		if item.class == self.ItemId then
			itemsToRemove[#itemsToRemove + 1] = item
			itemsToRemoveSlots[#itemsToRemoveSlots + 1] = slot
		end
	end)
	
	for i, item in ipairs(itemsToRemove) do
		unit:RemoveItem(itemsToRemoveSlots[i], item)
	end
	unit:UpdateOutfit()
end

---
--- Returns an error message if the NpcUnitTakeItem effect is not properly configured.
---
--- @return string|nil The error message, or nil if the effect is properly configured.
---
function NpcUnitTakeItem:GetError()
	if not self.ItemId then
		return "No items set"
	end
	if not self.TargetUnit then
		return "No target unit"
	end
end

DefineClass.PhraseSetEnabled = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Conversation", help = "The conversation the phrase is in.", 
			editor = "preset_id", default = false, preset_class = "Conversation", },
		{ id = "PhraseId", help = "The Id of the phrase to enable/disable.", 
			editor = "choice", default = false, items = function (self) return GetPhraseIdsCombo(self.Conversation) end, },
		{ id = "Enabled", help = "Enable or disable the phrase.", 
			editor = "bool", default = true, },
	},
	Documentation = "Enables or disables a particular conversation phrase.",
	EditorNestedObjCategory = "Interactions",
}

---
--- Returns a string representation of the PhraseSetEnabled effect for the editor view.
---
--- @return string The editor view string for the PhraseSetEnabled effect.
---
function PhraseSetEnabled:GetEditorView()
	local enable = self.Enabled and Untranslated("Enable phrase ") or Untranslated("Disable phrase ")
	return Untranslated("<u(Conversation)>: ") .. enable .. Untranslated("<u(PhraseId)>")
end

---
--- Executes the PhraseSetEnabled effect, which sets the enabled state of a conversation phrase.
---
--- @param obj table The object the effect is being executed on.
--- @param context table The execution context.
---
function PhraseSetEnabled:__exec(obj, context)
	SetPhraseEnabledState(self.Conversation .. "." .. self.PhraseId, self.Enabled)
end

---
--- Initializes the `Conversation` property of the `PhraseSetEnabled` effect when a new instance is created in the editor.
---
--- @param parent table The parent object of the `PhraseSetEnabled` effect.
--- @param ged table The editor object for the `PhraseSetEnabled` effect.
--- @param is_paste boolean Whether the effect was pasted from another location.
---
function PhraseSetEnabled:OnAfterEditorNew(parent, ged, is_paste)
	local preset = GetParentTableOfKind(self, "Conversation")
	if preset:IsKindOf("Conversation") then
		self.Conversation = preset.id
	end
end

DefineClass.PhraseSetSeen = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Conversation", help = "The conversation the phrase is in.", 
			editor = "preset_id", default = false, preset_class = "Conversation", },
		{ id = "PhraseId", help = "The Id of the phrase to enable/disable.", 
			editor = "choice", default = false, items = function (self) return GetPhraseIdsCombo(self.Conversation) end, },
		{ id = "Seen", help = "Sets the phrase as not seen (highlighted) by default; check the box to set the phrase as seen (dimmed) instead.", 
			editor = "bool", default = false, },
	},
	Documentation = "Changes a conversation's phrase \"seen\" (dimmed) status.",
	EditorNestedObjCategory = "Interactions",
}

---
--- Returns a string representation of the PhraseSetSeen effect for the editor view.
---
--- @return string The editor view string for the PhraseSetSeen effect.
---
function PhraseSetSeen:GetEditorView()
	local seen = self.Seen and Untranslated("seen") or Untranslated("not seen")
	return Untranslated("<u(Conversation)>: Set phrase<u(PhraseId)> as ") .. seen
end

---
--- Executes the PhraseSetSeen effect, which sets the "seen" (dimmed) state of a conversation phrase.
---
--- @param obj table The object the effect is being executed on.
--- @param context table The execution context.
---
function PhraseSetSeen:__exec(obj, context)
	SetPhraseSeen(self.Conversation .. "." .. self.PhraseId, self.Seen)
end

---
--- Initializes the `Conversation` property of the `PhraseSetEnabled` effect when a new instance is created in the editor.
---
--- @param parent table The parent object of the `PhraseSetEnabled` effect.
--- @param ged table The editor object for the `PhraseSetEnabled` effect.
--- @param is_paste boolean Whether the effect was pasted from another location.
---
function PhraseSetSeen:OnAfterEditorNew(parent, ged, is_paste)
	local preset = GetParentTableOfKind(self, "Conversation")
	if preset:IsKindOf("Conversation") then
		self.Conversation = preset.id
	end
end

DefineClass.PlayBanterEffect = {
	__parents = { "Effect", "BanterFunctionObjectBase", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Banters", name = "Banters", help = "List of banters to play.", 
			editor = "preset_id_list", default = {}, preset_class = "BanterDef", item_default = "", },
		{ id = "searchInMarker", name = "Include Marker Units", help = "The only valid actors for a banter are the units passed by the previous conditions. By setting this on units inside a GridMarker will also be included as valid actors.", 
			editor = "bool", default = true, },
		{ id = "banterSequentialWaitFor", name = "Wait For", help = "The banter event to wait for (if executing sequentially).", 
			editor = "choice", default = "BanterDone", items = function (self) return {"",  "BanterStart", "BanterDone", "BanterLineStart", "BanterLineDone"} end, },
		{ id = "searchInMap", name = "Include Whole Map", help = "The only valid actors for a banter are the units passed by the previous conditions. By setting this on units from the whole map will be considered. Your banter might spawn on a unit off screen.", 
			editor = "bool", default = false, },
		{ id = "FallbackToMerc", name = "Radio", help = "If enabled the banter will appear over the first merc on map if the banter actor is not present on the map.", 
			editor = "bool", default = false, },
		{ id = "WaitSetpieceEnd", help = "if enabled the banter will wait for the setpiece to end", 
			editor = "bool", default = false, },
		{ id = "anyFallback", name = "Use any unit as fallback for Radio.", help = "Use this if the Radio banter is not played.", 
			editor = "bool", default = false, },
		{ id = "AnyActorOverrideGroup", name = "Any Actor Override Group", help = 'Banter lines with actor "any" will be played by the first /object/ from the group.', 
			editor = "text", default = false, },
	},
	Documentation = "An effect to play a banter.",
	EditorNestedObjCategory = "Interactions",
}

---
--- Checks if the `Banters` property is set and if all the banter IDs in the list are valid.
---
--- @return string|nil An error message if there are any issues, or `nil` if the `Banters` property is valid.
---
function PlayBanterEffect:GetError()
	if not self.Banters then
		return "No banters"
	end
	
	for i,banter_id in ipairs(self.Banters) do
		if not Banters[banter_id] then
			return "Invalid banter ID " .. banter_id
		end
	end
end

---
--- Returns a string representation of the banter IDs configured for this effect.
---
--- @return string A string containing the banter IDs, separated by commas.
---
function PlayBanterEffect:GetEditorView()
	return Untranslated("Play banter(s): ").. Untranslated(table.concat(self.Banters, ", "))
end

---
--- Executes the PlayBanterEffect by finding the appropriate units to play the banter with.
---
--- @param obj table The object that triggered the effect.
--- @param context table The context of the effect, which may contain information about target units.
--- @return table|nil The banter object that was played, or nil if no banter could be played.
---
function PlayBanterEffect:__exec(obj, context)
	local is_marker = IsKindOf(obj, "GridMarker")
	local context_is_table = context and type(context)=="table"
	local targetUnitsTable = context_is_table and rawget(context, "target_units")
	targetUnitsTable = targetUnitsTable and table.icopy(targetUnitsTable)
	local units = targetUnitsTable or (is_marker and { obj } or {})
	if self.searchInMarker and is_marker then
		MapForEach("map", "Unit", function(u)
			if obj:IsInsideArea(u:GetPos()) then
				units[#units + 1] = u
			end
		end)
	elseif self.searchInMap then
		MapForEach("map", "Unit", function(u)
			units[#units + 1] = u
		end)
		MapForEach("map", "CheeringDummy", function(u)
			units[#units + 1] = u
		end)
	end
	if context_is_table and rawget(context, "interactable") then
		units = table.copy(units)
		table.insert(units, 1, context.interactable) 
	end
	local fallback = false
	if self.FallbackToMerc then
		for _, unit in ipairs(g_Units) do
			if unit:IsPlayerAlly() and not unit:IsDead() then
				fallback = unit
				break
			end
		end
		-- search for any actor also
		if not fallback and self.anyFallback then
			for _, unit in ipairs(g_Units) do
				if not unit:IsDead() then
					fallback = unit
					break
				end
			end
		end
	end
	
	local banters, banterActors = FilterAvailableBanters(self.Banters, context, units, fallback)
	if not banters then 
		CombatLog("debug","No banters can be played with the selected actors")
		return 
	end
	
	local idx = InteractionRand(#banters, "PlayBanterEffect") + 1
	local banterToPlay = banters[idx]
	local actorsToPlayWith = banterActors[idx]
	local anyActorOverride = self.AnyActorOverrideGroup
	
	-- Support for banter from conversation
	if context_is_table and context and context.found_merc then
		anyActorOverride = context.found_merc
	end
	
	local banterObj = PlayBanter(banterToPlay, actorsToPlayWith, fallback, anyActorOverride, self.WaitSetpieceEnd)
	if banterObj then
		local playerPos = IsValid(obj) and obj:GetPos()
		if playerPos then
			banterObj:SetPos(playerPos)
		end
		
		local resumeData = {}
		resumeData.preset = banterObj.preset.id
		
		local banterUnits = {}
		for i, u in ipairs(banterObj.associated_units) do
			banterUnits[#banterUnits + 1] = u.handle
		end
		resumeData.units = banterUnits
		resumeData.fallbackUnit = banterObj.fallback_actor and banterObj.fallback_actor.handle
		resumeData.any_actor_override = banterObj.any_actor_override and banterObj.any_actor_override.handle
		resumeData.playerHandle = banterObj.handle
		if playerPos then resumeData.player_pos = playerPos end
		
		g_PlayingBanterEffects[self] = resumeData
	end
	
	return banterObj
end

---
--- Skips all banters in the `Banters` list.
---
--- This function is used to skip any banter that may be playing when the user interacts with the object.
---
--- @param obj table The object that the banter effect is attached to.
--- @param context table The context information for the banter effect.
---
function PlayBanterEffect:__skip(obj, context)
	for i, banterId in ipairs(self.Banters) do
		SkipBanterFromUI(banterId)
	end
end

---
--- Waits for a specific event to occur before executing the banter effect.
---
--- This function is called after the `PlayBanterEffect:__exec` function, and will wait for the event specified in the `banterSequentialWaitFor` property to occur before continuing.
---
--- @param obj table The object that the banter effect is attached to.
--- @param context table The context information for the banter effect.
---
function PlayBanterEffect:__waitexec(obj, context)
	local banterObj = self:__exec(obj, context)
	local event = self.banterSequentialWaitFor
	if banterObj and event ~= "" then
		local notTimedOut, preset_id
		while preset_id ~= banterObj.preset.id do
			notTimedOut, preset_id = WaitMsg(event)
		end
	end
end

---
--- Checks for errors in the PlayBanterEffect class.
---
--- This function checks for two potential errors:
--- 1. If the Banters list is empty, it returns an error message indicating that at least one banter should be added.
--- 2. If both the searchInMarker and searchInMap properties are true, it returns an error message indicating that only one of them should be selected.
---
--- @return string|nil An error message if an error is detected, or nil if no errors are found.
---
function PlayBanterEffect:GetError()
	if #self.Banters == 0 then
		return "Add at least one banter"
	end
	if self.searchInMarker and self.searchInMap then
		return "Don't select both search in marker and search in map."
	end
end

---
--- Gets the resume data for a PlayBanterEffect instance.
---
--- This function retrieves the resume data for a PlayBanterEffect instance, which includes the current line being played for the banter. If the player associated with the banter effect is still valid, the current_line field is updated to the next line before returning the resume data.
---
--- @return string|nil The resume data for the PlayBanterEffect instance, or nil if no resume data is available.
---
function PlayBanterEffect:GetResumeData()
	local resumeData = g_PlayingBanterEffects[self]
	if resumeData and resumeData.playerHandle then
		local player = HandleToObject[resumeData.playerHandle]
		if IsValid(player) then
			resumeData.current_line = (player.current_line and player.current_line + 1) or 1
			return "PlayBanterEffect", resumeData
		end
	end
end

DefineClass.PlayNotNowVR = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	EditorView = Untranslated('Unit plays "NotNow" VR'),
	Documentation = 'Unit plays "NotNow" VR.',
	EditorNestedObjCategory = "Units",
}

---
--- Plays the "NotNow" VR voice response for the given object.
---
--- @param obj table The object to play the voice response for.
--- @param context table The context of the effect execution.
---
function PlayNotNowVR:__exec(obj, context)
	PlayVoiceResponse(obj, "NotNow")
end

DefineClass.PlaySetpiece = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "setpiece", name = "Setpiece", help = "The id of the set piece preset to play.", 
			editor = "preset_id", default = false, preset_class = "SetpiecePrg", },
	},
	EditorView = Untranslated("Play <setpiece> setpiece"),
	Documentation = "Play a Set-piece.",
	EditorNestedObjCategory = "",
	EditorNestedObjCategory = "Interactions",
}

---
--- Executes the PlaySetpiece effect, which plays a set-piece.
---
--- If the set-piece is configured to take player control, it opens a dialog to start the set-piece. Otherwise, it starts the set-piece in a new game thread.
---
--- The function first determines the trigger units for the set-piece based on the context. If the context has a "target_units" field, it uses those. Otherwise, it tries to get the units from the object's group, or all player mercs in the current sector.
---
--- If the context has a "found_merc" field, it passes that as an extra parameter to the set-piece.
---
--- @param obj table The object that the effect is being executed on.
--- @param context table The context of the effect execution, which may contain information about target units and a found merc.
---
function PlaySetpiece:__exec(obj, context)
	local triggerUnits = false
	if type(context) == "table" and rawget(context, "target_units") then
		triggerUnits = rawget(context, "target_units")
	elseif Groups[obj] then
		triggerUnits = Groups[obj]
	elseif gv_CurrentSectorId then
		triggerUnits = table.map(GetPlayerMercsInSector(gv_CurrentSectorId), function(o) return g_Units[o] end)
	end
	
	local foundMerc = false
	if type(context) == "table" and rawget(context, "found_merc") then
		foundMerc = rawget(context, "found_merc")
		foundMerc = g_Units[foundMerc]
	end
	
	local setpiece = Setpieces[self.setpiece]
	if setpiece.TakePlayerControl then
		local dlg = OpenDialog("XSetpieceDlg", false, { 
			setpiece = self.setpiece,
			setpiece_seed = InteractionRand(nil, "Setpiece"),
			triggerUnits = triggerUnits,
			extra_params = foundMerc and { {foundMerc} }
		})
		if GameState.entering_sector then
			dlg:FadeOut(0) -- immediate black screen to hide any stray frames if we are started upon entering a sector (with a loading screen)
		end
	else
		CreateGameTimeThread(function()
			StartSetpiece(self.setpiece, false, InteractionRand(nil, "Setpiece"), triggerUnits, foundMerc)
		end)
	end
end

---
--- Executes the PlaySetpiece effect, which plays a set-piece. If the set-piece is configured to take player control, it opens a dialog to start the set-piece. Otherwise, it starts the set-piece in a new game thread.
---
--- This function waits for the set-piece to end before returning. If the set-piece takes player control, it waits for the "SetpieceEnded" message. Otherwise, it waits for the "SetpieceEndExecution" message.
---
--- @param obj table The object that the effect is being executed on.
--- @param context table The context of the effect execution, which may contain information about target units and a found merc.
---
function PlaySetpiece:__waitexec(obj, context)
	self:__exec(obj, context)
	
	local setpiece = Setpieces[self.setpiece]
	if setpiece.TakePlayerControl then
		WaitMsg("SetpieceEnded")
	else
		WaitMsg("SetpieceEndExecution")
	end
end

---
--- Returns an error message if the setpiece property is not set.
---
--- @return string|nil Error message if the setpiece property is not set, otherwise nil.
---
function PlaySetpiece:GetError()
	if not self.setpiece then return "No setpiece set." end
end

DefineClass.PlayUnitVoiceResponse = {
	__parents = { "UnitTarget", "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "VoiceResponse", name = "Voice Response", help = "Voice response type to choose a phrase from; the phrases of the current unit will be used.", 
			editor = "combo", default = false, items = function (self) return GetVoiceResponseCombo(self, self.TargetUnit) end, },
	},
	EditorView = Untranslated("<u(TargetUnit)> plays '<u(VoiceResponse)>'"),
	Documentation = "Target unit plays voice response",
	EditorNestedObjCategory = "Units",
}

---
--- Executes the PlayUnitVoiceResponse effect, which plays a voice response for the target unit.
---
--- If the VoiceResponse property is not set, this function will return without doing anything.
---
--- If a context is provided, it will use the target_units field to randomly select a unit to play the voice response for. Otherwise, it will use the units matched by the MatchMapUnits function.
---
--- @param obj table The object that the effect is being executed on.
--- @param context table The context of the effect execution, which may contain information about target units.
---
function PlayUnitVoiceResponse:__exec(obj, context)
	if not self.VoiceResponse then return end
	if not context then context = {} end
	
	local units = self:MatchMapUnits(obj, context)
	if units and context.target_units then
		local unit =   context.target_units[ AsyncRand(# context.target_units) +1]
		if not unit or not self.VoiceResponse then return end
		PlayVoiceResponse(unit, self.VoiceResponse, true)
	end
end

---
--- Returns an error message if the TargetUnit or VoiceResponse properties are not set.
---
--- @return string|nil Error message if the TargetUnit or VoiceResponse properties are not set, otherwise nil.
---
function PlayUnitVoiceResponse:GetError()
	if not self.TargetUnit then
		return "Choose target unit"
	end
	if not self.VoiceResponse then
		return "Choose voice response id"
	end
end

---
--- Checks if the given unit is valid for the PlayUnitVoiceResponse effect.
---
--- This function always returns true, as there are no additional checks performed.
---
--- @param unit table The unit to check.
--- @param obj table The object that the effect is being executed on.
--- @param context table The context of the effect execution.
--- @return boolean Always returns true.
---
function PlayUnitVoiceResponse:UnitCheck(unit, obj, context)
	return true
end

DefineClass.PlayerGrantMoney = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Amount", name = "Amount", help = "Amount of money to grant.", 
			editor = "number", default = 0, min = 0, },
	},
	EditorView = Untranslated("Grant <money(Amount)>"),
	Documentation = "Give money to player.",
}

---
--- Adds the specified amount of money to the player's balance.
---
--- @param obj table The object that the effect is being executed on.
--- @param context table The context of the effect execution.
---
function PlayerGrantMoney:__exec(obj, context)
	AddMoney(self.Amount, "deposit")
end

---
--- Returns a localized string representing the amount of money gained or paid.
---
--- @param negative boolean Whether the amount is negative (money paid) or positive (money gained).
--- @param template string The localization template to use.
--- @param game table The game context.
--- @return string The localized string representing the money amount.
---
function PlayerGrantMoney:GetPhraseTopRolloverText(negative, template, game)
	local amount =  self.Amount
	if amount>0 then
		return T{666348317447, "<money(Amount)> acquired",Amount = amount}
	elseif amount<0 then
		return T{194741866993, "Paid <money(Amount)>",Amount = amount}
	end
end

---
--- Returns the name of the sound effect to play when money is granted to the player.
---
--- @return string The name of the sound effect to play.
---
function PlayerGrantMoney:GetPhraseFX()
	return "ConversationMoneyGained"
end

DefineClass.PlayerPayMoney = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Amount", name = "Amount", help = "Amount of money to pay.", 
			editor = "number", default = 0, min = 0, },
	},
	EditorView = Untranslated("Pay <money(Amount)>"),
	Documentation = "Take money from player.",
}

---
--- Subtracts the specified amount of money from the player's balance.
---
--- @param obj table The object that the effect is being executed on.
--- @param context table The context of the effect execution.
---
function PlayerPayMoney:__exec(obj, context)
	AddMoney(-self.Amount, "expense")
end

---
--- Returns a localized string representing the amount of money paid.
---
--- @param negative boolean Whether the amount is negative (money paid) or positive (money gained).
--- @param template string The localization template to use.
--- @param game table The game context.
--- @return string The localized string representing the money amount.
---
function PlayerPayMoney:GetPhraseTopRolloverText(negative, template, game)
	local amount =  self.Amount
	return T{194741866993, "Paid <money(Amount)>",Amount = amount}
end

---
--- Returns a localized string representing the amount of money to be given.
---
--- @param context table The context of the effect execution.
--- @return string The localized string representing the money amount.
---
function PlayerPayMoney:GetUIText(context)
	return  T{982094780061, "Give <money(Amount)>", Amount = self.Amount}
end

DefineClass.QuestEffectBase = {
	__parents = { "Effect", "QuestFunctionObjectBase", },
	__generated_by_class = "ClassDef",

	EditorNestedObjCategory = "Quests",
}

---
--- Called after the editor creates a new instance of this effect.
--- If the effect is not pasted, it will attempt to set the QuestId property
--- to the id of the parent QuestsDef object.
---
--- @param obj table The object that the effect is being executed on.
--- @param socket table The socket that the effect is being added to.
--- @param paste boolean Whether the effect was pasted or not.
--- @param old_id string The old id of the effect, if it was pasted.
---
function QuestEffectBase:OnAfterEditorNew(obj, socket, paste, old_id)
	if not paste then
		local quest_def = GetParentTableOfKindNoCheck(obj, "QuestsDef")
		if quest_def then
			self.QuestId = quest_def.id
		end
	end
end

DefineClass.QuestKillTCE = {
	__parents = { "QuestEffectBase", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "QuestId", name = "Quest id", help = "Quest to change.", 
			editor = "preset_id", default = false, preset_class = "QuestsDef", },
		{ id = "TCE", name = "TCE", help = "Quest TCE to kill", 
			editor = "choice", default = false, items = function (self) return GetQuestsVarsCombo(self.QuestId, "TCEState") end, },
	},
	EditorView = Untranslated("Kills '<u(TCE)>' TCE from '<u(QuestId)>' quest"),
	Documentation = "Kills specific TCE from a given quest",
}

---
--- Executes the QuestKillTCE effect.
---
--- This function is responsible for killing a specific TCE (Timed Conditional Effect) from a given quest.
---
--- @param obj table The object that the effect is being executed on.
--- @param context table The context of the effect execution.
--- @return boolean True if the TCE was successfully killed, false otherwise.
---
function QuestKillTCE:__exec(obj, context)
	if not RunningSequentialEffects then return false end
	if not self.QuestId or self.QuestId == ""  or not self.TCE or self.TCE == "" then return false end
	
	for i = #RunningSequentialEffects, 1, -1 do
		local run_state = RunningSequentialEffects[i]
		if run_state[5] == self.QuestId and run_state[6] == self.TCE then
			DeleteThread(run_state[1])
			table.remove(RunningSequentialEffects, i)
			return
		end
	end
end

---
--- Checks if the QuestId property is set and not empty.
---
--- @return string|nil An error message if the QuestId property is not set or empty, otherwise nil.
---
function QuestKillTCE:GetError()
	if not self.QuestId or self.QuestId=="" then
		return "Specify the quest!"
	end
end

DefineClass.QuestSetVariableBool = {
	__parents = { "QuestEffectBase", },
	__generated_by_class = "EffectDef",

	properties = {
		{ category = "General", id = "QuestId", name = "Quest id", help = "Quest to change.", 
			editor = "preset_id", default = false, preset_class = "QuestsDef", preset_filter = function (preset, obj, prop_meta)
	return QuestHasVariable(preset, "QuestVarBool")
end, 
},
		{ category = "General", id = "Prop", name = "Quest Variable", help = "Quest variable to change.", 
			editor = "choice", default = false, items = function (self) return GetQuestsVarsCombo(self.QuestId,"Bool") end, },
		{ category = "General", id = "Toggle", name = "Toggle Current Value", help = "Toggles the current flag value (changes it from 'true' to 'false' and vice versa).", 
			editor = "bool", default = false, },
		{ category = "General", id = "Set", name = "Change to", help = "Value to set.", 
			editor = "bool", default = true, 
			no_edit = function(self) return self.Toggle end, },
	},
	Documentation = "A way to change the quest's flag. If not 'Toggle'  then changes the flag to 'Set' value, else toggle the flag's value.",
}

---
--- Sets a quest variable to a specified boolean value, or toggles its current value.
---
--- @param obj table The object that the effect is being executed on.
--- @param context table The context of the effect execution.
---
function QuestSetVariableBool:__exec(obj, context)
	local quest = QuestGetState(self.QuestId or "")
	if not quest then return end
	if self.Toggle then
		SetQuestVar(quest, self.Prop, not rawget(quest, self.Prop))
	else
		SetQuestVar(quest, self.Prop, self.Set)
	end
end

---
--- Checks if the QuestId and Prop properties are set and not empty.
---
--- @return string|nil An error message if the QuestId or Prop properties are not set or empty, otherwise nil.
---
function QuestSetVariableBool:GetError()
	if not self.QuestId or self.QuestId=="" then
		return "Specify the quest!"
	end
	if not self.Prop then
		return "Specify the param to change!"
	end
end

---
--- Returns a string representation of the QuestSetVariableBool effect for the editor.
---
--- If the effect is set to toggle the quest variable, the string will be:
--- "Quest <u(QuestId)>: toggle <u(Prop)>"
---
--- If the effect is set to set the quest variable to a specific value, the string will be:
--- "Quest <u(QuestId)>: <u(Prop)> = <tostring(self.Set)>"
---
--- @return string The editor view string for the QuestSetVariableBool effect.
---
function QuestSetVariableBool:GetEditorView()
	if self.Toggle then
		return Untranslated("Quest <u(QuestId)>: toggle <u(Prop)>")
	else
		return Untranslated("Quest <u(QuestId)>: <u(Prop)> = " .. tostring(self.Set))
	end
end

DefineClass.QuestSetVariableNum = {
	__parents = { "QuestEffectBase", },
	__generated_by_class = "EffectDef",

	properties = {
		{ category = "General", id = "QuestId", name = "Quest id", help = "Quest to change.", 
			editor = "preset_id", default = false, preset_class = "QuestsDef", preset_filter = function (preset, obj, prop_meta)
	return QuestHasVariable(preset, "QuestVarNum")
end, 
},
		{ category = "General", id = "Prop", name = "Quest Variable", help = "Quest variable to change.", 
			editor = "choice", default = false, items = function (self) return GetQuestsVarsCombo(self.QuestId,"Num") end, },
		{ category = "General", id = "Amount", name = "Amount", help = "Value to set.", 
			editor = "number", default = 0, },
		{ category = "General", id = "RandomRangeMax", name = "Random Amount Max", help = 'If set, the amount will be a random number between "Amount" and this number. Both values are inclusive.', 
			editor = "number", default = false, },
		{ category = "General", id = "Percent", name = "Percent", help = "Percent change to current value, if operation is modify.", 
			editor = "number", default = 100, },
		{ category = "General", id = "Operation", name = "Operation", help = "Modify the current value with amount/percent or set a new one.", 
			editor = "combo", default = "modify", items = function (self) return {"set", "modify"} end, },
	},
	Documentation = "Change a quest variable's value. Modifies the current value wiyh amount/percent or sets a new amount.",
}

---
--- Executes the QuestSetVariableNum effect, which sets or modifies a quest variable's numeric value.
---
--- If the operation is "set", the quest variable is set to the specified amount, which may be a random value within a range.
---
--- If the operation is "modify", the quest variable's current value is modified by adding the specified amount, and optionally applying a percentage change.
---
--- @param obj table The object that the effect is being applied to.
--- @param context table The context in which the effect is being executed.
---
function QuestSetVariableNum:__exec(obj, context)
	local quest = QuestGetState(self.QuestId or "")
	if not quest then return end
	local prev_val =  rawget(quest,self.Prop)
	local new_val
	local mod_amount = self.Amount
	
	if self.RandomRangeMax then
		mod_amount = mod_amount + InteractionRand(self.RandomRangeMax - mod_amount + 1, "QuestVariableNum")
	end
	
	if self.Operation=="set" then
		new_val = mod_amount
	elseif self.Operation=="modify" then
		new_val = (prev_val or 0) + mod_amount
		if self.Percent~=0 then
			new_val = MulDivRound(new_val, self.Percent, 100)
		end
	end
	SetQuestVar(quest, self.Prop, new_val)
end

---
--- Checks for errors in the QuestSetVariableNum effect.
---
--- @param self table The QuestSetVariableNum effect instance.
--- @return string|nil An error message if any errors are found, or nil if no errors.
---
function QuestSetVariableNum:GetError()
	if not self.QuestId or self.QuestId=="" then
		return "Specify the quest!"
	end
	if not self.Prop then
		return "Specify the param to change!"
	end
	if self.RandomRangeMax and self.RandomRangeMax < self.Amount then
		return "Max cannot be smaller than min (Amount)."
	end
	if self.Operation~="set" then
		local quest = QuestGetState(self.QuestId or "")
		local prev_val =  rawget(quest,self.Prop)
		if not prev_val then
			return "This prop has not set any value and can not be changed"
		end
	end
end

---
--- Generates the editor view string for the QuestSetVariableNum effect.
---
--- @param self table The QuestSetVariableNum effect instance.
--- @return string The editor view string.
---
function QuestSetVariableNum:GetEditorView()
	local printValue = "<Amount>"
	if self.RandomRangeMax then
		printValue = printValue .. "-<RandomRangeMax>"
	end
	
	if self.Operation=="set" then
		return Untranslated("Quest <u(QuestId)>:<u(Prop)> = " .. printValue)
	elseif self.Operation=="modify" then
		return Untranslated("Quest <u(QuestId)>:<u(Prop)> =  <Percent>% from (<u(Prop)> + " .. printValue .. ")")
	end
end

DefineClass.QuestSetVariableSpecialValue = {
	__parents = { "QuestEffectBase", },
	__generated_by_class = "EffectDef",

	properties = {
		{ category = "General", id = "QuestId", name = "Quest id", help = "Quest to change.", 
			editor = "preset_id", default = false, preset_class = "QuestsDef", preset_filter = function (preset, obj, prop_meta)
	return QuestHasVariable(preset, "QuestVarNum")
end, 
},
		{ category = "General", id = "Prop", name = "Quest Variable", help = "Quest variable to change.", 
			editor = "choice", default = false, no_validate = true, items = function (self) return GetQuestsVarsCombo(self.QuestId,"Num") end, },
		{ category = "General", id = "Special", name = "Special value type", help = "Value to set.", 
			editor = "combo", default = "current campaign time", items = function (self) return {"current campaign time"} end, },
	},
	Documentation = "Set a quest number variable to a special value, chosen from the Special property.",
}

---
--- Executes the QuestSetVariableSpecialValue effect.
---
--- Sets the specified quest variable to a special value, such as the current campaign time.
---
--- @param obj table The object the effect is being executed on.
--- @param context table The execution context.
---
function QuestSetVariableSpecialValue:__exec(obj, context)
	local quest = QuestGetState(self.QuestId or "")
	if not quest then return end
	local new_val
	
	if self.Special == "current campaign time" then
		new_val = Game.CampaignTime
	end
	
	SetQuestVar(quest, self.Prop, new_val)
end

---
--- Checks if the QuestId property is set and not empty.
---
--- @return string|nil An error message if the QuestId is not set, otherwise nil.
---
function QuestSetVariableSpecialValue:GetError()
	if not self.QuestId or self.QuestId=="" then
		return "Specify the quest!"
	end
end

---
--- Returns the editor view for the QuestSetVariableSpecialValue effect.
---
--- If the Special property is set to "current campaign time", this function returns a string
--- that displays the quest ID, the quest variable, and the value "current campaign time".
---
--- @return string The editor view string.
---
function QuestSetVariableSpecialValue:GetEditorView()
	if self.Special == "current campaign time" then
		return Untranslated("Quest <u(QuestId)>:<u(Prop)> = current campaign time")
	end
end

DefineClass.QuestSetVariableText = {
	__parents = { "QuestEffectBase", },
	__generated_by_class = "EffectDef",

	properties = {
		{ category = "General", id = "QuestId", name = "Quest id", help = "Quest to change.", 
			editor = "preset_id", default = false, preset_class = "QuestsDef", preset_filter = function (preset, obj, prop_meta)
	return QuestHasVariable(preset, "QuestVarText")
end, 
},
		{ category = "General", id = "Prop", name = "Quest Variable", help = "Quest variable to change", 
			editor = "choice", default = false, items = function (self) return GetQuestsVarsCombo(self.QuestId, "Text") end, },
		{ category = "General", id = "Text", name = "Text", help = "Value to set.", 
			editor = "text", default = '""', },
	},
	EditorView = Untranslated("Quest <u(QuestId)>:<u(Prop)> = '<u(Text)>'"),
	Documentation = "Change a quest's text variable.",
}

---
--- Executes the QuestSetVariableText effect, setting the specified quest variable to the provided text value.
---
--- @param obj table The object the effect is being executed on.
--- @param context table The execution context.
---
function QuestSetVariableText:__exec(obj, context)
	local quest = QuestGetState(self.QuestId or "")
	if not quest then return end
	SetQuestVar(quest, self.Prop, self.Text)
end

---
--- Returns an error message if the QuestId or Prop properties are not set.
---
--- This function is used to validate the properties of the QuestSetVariableText effect before execution.
---
--- @return string|nil An error message if the properties are not set, or nil if the properties are valid.
---
function QuestSetVariableText:GetError()
	if not self.QuestId or self.QuestId=="" then
		return "Specify the quest!"
	end
	if not self.Prop then
		return "Specify the param to change!"
	end
end

DefineClass.QuestSetVariableTimer = {
	__parents = { "QuestEffectBase", },
	__generated_by_class = "EffectDef",

	properties = {
		{ category = "General", id = "QuestId", name = "Quest id", help = "Quest to change.", 
			editor = "preset_id", default = false, preset_class = "QuestsDef", preset_filter = function (preset, obj, prop_meta)
	return QuestHasVariable(preset, "QuestVarNum")
end, 
},
		{ category = "General", id = "Prop", name = "Quest Variable", help = "Quest variable to change.", 
			editor = "choice", default = false, items = function (self) return GetQuestsVarsCombo(self.QuestId,"Num") end, },
		{ category = "General", id = "TimeAmount", 
			editor = "number", default = 0, },
		{ category = "General", id = "TimeAmountRangeMax", help = "If set the time amount will be randomed between TimeAmount and this value.", 
			editor = "number", default = 0, },
		{ category = "General", id = "Timescale", 
			editor = "choice", default = "h", items = function (self) return GetTimeScalesCombo() end, },
	},
	Documentation = "Set a timer to a quest variable.",
}

---
--- Executes the QuestSetVariableTimer effect, setting the specified quest variable to the current game time plus a specified time amount.
---
--- @param obj table The object the effect is being executed on.
--- @param context table The execution context.
---
function QuestSetVariableTimer:__exec(obj, context)
	local quest = QuestGetState(self.QuestId or "")
	if not quest then return end
	local prev_val =  rawget(quest, self.Prop)
	
	local timeAmount = self.TimeAmount
	if self.TimeAmountRangeMax ~= 0 then
		timeAmount = timeAmount + InteractionRand(self.TimeAmountRangeMax - timeAmount + 1, "QuestVariableTimer")
	end
	
	timeAmount = timeAmount * (const.Scale[self.Timescale] or const.Scale.h)
	local triggerTime = Game.CampaignTime + timeAmount
	SetQuestVar(quest, self.Prop, triggerTime)
end

---
--- Checks for errors in the QuestSetVariableTimer effect.
---
--- @param self table The QuestSetVariableTimer effect instance.
--- @return string|nil An error message if any errors are found, or nil if no errors.
---
function QuestSetVariableTimer:GetError()
	if not self.QuestId or self.QuestId=="" then
		return "Specify the quest!"
	end
	if not self.Prop then
		return "Specify the param to change!"
	end
	if (self.TimeAmountRangeMax or 0) ~= 0 and self.TimeAmountRangeMax < self.TimeAmount then
		return "Max cannot be smaller than min (TimeAmount)."
	end
end

---
--- Generates the editor view for the QuestSetVariableTimer effect.
---
--- @param self table The QuestSetVariableTimer effect instance.
--- @return string The editor view string.
---
function QuestSetVariableTimer:GetEditorView()
	local printValue = "<TimeAmount>"
	if (self.TimeAmountRangeMax or 0) ~= 0 then
		printValue = printValue .. "-<TimeAmountRangeMax>"
	end
	
	return Untranslated("Set quest timer in <u(QuestId)>:<u(Prop)> for after " .. printValue .. " " .. self.Timescale)
end

DefineClass.RadioStartConversation = {
	__parents = { "Effect", "ConversationFunctionObjectBase", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Conversation", name = "Conversation", help = "Conversation to start.", 
			editor = "preset_id", default = false, preset_class = "Conversation", },
		{ id = "Icon", 
			editor = "combo", default = "UI/Hud/radio", items = function (self) return GetRadioConversationIconsCombo end, },
	},
	EditorView = Untranslated("Start radio conversation <u(Conversation)>."),
	Documentation = "Starts a specific radio conversation - no groups or conditions are checked.",
	EditorNestedObjCategory = "Interactions",
}

---
--- Starts a radio conversation effect.
---
--- @param obj table The object the effect is being executed on.
--- @param context table The context in which the effect is being executed.
---
function RadioStartConversation:__exec(obj, context)
	StartConversationEffect(self.Conversation, {radio = true, icon = self.Icon})
end

---
--- Waits for a radio conversation effect to complete.
---
--- @param obj table The object the effect is being executed on.
--- @param context table The context in which the effect is being executed.
---
function RadioStartConversation:__waitexec(obj, context)
	StartConversationEffect(self.Conversation, {radio = true, icon = self.Icon}, "wait")
end

---
--- Checks if the `Conversation` property is set for the `RadioStartConversation` effect.
---
--- @return string|nil An error message if the `Conversation` property is not set, or `nil` if it is set.
---
function RadioStartConversation:GetError()
	if not self.Conversation then
		return "Please specify conversation"
	end
end

---
--- Returns the resume data for a `RadioStartConversation` effect.
---
--- @param thread table The coroutine thread.
--- @param stack table The call stack.
--- @param stack_index number The index of the current frame in the call stack.
--- @return string, string, string The effect name, conversation ID, and icon.
---
function RadioStartConversation:GetResumeData(thread, stack, stack_index)
	return "RadioStartConversation", self.Conversation, self.Icon
end

DefineClass.RandomEffect = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Effects", name = "Effects", 
			editor = "nested_list", default = false, base_class = "Effect", },
	},
	ReturnClass = "",
	EditorView = Untranslated("Play a random effect from a list."),
	Documentation = "Play a random effect from a list.",
	EditorNestedObjCategory = "",
}

---
--- Executes a random effect from the list of effects.
---
--- @param obj table The object the effect is being executed on.
--- @param context table The context in which the effect is being executed.
---
function RandomEffect:__exec(obj, context)
	local num = #self.Effects
	if num > 0 then
		local roll = InteractionRand(num, "RandomEffect") + 1
		self.Effects[roll]:__exec()
	end
end

---
--- Checks if the `Effects` property is set and has at least one effect.
---
--- @return string|nil An error message if the `Effects` property is not set or is empty, or `nil` if it is set.
---
function RandomEffect:GetError()
	if not self.Effects or #self.Effects < 1 then
		return "Please specify some effects"
	end
end

DefineClass.RandomEffectWithCondition = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Effects", name = "Effects", 
			editor = "nested_list", default = false, base_class = "ConditionalEffect", },
	},
	ReturnClass = "",
	EditorView = Untranslated("Play a random effect from a list whose conditions evaluate to true."),
	Documentation = "Play a random effect from a list whose conditions evaluate to true.",
	EditorNestedObjCategory = "",
}

---
--- Executes a random effect from the list of effects whose conditions evaluate to true.
---
--- @param obj table The object the effect is being executed on.
--- @param context table The context in which the effect is being executed.
---
function RandomEffectWithCondition:__exec(obj, context)
	local valid = {}
	for i, eff in ipairs(self.Effects) do
		if EvalConditionList(eff.Conditions, obj, context) then
			valid[#valid + 1] = eff
		end
	end
	local num = #valid
	if num > 0 then
		local roll = InteractionRand(num, "RandomEffect") + 1
		
		local effRolled = valid[roll]
		local effects = effRolled.Effects
		for _, effect in ipairs(effects) do
			effect:__exec(obj, context)
		end
	end
end

---
--- Checks if the `Effects` property is set and has at least one effect.
---
--- @return string|nil An error message if the `Effects` property is not set or is empty, or `nil` if it is set.
---
function RandomEffectWithCondition:GetError()
	if not self.Effects or #self.Effects < 1 then
		return "Please specify some effects"
	end
end

DefineClass.RechargeCDs = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	RequiredObjClasses = {
	"Unit",
	"UnitData",
},
	EditorView = Untranslated("Recharge a unit's CDs"),
	Documentation = "Recharge a unit's CDs",
	EditorNestedObjCategory = "Units",
}

---
--- Recharges the signatures (cooldowns) of a unit if it is not dead.
---
--- @param obj table The unit or unit data object to recharge the signatures of.
--- @param context table The context in which the effect is being executed.
---
function RechargeCDs:__exec(obj, context)
	if IsKindOfClasses(obj, "Unit", "UnitData") and not obj:IsDead() then
		obj:RechargeSignatures()
	end
end

DefineClass.RegenerateGuardpostObjective = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "GuardpostObjective", name = "GuardpostObjective", 
			editor = "preset_id", default = false, preset_class = "GuardpostObjective", },
	},
	EditorView = Untranslated("Regenerate guardpost objective <u(GuardpostObjective)>"),
	Documentation = "Regenerate a completed guardpost objective.",
	EditorNestedObjCategory = "Sectors",
}

---
--- Regenerates a completed guardpost objective.
---
--- @param obj table The guardpost objective to regenerate.
--- @param context table The context in which the effect is being executed.
---
function RegenerateGuardpostObjective:__exec(obj, context)
	SetGuardpostObjectiveRegenerated(self.GuardpostObjective)
end

DefineClass.ReplaceMercEffect = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "ExistingMerc", name = "Existing Merc", help = "Existing merc to replace.", 
			editor = "combo", default = false, items = function (self) return MercPresetCombo() end, },
		{ id = "NewMercDef", name = "New Merc Definition", help = "New merc definition to use for replacement.", 
			editor = "combo", default = false, items = function (self) return MercPresetCombo() end, },
	},
	EditorView = Untranslated("Replace <u(ExistingMerc)> with <u(NewMercDef)> keeping his progress."),
	Documentation = "Replace a merc with another definition while keeping his progress. Example use: switch Larry to Larry_Clean.",
	EditorNestedObjCategory = "Units",
}

---
--- Replaces the specified merc with a new merc definition, keeping the merc's progress.
---
--- @param obj table The object on which the effect is being executed.
--- @param context table The context in which the effect is being executed.
---
function ReplaceMercEffect:__exec(obj, context)
	ReplaceMerc(self.ExistingMerc, self.NewMercDef, "keepInventory")
end

---
--- Checks if the existing merc and new merc definition are set, and returns an error message if either is missing.
---
--- @return string|nil An error message if either the existing merc or new merc definition is missing, otherwise nil.
---
function ReplaceMercEffect:GetError()
	if not self.ExistingMerc then
		return "Choose an existing merc to replace"
	end
	if not self.NewMercDef then
		return "Choose a new merc definition to replace the existing one with"
	end
end

---
--- Generates the UI text for the ReplaceMercEffect.
---
--- @param context table The context in which the effect is being executed.
--- @param template table The template to use for the UI text.
--- @param game table The game object.
--- @return string The generated UI text.
---
function ReplaceMercEffect:GetUIText(context,template, game)
	local merc = gv_UnitData and gv_UnitData[self.Merc]
	local name
	if not merc then
		name = game and "" or Untranslated("[MercName]")
	else
		name = merc.Nick or merc.Name
	end
	return T{246469241790, "Recruit merc (<em><name></em>)", name= name}
end

DefineClass.ResetAmbientLife = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Ephemeral", name = "Ephemeral Only", help = "All ambient life units or just ephemeral ones.", 
			editor = "bool", default = true, },
		{ id = "KickPerpetualUnits", name = "Kick Perpetual Units", help = "If checked perpetual units will be reset too, otherwise they will stay in their markers.", 
			editor = "bool", default = false, },
		{ id = "ForceImmediateKick", name = "Force Immediate Kick", help = "Forces immedite kick so the marker and the unit can be used right away - usually clearing the marker happens after playing exit animation. Anyway if UnitsStealForPerpetualMarkers effect is scheduled right after this one it can not work as expected since it will be called before the destructors and the units/marker will be still busy", 
			editor = "bool", default = false, },
	},
	EditorView = Untranslated("Reset Ambient Life Behavior"),
	Documentation = "Forces all units in ambient life behavior to check the condition of the spot they are using and makes them leave if that condition is not met",
}

---
--- Executes the ResetAmbientLife effect, which forces all units in ambient life behavior to check the condition of the spot they are using and makes them leave if that condition is not met.
---
--- @param obj table The object on which the effect is being executed.
--- @param context table The context in which the effect is being executed.
---
function ResetAmbientLife:__exec(obj, context)
	for _, unit in ipairs(g_Units) do
		if (not self.Ephemeral or unit.ephemeral) and unit:IsVisiting() then
			unit:ResetAmbientLife(self.KickPerpetualUnits, self.ForceImmediateKick)
		end
	end
end

DefineClass.RestoreHealth = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "amount", name = "Amount", 
			editor = "number", default = 9999, },
	},
	RequiredObjClasses = {
	"Unit",
	"UnitData",
},
	EditorView = Untranslated("Restore unit's health"),
	Documentation = "Restores unit's health",
	EditorNestedObjCategory = "Units",
}

---
--- Restores the health of a unit by the specified amount, up to the unit's maximum health.
---
--- @param obj table The unit object on which to restore health.
--- @param context table The context in which the effect is being executed.
---
function RestoreHealth:__exec(obj, context)
	if IsKindOfClasses(obj, "Unit", "UnitData") and not obj:IsDead() then
		obj.HitPoints = Min(obj.MaxHitPoints, obj.HitPoints + self.amount)
	end
end

DefineClass.SatelliteShortcutSetSpeed = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "shortcut_id", 
			editor = "combo", default = false, items = function (self) return PresetsCombo("SatelliteShortcutPreset") end, },
		{ id = "speed_const", help = "The constant denoting the shortcut's speed", 
			editor = "combo", default = "RiverTravelTime", items = function (self) return ConstCategoryToCombo(const.SatelliteShortcut) end, },
	},
	Documentation = "Set the speed of a satellite shortcut",
	EditorNestedObjCategory = "Sector effects",
}

---
--- Sets the speed of a satellite shortcut.
---
--- @param obj table The object on which the effect is being executed (ignored).
--- @param context table The context in which the effect is being executed (ignored).
---
function SatelliteShortcutSetSpeed:__exec(obj, context)
	SatelliteShortcutChangeSpeed(self.shortcut_id, self.speed_const)
end

---
--- Checks if the `shortcut_id` property is set. If not, returns an error message indicating that the shortcut ID needs to be specified.
---
--- @return string|nil An error message if the `shortcut_id` is not set, otherwise `nil`.
---
function SatelliteShortcutSetSpeed:GetError()
	if not self.shortcut_id then
		return "Specify shortcut!"
	end
end

---
--- Returns a string describing the editor view for the SatelliteShortcutUnlockEffect.
---
--- @return string The editor view string.
---
function SatelliteShortcutSetSpeed:GetEditorView()
	if self.enable then
		return Untranslated("Enable satellite shortcut <u(shortcut_id)>", self)
	else
		return Untranslated("Disable satellite shortcut <u(shortcut_id)>", self)
	end
end

DefineClass.SatelliteShortcutUnlockEffect = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "shortcut_id", 
			editor = "combo", default = false, items = function (self) return PresetsCombo("SatelliteShortcutPreset") end, },
		{ id = "enable", 
			editor = "bool", default = true, },
	},
	Documentation = "Enable a satellite shortcut",
	EditorNestedObjCategory = "Sector effects",
}

---
--- Enables or disables a satellite shortcut.
---
--- @param obj table The object on which the effect is being executed (ignored).
--- @param context table The context in which the effect is being executed (ignored).
---
function SatelliteShortcutUnlockEffect:__exec(obj, context)
	SatelliteShortcutSetEnabled(self.shortcut_id, self.enable)
end

---
--- Checks if the `shortcut_id` property is set. If not, returns an error message indicating that the shortcut ID needs to be specified.
---
--- @return string|nil An error message if the `shortcut_id` is not set, otherwise `nil`.
---
function SatelliteShortcutUnlockEffect:GetError()
	if not self.shortcut_id then
		return "Specify shortcut!"
	end
end

---
--- Returns a string describing the editor view for the SatelliteShortcutUnlockEffect.
---
--- @param self SatelliteShortcutUnlockEffect The SatelliteShortcutUnlockEffect instance.
--- @return string The editor view string.
---
function SatelliteShortcutUnlockEffect:GetEditorView()
	if self.enable then
		return Untranslated("Enable satellite shortcut <u(shortcut_id)>", self)
	else
		return Untranslated("Disable satellite shortcut <u(shortcut_id)>", self)
	end
end

DefineClass.ScatterAmbientLife = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	EditorView = Untranslated("Scatter Ambient Life"),
	Documentation = "orders all of the ambient life units on the map (ones spawned from AmbientZones) to stop what they are doing on the spot and trigger the conflict logic.",
}

---
--- Triggers the conflict logic for all ambient life units on the map.
---
--- @param obj table The object on which the effect is being executed (ignored).
--- @param context table The context in which the effect is being executed (ignored).
---
function ScatterAmbientLife:__exec(obj, context)
	ChangeGameState({ConflictScripted=true})
end

DefineClass.SectorAddOperationProgress = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "sector_id", name = "Sector Id", help = "Sector id.", 
			editor = "combo", default = false, items = function (self) return GetCampaignSectorsCombo() end, },
		{ id = "operation", name = "Operation", help = "Operation to add progress to.", 
			editor = "combo", default = false, items = function (self) return table.keys(SectorOperations) end, },
		{ id = "perc", name = "Add Perc", help = "Percent of the target progress that will be added.", 
			editor = "number", default = 0, min = 0, max = 100, },
	},
	Documentation = "Adds progress to a given operation in a given sector",
	EditorView = Untranslated("Adds <percent(perc)> progress to <u(operation)> in sector <u(sector_id)>"),
	EditorNestedObjCategory = "Sector effects",
}

---
--- Boosts the progress of the specified operation in the specified sector.
---
--- @param obj table The object on which the effect is being executed (ignored).
--- @param context table The context in which the effect is being executed (ignored).
---
function SectorAddOperationProgress:__exec(obj, context)
	SectorOperations[self.operation]:BoostProgress(self.perc, gv_Sectors[self.sector_id])
end

---
--- Checks if the `sector_id` property is set. If not, returns an error message.
---
--- @return string|nil An error message if `sector_id` is not set, otherwise `nil`.
---
function SectorAddOperationProgress:GetError()
	if not self.sector_id then
		return "Specify sector!"
	end
end

DefineClass.SectorDisableAutoResolve = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "value", 
			editor = "bool", default = true, },
		{ id = "sector_id", help = "Sector id.", 
			editor = "combo", default = false, items = function (self) return GetCampaignSectorsCombo() end, },
	},
	Documentation = "Enable/Disable auto-resolve on the sector",
}

---
--- Enables or disables auto-resolve on the specified sector.
---
--- @param obj table The object on which the effect is being executed (ignored).
--- @param context table The context in which the effect is being executed (ignored).
---
function SectorDisableAutoResolve:__exec(obj, context)
	local sector = gv_Sectors[self.sector_id]
	if sector then
		sector.autoresolve_disabled = not self.value
	end
end

---
--- Generates the editor view text for the SectorDisableAutoResolve effect.
---
--- @param self table The SectorDisableAutoResolve effect instance.
--- @return string The editor view text.
---
function SectorDisableAutoResolve:GetEditorView()
	if self.value then
		return Untranslated("Enable auto-resolve for sector <u(sector_id)>")
	else
		return Untranslated("Disable auto-resolve for sector <u(sector_id)>")
	end
end

---
--- Checks if the `sector_id` property is set. If not, returns an error message.
---
--- @return string|nil An error message if `sector_id` is not set, otherwise `nil`.
---
function SectorDisableAutoResolve:GetError()
	if not self.sector_id then
		return "Specify sector!"
	end
end

DefineClass.SectorEnableAutoDeploy = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "deploy", help = "Enable/disable auto-deploy on enter.", 
			editor = "bool", default = true, },
		{ id = "sector_id", help = "Sector id.", 
			editor = "combo", default = false, items = function (self) return GetCampaignSectorsCombo() end, },
	},
	Documentation = "Enable/Disable auto-deploy mode on sector enter",
}

---
--- Enables or disables auto-deploy mode on the specified sector.
---
--- @param obj table The object on which the effect is being executed (ignored).
--- @param context table The context in which the effect is being executed (ignored).
---
function SectorEnableAutoDeploy:__exec(obj, context)
	local sector = gv_Sectors[self.sector_id]
	if sector then
		sector.enabled_auto_deploy = self.deploy
	end
end

---
--- Generates the editor view text for the SectorEnableAutoDeploy effect.
---
--- @param self table The SectorEnableAutoDeploy effect instance.
--- @return string The editor view text.
---
function SectorEnableAutoDeploy:GetEditorView()
	if self.deploy then
		return Untranslated("Enable auto-deploy for sector <u(sector_id)>")
	else
		return Untranslated("Disable auto-deploy for sector <u(sector_id)>")
	end
end

---
--- Checks if the `sector_id` property is set. If not, returns an error message.
---
--- @return string|nil An error message if `sector_id` is not set, otherwise `nil`.
---
function SectorEnableAutoDeploy:GetError()
	if not self.sector_id then
		return "Specify sector!"
	end
end

DefineClass.SectorEnableCustomOperation = {
	__parents = { "Effect", "LootTableFunctionObjectBase", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "sector_id", name = "Sector", help = "Sector id.", 
			editor = "combo", default = false, items = function (self) return GetCampaignSectorsCombo() end, },
		{ id = "operation", name = "Operation", help = "Custom operation.", 
			editor = "combo", default = false, items = function (self) return GetCustomOperations() end, },
		{ id = "DisplayLog", name = "Display in Log", help = "Whether to display enabling the Operation in the combat log", 
			editor = "bool", default = false, },
		{ category = "Execution", id = "EffectsOnSuccess", name = "On Success", help = "Effects that are executed after the operation is completed.", 
			editor = "nested_list", default = false, base_class = "Effect", },
		{ category = "Execution", id = "LootTableId", name = "Loot Table Id", help = "Loot table to generate items that will be granted after the operation is completed.", 
			editor = "preset_id", default = false, preset_class = "LootDef", },
		{ category = "Execution", id = "GrantItemApply", name = "GrantItemApply", help = 'Loot table roll -  "first"(merc) - only once, "all"(mercs) for each merc', 
			editor = "combo", default = "first", items = function (self) return {"first", "all"} end, },
	},
	Documentation = "Enables custom operation in the sector",
	EditorView = Untranslated("Enables custom Operation <u(operation)> in sector <u(sector_id)>"),
	EditorNestedObjCategory = "Sector effects",
}

---
--- Enables a custom operation in the specified sector.
---
--- @param obj table The object instance.
--- @param context table The execution context.
---
function SectorEnableCustomOperation:__exec(obj, context)
	local sector = gv_Sectors[self.sector_id]
	if not sector then return end
	
	sector.custom_operations = sector.custom_operations or {}
	sector.custom_operations[self.operation] = {
		status = "enabled",
		progress = 0,
		EffectsOnSuccess = self.EffectsOnSuccess,
		LootTableId = self.LootTableId,
		GrantItemApply = self.GrantItemApply
	}
	ObjModified(sector)
	ObjModified(gv_Squads)
	
	if self.DisplayLog then 
		CombatLog("important",T{537039992460, "New <em>Sector Operation</em> available (<em><SectorId(sector)></em>): <em><ActivityName></em>", ActivityName = SectorOperations[self.operation] and SectorOperations[self.operation].display_name or "", sector = self.sector_id})
	end
end

---
--- Returns an error message if the sector ID or custom operation is not specified.
---
--- @return string|nil Error message if there is an issue, nil otherwise.
---
function SectorEnableCustomOperation:GetError()
	if not self.sector_id then
		return "Specify sector!"
	elseif not self.operation then
		return "Specify custom operation!"
	end
end

---
--- Returns a rollover text for the operation available in the sector.
---
--- @param negative boolean Whether the rollover text should be displayed in a negative context.
--- @param template string The template to use for the rollover text.
--- @param game table The game context.
--- @return string The rollover text for the operation.
---
function SectorEnableCustomOperation:GetPhraseTopRolloverText(negative, template, game)
	return T{588881082990, "Operation is available: <em><ActivityName></em>", ActivityName = SectorOperations[self.operation] and SectorOperations[self.operation].display_name or ""}
end

DefineClass.SectorEnableWarningState = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Enable", name = "Enable", help = "Enable", 
			editor = "bool", default = true, },
		{ id = "sector_id", name = "Sector Id", help = "Sector id.", 
			editor = "combo", default = "current", items = function (self) return table.iappend({{text="current",value="current"}}, GetCampaignSectorsCombo()) end, },
	},
	Documentation = "Enable/Disable the Warning State mechanic for sector. (does NOT trigger it)",
	EditorView = Untranslated("Change <u(sector_id)> sector's WarningStateEnabled to <Bool(Enable)>. (does NOT trigger it)"),
	EditorNestedObjCategory = "Sector effects",
}

---
--- Enables or disables the warning state mechanic for the specified sector.
---
--- @param obj table The object that the effect is being executed on.
--- @param context table The context in which the effect is being executed.
---
function SectorEnableWarningState:__exec(obj, context)
	local sector_id = self.sector_id == "current" and gv_CurrentSectorId or self.sector_id
	local sector = gv_Sectors[sector_id]
	sector.warningStateEnabled = self.Enable
end

DefineClass.SectorEnterConflict = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "conflict_mode", help = "Force or resolve conflict in that sector.", 
			editor = "bool", default = true, },
		{ id = "sector_id", help = "Sector id.", 
			editor = "combo", default = false, items = function (self) return table.iappend({{text="current",value="current"}}, GetCampaignSectorsCombo()) end, },
		{ id = "disable_travel", help = "Disables all travel zones on the map.", 
			editor = "bool", default = false, },
		{ id = "lock_conflict", help = "Killing all enemies on the map cannot resolve a locked conflict, only scripts can.", 
			editor = "bool", default = false, },
		{ id = "no_exploration_resolve", help = "dont resolve conflict in exploration", 
			editor = "bool", default = false, },
		{ id = "descr_id", help = 'This text is displayed when the "Conflict" text is rolled over and in the description of the conflict window. Define texts in the conflict descriptions editor.', 
			editor = "combo", default = false, items = function (self) return PresetGroupCombo("ConflictDescription", "Default") end, },
		{ id = "spawn_mode", 
			editor = "combo", default = false, items = function (self) return {"attack", "defend", "explore"} end, },
	},
	Documentation = "Forces/Resolve conflict mode for the speciafied sector",
	EditorNestedObjCategory = "Sector effects",
}

---
--- Executes the SectorEnterConflict effect.
---
--- @param obj table The object that the effect is being executed on.
--- @param context table The context in which the effect is being executed.
---
function SectorEnterConflict:__exec(obj, context)
	local sector = self.sector_id == "current" and gv_Sectors[gv_CurrentSectorId] or gv_Sectors[self.sector_id]
	if not sector then return end
	if self.conflict_mode then
		ForceEnterConflictEffect(
				sector,
				self.spawn_mode,
				self.disable_travel,
				self.lock_conflict,
				self.descr_id,
				self.no_exploration_resolve and "force-exploration-only" or "force"
			)
	else
		sector.ForceConflict = false
		if gv_Sectors[gv_CurrentSectorId] == sector then
			if sector.conflict then
				sector.conflict.locked = false
			end
			CheckMapConflictResolved("no voice")
		else
			ResolveConflict(sector, "no voice")
		end
	end
end

---
--- Gets the editor view for the SectorEnterConflict effect.
---
--- @return string The editor view text for the effect.
---
function SectorEnterConflict:GetEditorView()
	if self.conflict_mode then
		return Untranslated("Force conflict mode for sector <u(sector_id)>")
	else
		return Untranslated("Remove forced conflict mode for sector <u(sector_id)>")
	end
end

---
--- Gets the error message for the SectorEnterConflict effect if the sector ID is not specified.
---
--- @return string The error message to display in the editor.
---
function SectorEnterConflict:GetError()
	if not self.sector_id then
		return "Specify sector!"
	end
end

DefineClass.SectorGrantIntel = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "sector_id", help = "Sector id.", 
			editor = "combo", default = false, items = function (self) return GetCampaignSectorsCombo() end, },
	},
	Documentation = "Grants intel for the sector",
	EditorView = Untranslated("Grant intel for sector <u(sector_id)>"),
	EditorNestedObjCategory = "Sector effects",
}

---
--- Executes the SectorGrantIntel effect, which grants intel for the specified sector.
---
--- @param obj table The object that the effect is being executed on.
--- @param context table The context in which the effect is being executed.
---
function SectorGrantIntel:__exec(obj, context)
	DiscoverIntelForSector(self.sector_id)
end

---
--- Gets the error message for the SectorGrantIntel effect if the sector ID is not specified.
---
--- @return string The error message to display in the editor.
---
function SectorGrantIntel:GetError()
	if not self.sector_id then
		return "Specify sector!"
	end
end

---
--- Gets the rollover text for the SectorGrantIntel effect, which displays information about the intel granted for a sector.
---
--- @param negative boolean Whether the rollover text should be for a negative effect.
--- @param template string The template to use for the rollover text.
--- @param game table The current game object.
--- @return string The rollover text to display.
---
function SectorGrantIntel:GetPhraseTopRolloverText(negative, template, game)
	local campaign = CampaignPresets[Game and Game.Campaign or DefaultCampaign]
	local sector = gv_Sectors and gv_Sectors[self.sector_id] or table.find_value(campaign.Sectors, "Id", self.sector_id)
	
	if sector and sector.intel_discovered then
		return T{903574434021, "<em>Intel</em> is already available for <em><SectorName(sector)></em>", sector = sector}
	end
	
	return T{223883822777, "Gained <em>Intel</em> for <em><SectorName(sector)></em>", sector = sector}
end

DefineClass.SectorModifyEnemySquads = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "sector_id", name = "Sector", help = "Sector id.", 
			editor = "combo", default = false, items = function (self) return GetCampaignSectorsCombo() end, },
		{ id = "percent", name = "Percent", help = "Percent for enemy count modification.", 
			editor = "number", default = 0, },
		{ id = "count", name = "Count", help = "Specific count for enemy count modification.", 
			editor = "number", default = 0, },
		{ id = "UnitTemplate", name = "UnitTemplate", help = "Unit template that will be affected or all if false.", 
			editor = "combo", default = false, items = function (self) return GetEnemySquadsUnitTemplates("all") end, },
	},
	Documentation = "The spawned enemy squads in that sector get their units or specified type of units decreased or increased by that specified percent. To remove all units from unittype, set pecent to -100",
	EditorNestedObjCategory = "Sector effects",
}

---
--- Modifies the enemy squads in the specified sector.
---
--- @param obj table The object that the effect is being applied to.
--- @param context table The context in which the effect is being executed.
---
function SectorModifyEnemySquads:__exec(obj, context)
	local value, valueType = self.percent, "percent"
	local count = self.count
	if count and count ~= 0 then
		value = count
		valueType = "count"
	end
	ModifySectorEnemySquads(self.sector_id, value, valueType, self.UnitTemplate)
end

---
--- Generates the editor view text for the SectorModifyEnemySquads effect.
---
--- @param self table The SectorModifyEnemySquads effect instance.
--- @return string The editor view text.
---
function SectorModifyEnemySquads:GetEditorView()
	local value, valueType = self.percent, "percent"
	local count = self.count
	if count and count ~= 0 then
		value = count
		valueType = "count"
	end
	local valString = valueType == "percent" and (tostring(value) .. "%") or tostring(value)
	
	if value > 0 then
		if self.UnitTemplate then
			return Untranslated("Increases <u(UnitTemplate)> units in enemy squads force in <u(sector_id)> by " .. valString)
		else
			return Untranslated("Increases all enemies in <u(sector_id)> by ".. valString)
		end
	else
		if self.UnitTemplate then
			return Untranslated("Decreases <u(UnitTemplate)> units in enemy squads force in <u(sector_id)> by " .. valString)
		else
			return Untranslated("Decreases all enemies in <u(sector_id)> by " .. valString)
		end
	end
end

---
--- Checks if the `sector_id` property is set for the `SectorModifyEnemySquads` effect.
---
--- @return string|nil An error message if the `sector_id` property is not set, otherwise `nil`.
---
function SectorModifyEnemySquads:GetError()
	if not self.sector_id then
		return "Specify sector!"
	end
end

DefineClass.SectorModifyMineProperties = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "DepletionTime", name = "Depletion Income Modifier Percent", help = "% modifier for depletion time", 
			editor = "number", default = false, min = 1, max = 500, },
		{ id = "DailyIncome", name = "Daily Income Modifier Percent", help = "% modifier for profit per day at 100% loyalty. For instance 200 would double, and 50 would halve", 
			editor = "number", default = false, min = 0, max = 1000, },
		{ id = "sector_id", help = "Sector id.", 
			editor = "combo", default = false, items = function (self) return GetCampaignSectorsCombo() end, },
	},
	Documentation = "Modify diamond mine properties for a given sector",
	EditorNestedObjCategory = "Sector effects",
}

---
--- Executes the `SectorModifyMineProperties` effect, modifying the depletion time and daily income of a sector's diamond mines.
---
--- @param obj table The object instance of the `SectorModifyMineProperties` class.
--- @param context table The execution context.
---
function SectorModifyMineProperties:__exec(obj, context)
	local sector = gv_Sectors[self.sector_id]
	
	if self.DepletionTime then
		if not sector.depletion_mods then sector.depletion_mods = {} end
		sector.depletion_mods[#sector.depletion_mods + 1] = self.DepletionTime
	end
	
	if self.DailyIncome then
		if not sector.income_mods then sector.income_mods = {} end
		sector.income_mods[#sector.income_mods + 1] = self.DailyIncome
	end
end

---
--- Generates the editor view for the `SectorModifyMineProperties` effect.
---
--- @return string The editor view string.
---
function SectorModifyMineProperties:GetEditorView()
	return Untranslated("Modify diamond mine related properties on <sector_id>")
end

---
--- Checks if the `sector_id` property is set on the `SectorModifyMineProperties` object. If not, returns an error message.
---
--- @param self table The `SectorModifyMineProperties` object instance.
--- @return string The error message if `sector_id` is not set, otherwise `nil`.
---
function SectorModifyMineProperties:GetError()
	if not self.sector_id then
		return "Specify sector!"
	end
end

---
--- Generates the top rollover text for the `SectorModifyMineProperties` effect.
---
--- @param negative boolean Whether the rollover text should be for a negative effect.
--- @param template string The rollover text template.
--- @param game table The game object.
--- @return string The generated rollover text.
---
function SectorModifyMineProperties:GetPhraseTopRolloverText(negative, template, game)
	if self.DailyIncome and next(gv_Sectors) then
		local name = gv_Sectors[self.sector_id].display_name
		if self.DailyIncome > 100 then
			return T{830978589245, "<Name> diamond production increased by <(value -100)>%", value = self.DailyIncome, Name = name}
		end	
		if self.DailyIncome<100 then 
			return T{340934605682, "<Name> diamond production decreased by <(100-value)>%", value = self.DailyIncome, Name = name}
		end
	end
end

DefineClass.SectorRemoveCustomOperation = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "sector_id", name = "Sector", help = "Sector id.", 
			editor = "combo", default = false, items = function (self) return GetCampaignSectorsCombo() end, },
		{ id = "operation", name = "Operation", help = "Remove custom operation.", 
			editor = "combo", default = false, items = function (self) return GetCustomOperations() end, },
	},
	Documentation = "Removes custom operation in the sector, sets operation mercs to Idle",
	EditorView = Untranslated("Removes custom Operation <u(operation)> in sector <u(sector_id)>"),
	EditorNestedObjCategory = "Sector effects",
}

---
--- Removes a custom operation from a sector and sets the operation mercs to Idle.
---
--- @param obj table The object instance.
--- @param context table The execution context.
---
function SectorRemoveCustomOperation:__exec(obj, context)
	local sector = gv_Sectors[self.sector_id]
	if not sector then return end
	
	local operation = self.operation
	if sector.custom_operations and sector.custom_operations[operation] then
		sector.custom_operations[operation] = nil
	end
	local mercs = GetPlayerSectorUnits(self.sector_id)
	SectorOperation_CancelByGame(mercs, operation, true)
	
	ObjModified(sector)
	ObjModified(gv_Squads)
end

---
--- Checks if the sector ID and custom operation are specified for the SectorRemoveCustomOperation effect.
---
--- @return string|nil The error message if the sector ID or custom operation is not specified, otherwise nil.
---
function SectorRemoveCustomOperation:GetError()
	if not self.sector_id then
		return "Specify sector!"
	elseif not self.operation then
		return "Specify custom operation!"
	end
end

---
--- Returns the top rollover text for the SectorRemoveCustomOperation effect.
---
--- @param negative boolean Whether the rollover text should be for a negative state.
--- @param template string The template to use for the rollover text.
--- @param game table The game context.
--- @return string The formatted rollover text.
---
function SectorRemoveCustomOperation:GetPhraseTopRolloverText(negative, template, game)
	return T{565334741205, "<ActivityName> Operation is unavailable", ActivityName = SectorOperations[self.operation] and SectorOperations[self.operation].display_name or ""}
end

DefineClass.SectorReplaceEnemySquadList = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "sector_id", name = "Sector Id", help = "Sector id.", 
			editor = "combo", default = false, items = function (self) return GetCampaignSectorsCombo() end, },
		{ id = "EnemySquadsList", name = "Enemy Squads List", help = "A random squad from the list will be chosen on guardpost spawn time.", 
			editor = "preset_id_list", default = {}, preset_class = "EnemySquads", preset_filter = function (preset, obj, prop_meta)
	if preset.group ~= "Test Encounters" then return obj end
end, 
item_default = "", },
		{ id = "StrongEnemySquadsList", name = "Strong Enemy Squads List", 
			editor = "preset_id_list", default = {}, preset_class = "EnemySquads", preset_filter = function (preset, obj, prop_meta)
	if preset.group ~= "Test Encounters" then return obj end
end, 
item_default = "", },
		{ id = "ExtraDefenderSquads", name = "Extra Defender Squads", 
			editor = "preset_id_list", default = {}, preset_class = "EnemySquads", preset_filter = function (preset, obj, prop_meta)
	if preset.group ~= "Test Encounters" then return obj end
end, 
item_default = "", },
	},
	EditorView = Untranslated("Overrides EnemySquadList in sector <u(sector_id)>"),
	Documentation = "Overrides EnemySquadList in a given sector",
	EditorNestedObjCategory = "Sector effects",
}

---
--- Executes the SectorReplaceEnemySquadList effect, overriding the EnemySquadsList, StrongEnemySquadsList, and ExtraDefenderSquads properties of the specified sector.
---
--- @param obj table The object instance of the SectorReplaceEnemySquadList effect.
--- @param context table The execution context.
---
function SectorReplaceEnemySquadList:__exec(obj, context)
	local sector = gv_Sectors[self.sector_id]
	if not sector then return end
	
	if sector.EnemySquadsList and #sector.EnemySquadsList > 0 then
		sector.EnemySquadsList = table.copy(self.EnemySquadsList)
	end
	if sector.StrongEnemySquadsList and #sector.StrongEnemySquadsList > 0 then
		sector.StrongEnemySquadsList = table.copy(self.StrongEnemySquadsList)
	end
	if sector.ExtraDefenderSquads and #sector.ExtraDefenderSquads > 0 then
		sector.ExtraDefenderSquads = table.copy(self.ExtraDefenderSquads)
	end
end

--- Returns an error message if the `sector_id` property is not set.
---
--- This function is a helper method for the `SectorReplaceEnemySquadList` class, which is used to override the enemy squad lists in a given sector. If the `sector_id` property is not set, this function will return an error message indicating that the sector must be specified.
---
--- @return string|nil An error message if the `sector_id` property is not set, or `nil` if it is set.
function SectorReplaceEnemySquadList:GetError()
	if not self.sector_id then
		return "Specify sector!"
	end
end

DefineClass.SectorReplaceTargetSectors = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "sector_id", name = "Sector Id", help = "Sector id.", 
			editor = "combo", default = false, items = function (self) return GetCampaignSectorsCombo() end, },
		{ id = "TargetSectors", name = "Target Sectors", help = "Target sectors for spawned enemy squads.", 
			editor = "string_list", default = {}, item_default = "", items = function (self) return GetCampaignSectorsCombo("") end, },
	},
	EditorView = Untranslated("Overrides TargetSectors in a given sector"),
	Documentation = "Overrides TargetSectors in a given sector",
	EditorNestedObjCategory = "Sector effects",
}

---
--- Executes the SectorReplaceTargetSectors effect, overriding the TargetSectors property of the specified sector.
---
--- @param obj table The object instance of the SectorReplaceTargetSectors effect.
--- @param context table The execution context.
---
function SectorReplaceTargetSectors:__exec(obj, context)
	local sector = gv_Sectors[self.sector_id]
	if sector then
		sector.TargetSectors = table.copy(self.TargetSectors, "deep")
	end
end

--- Returns an error message if the `sector_id` property is not set.
---
--- This function is a helper method for the `SectorReplaceTargetSectors` class, which is used to override the target sectors in a given sector. If the `sector_id` property is not set, this function will return an error message indicating that the sector must be specified.
---
--- @return string|nil An error message if the `sector_id` property is not set, or `nil` if it is set.
function SectorReplaceTargetSectors:GetError()
	if not self.sector_id then
		return "Specify sector!"
	end
end

DefineClass.SectorSetAwarenessSequence = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "sector_id", help = "Sector id.", 
			editor = "combo", default = false, items = function (self) return GetCampaignSectorsCombo() end, },
		{ id = "awareness_sequence", name = "Awareness Sequence", 
			editor = "choice", default = "Standard", items = function (self) return { "Standard", "Skip Setpiece", "Skip All" } end, },
	},
	Documentation = "Enable/Disable auto-deploy mode on sector enter",
}

---
--- Executes the SectorSetAwarenessSequence effect, setting the awareness sequence for the specified sector.
---
--- @param obj table The object instance of the SectorSetAwarenessSequence effect.
--- @param context table The execution context.
---
function SectorSetAwarenessSequence:__exec(obj, context)
	local sector = gv_Sectors[self.sector_id]
	if sector then
		sector.awareness_sequence = self.awareness_sequence
	end
end

---
--- Returns a string representation of the editor view for the SectorSetAwarenessSequence effect.
---
--- This function is used to generate the editor view for the SectorSetAwarenessSequence effect, which is used to set the awareness sequence for a specified sector. The function returns a string that includes the sector ID and the selected awareness sequence.
---
--- @return string The editor view string for the SectorSetAwarenessSequence effect.
function SectorSetAwarenessSequence:GetEditorView()
	return Untranslated(string.format("Set Awareness Sequence for for sector <u(sector_id)> to %s", self.awareness_sequence))
end

--- Returns an error message if the `sector_id` property is not set.
---
--- This function is a helper method for the `SectorReplaceTargetSectors` class, which is used to override the target sectors in a given sector. If the `sector_id` property is not set, this function will return an error message indicating that the sector must be specified.
---
--- @return string|nil An error message if the `sector_id` property is not set, or `nil` if it is set.
function SectorSetAwarenessSequence:GetError()
	if not self.sector_id then
		return "Specify sector!"
	end
end

DefineClass.SectorSetCustomConflictDesc = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "sector_id", help = "Sector id.", 
			editor = "combo", default = false, items = function (self) return GetCampaignSectorsCombo() end, },
		{ id = "descr_id", help = 'This text is displayed when the "Conflict" text is rolled over and in the description of the conflict window. Define texts in the conflict descriptions editor.', 
			editor = "combo", default = false, items = function (self) return PresetGroupCombo("ConflictDescription", "Default") end, },
	},
	Documentation = "Set a custom conflict description for the given sector. Cleared when the conflict is resolved.",
	EditorNestedObjCategory = "Sector effects",
}

---
--- Executes the SectorSetCustomConflictDesc effect, setting a custom conflict description for the specified sector.
---
--- This function is called when the SectorSetCustomConflictDesc effect is executed. It sets the CustomConflictDescr property of the specified sector to the descr_id value. If the sector is currently in conflict and does not have a descr_id set, it also sets the descr_id property of the sector's conflict.
---
--- @param obj table The object instance of the SectorSetCustomConflictDesc effect.
--- @param context table The execution context.
---
function SectorSetCustomConflictDesc:__exec(obj, context)
	local sector = gv_Sectors[self.sector_id]
	
	sector.CustomConflictDescr = self.descr_id
	if sector.conflict and not sector.conflict.descr_id then
		sector.conflict.descr_id = self.descr_id
	end
end

---
--- Returns the editor view string for the SectorSetCustomConflictDesc effect.
---
--- This function is used to generate the editor view for the SectorSetCustomConflictDesc effect, which is used to set a custom conflict description for a specified sector. The function returns a string that includes the sector ID and the selected conflict description preset.
---
--- @return string The editor view string for the SectorSetCustomConflictDesc effect.
function SectorSetCustomConflictDesc:GetEditorView()
	return Untranslated("Set conflict description <u(descr_id)> for <u(sector_id)>")
end

---
--- Returns an error message if the `sector_id` or `descr_id` properties are not set.
---
--- This function is a helper method for the `SectorSetCustomConflictDesc` class, which is used to set a custom conflict description for a specified sector. If the `sector_id` or `descr_id` properties are not set, this function will return an error message indicating that the sector and/or description preset must be specified.
---
--- @return string|nil An error message if the `sector_id` or `descr_id` properties are not set, or `nil` if they are set.
function SectorSetCustomConflictDesc:GetError()
	if not self.sector_id then
		return "Specify sector!"
	end
	if not self.descr_id then
		return "Specify description preset!"
	end
end

DefineClass.SectorSetForceConflict = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "sector_id", name = "Sector Id", help = "Sector id.", 
			editor = "combo", default = false, items = function (self) return GetCampaignSectorsCombo() end, },
		{ id = "force", name = "Force Conflict", help = "Force conflict value.", 
			editor = "bool", default = false, },
	},
	Documentation = "Enable/Disable 'force conflict' for the sector - entering sectors with force conflict set to true results in conflict mode with or without enemy presence in the sector",
	EditorNestedObjCategory = "Sector effects",
}

---
--- Sets the 'force conflict' flag for the specified sector.
---
--- This function is part of the `SectorSetForceConflict` effect, which is used to enable or disable the 'force conflict' flag for a specified sector. When the 'force conflict' flag is set to true, entering the sector will result in conflict mode, regardless of whether there are any enemies present.
---
--- @param obj table The object instance of the `SectorSetForceConflict` effect.
--- @param context table The execution context.
function SectorSetForceConflict:__exec(obj, context)
	if not gv_Sectors[self.sector_id] then return end
	gv_Sectors[self.sector_id].ForceConflict = self.force
end

---
--- Returns the editor view string for the SectorSetForceConflict effect.
---
--- This function is used to generate the editor view for the SectorSetForceConflict effect, which is used to enable or disable the 'force conflict' flag for a specified sector. The function returns a string that includes the sector ID and whether the 'force conflict' flag is enabled or disabled.
---
--- @param self table The object instance of the SectorSetForceConflict effect.
--- @return string The editor view string for the SectorSetForceConflict effect.
function SectorSetForceConflict:GetEditorView()
	if self.force then
		return Untranslated("Enable sector <u(sector_id)> force conflict")
	else
		return Untranslated("Disable sector <u(sector_id)> force conflict")
	end
end

---
--- Returns an error message if the `sector_id` property is not set.
---
--- This function is part of the `SectorSetForceConflict` effect, which is used to enable or disable the 'force conflict' flag for a specified sector. If the `sector_id` property is not set, this function will return an error message indicating that the sector must be specified.
---
--- @return string The error message if the `sector_id` property is not set.
function SectorSetForceConflict:GetError()
	if not self.sector_id then
		return "Specify sector!"
	end
end

DefineClass.SectorSetHospital = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "enable", help = "Add/remove hospital in sector.", 
			editor = "bool", default = true, },
		{ id = "sector_id", help = "Sector id.", 
			editor = "combo", default = false, items = function (self) return GetCampaignSectorsCombo() end, },
	},
	Documentation = "Enable/disable hospital in specified sector",
	EditorNestedObjCategory = "Sector effects",
}

---
--- Enables or disables the hospital in the specified sector.
---
--- This function is part of the `SectorSetHospital` effect, which is used to enable or disable the hospital in a specified sector. When the `enable` property is set to `true`, the hospital is enabled in the sector. When it is set to `false`, the hospital is disabled.
---
--- @param obj table The object instance of the `SectorSetHospital` effect.
--- @param context table The execution context.
function SectorSetHospital:__exec(obj, context)
	local sector = gv_Sectors[self.sector_id]
	sector.HospitalLocked = not self.enable
	sector.Hospital = true -- Legacy
	Msg("BuildingLockChanged", self.sector_id)
end

---
--- Returns the top rollover text for the hospital treatment operation.
---
--- This function is part of the `SectorSetHospital` effect, which is used to enable or disable the hospital in a specified sector. The `GetPhraseTopRolloverText` function returns the top rollover text for the hospital treatment operation, which is displayed in the game UI.
---
--- @param negative boolean Whether the operation is a negative one.
--- @param template string The template for the rollover text.
--- @param game table The game context.
--- @return string The top rollover text for the hospital treatment operation.
function SectorSetHospital:GetPhraseTopRolloverText(negative, template, game)
	return T{588881082990, "Operation is available: <em><ActivityName></em>", ActivityName = SectorOperations["HospitalTreatment"] and SectorOperations["HospitalTreatment"].display_name or ""}
end

---
--- Returns the editor view text for the SectorSetHospital effect.
---
--- This function is part of the `SectorSetHospital` effect, which is used to enable or disable the hospital in a specified sector. The `GetEditorView` function returns the text that is displayed in the editor view for this effect.
---
--- @param self table The object instance of the `SectorSetHospital` effect.
--- @return string The editor view text for the SectorSetHospital effect.
function SectorSetHospital:GetEditorView()
	if self.enable then
		return Untranslated("Enable hospital in sector <u(sector_id)>")
	else
		return Untranslated("Disable hospital in sector <u(sector_id)>")
	end
end

---
--- Checks if the `sector_id` property is set for the `SectorSetHospital` effect.
---
--- This function is part of the `SectorSetHospital` effect, which is used to enable or disable the hospital in a specified sector. The `GetError` function checks if the `sector_id` property is set, and returns an error message if it is not.
---
--- @param self table The object instance of the `SectorSetHospital` effect.
--- @return string The error message if the `sector_id` property is not set.
function SectorSetHospital:GetError()
	if not self.sector_id then
		return "Specify sector!"
	end
end

DefineClass.SectorSetMap = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "sector_id", name = "Sector Id", help = "Sector id.", 
			editor = "combo", default = false, items = function (self) return GetCampaignSectorsCombo() end, },
		{ id = "MapFile", 
			editor = "combo", default = "", items = function (self) return ListMaps() end, },
		{ id = "image", 
			editor = "ui_image", default = false, },
		{ id = "loading_screen", 
			editor = "ui_image", default = false, },
	},
	Documentation = "Change the map of a sector",
	EditorNestedObjCategory = "Sector effects",
}

---
--- Executes the SectorSetMap effect, which changes the map of a specified sector.
---
--- This function is part of the `SectorSetMap` effect, which is used to change the map of a specified sector. The `__exec` function is responsible for actually applying the effect by updating the `Map`, `image`, and `override_loading_screen` properties of the sector preset.
---
--- @param self table The object instance of the `SectorSetMap` effect.
--- @param obj table The object that the effect is being applied to.
--- @param context table The context in which the effect is being executed.
function SectorSetMap:__exec(obj, context)
	local sectorPreset = gv_Sectors[self.sector_id]
	if sectorPreset then
		sectorPreset.Map = self.MapFile
		
		if self.image and self.image ~= "" then
			sectorPreset.image = self.image
		end
		
		if self.loading_screen and self.loading_screen ~= "" then
			sectorPreset.override_loading_screen = self.loading_screen
		end
	end
end

---
--- Returns a string that describes the editor view for the SectorSetMap effect.
---
--- This function is part of the `SectorSetMap` effect, which is used to change the map of a specified sector. The `GetEditorView` function returns a string that describes the effect in the editor, showing the sector ID and the map file that will be set.
---
--- @param self table The object instance of the `SectorSetMap` effect.
--- @return string The editor view description for the `SectorSetMap` effect.
function SectorSetMap:GetEditorView()
	return Untranslated("Change the sector map of <u(sector_id)> to <u(MapFile)>", self)
end

---
--- Checks for errors in the SectorSetMap effect.
---
--- This function is part of the `SectorSetMap` effect, which is used to change the map of a specified sector. The `GetError` function checks for any errors in the effect, such as missing sector ID or conflicting settings.
---
--- @param self table The object instance of the `SectorSetMap` effect.
--- @return string The error message, or `nil` if there are no errors.
function SectorSetMap:GetError()
	if not self.sector_id then
		return "Specify sector!"
	elseif self.enable_sticky and self.disable_sticky then
		return "You cannot both enable and disable sticky side, choose one"
	end
end

DefineClass.SectorSetMilitia = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "enable", help = "Set militia in sector.", 
			editor = "bool", default = true, },
		{ id = "sector_id", help = "Sector id.", 
			editor = "combo", default = false, items = function (self) return GetCampaignSectorsCombo() end, },
	},
	Documentation = "Enable/disable militia in specified sector",
	EditorNestedObjCategory = "Sector effects",
}

---
--- Sets the militia status of the specified sector.
---
--- This function is part of the `SectorSetMilitia` effect, which is used to enable or disable the militia in a specified sector. The `__exec` function sets the `Militia` property of the sector to the value of the `enable` property of the `SectorSetMilitia` effect.
---
--- @param obj table The object instance of the `SectorSetMilitia` effect.
--- @param context table The context in which the effect is being executed.
function SectorSetMilitia:__exec(obj, context)
	gv_Sectors[self.sector_id].Militia = self.enable
end

---
--- Returns a string that describes the editor view for the SectorSetMilitia effect.
---
--- This function is part of the `SectorSetMilitia` effect, which is used to enable or disable the militia in a specified sector. The `GetEditorView` function returns a string that describes the effect in the editor, showing whether the militia is being enabled or disabled in the specified sector.
---
--- @param self table The object instance of the `SectorSetMilitia` effect.
--- @return string The editor view description for the `SectorSetMilitia` effect.
function SectorSetMilitia:GetEditorView()
	if self.enable then
		return Untranslated("Enable militia in sector <u(sector_id)>")
	else
		return Untranslated("Disable militia in sector <u(sector_id)>")
	end
end

---
--- Returns an error message if the `sector_id` property is not set.
---
--- This function is part of the `SectorSetMilitia` effect, which is used to enable or disable the militia in a specified sector. The `GetError` function checks if the `sector_id` property is set, and if not, returns an error message.
---
--- @param self table The object instance of the `SectorSetMilitia` effect.
--- @return string The error message, or `nil` if there are no errors.
function SectorSetMilitia:GetError()
	if not self.sector_id then
		return "Specify sector!"
	end
end

DefineClass.SectorSetMineProperties = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Depletion", 
			editor = "combo", default = "no-change", items = function (self) return { "no-change", "enabled", "disabled" } end, },
		{ id = "HasMine", 
			editor = "combo", default = "no-change", items = function (self) return { "no-change", "enabled", "disabled" } end, },
		{ id = "DepletionTime", help = "In how many days the mine will deplete", 
			editor = "number", default = false, min = 1, max = 500, },
		{ id = "DailyIncome", help = "Profit per day at 100% loyalty", 
			editor = "number", default = false, min = 0, },
		{ id = "sector_id", help = "Sector id.", 
			editor = "combo", default = false, items = function (self) return GetCampaignSectorsCombo() end, },
	},
	Documentation = "Set diamond mine properties for a given sector.",
	EditorNestedObjCategory = "Sector effects",
}

---
--- Executes the `SectorSetMineProperties` effect, which sets various properties of a diamond mine in a specified sector.
---
--- This function is responsible for updating the properties of a diamond mine in a sector based on the values set in the `SectorSetMineProperties` effect. It checks the values of the `Depletion`, `HasMine`, `DepletionTime`, and `DailyIncome` properties, and updates the corresponding properties of the sector's diamond mine accordingly.
---
--- @param self table The object instance of the `SectorSetMineProperties` effect.
--- @param obj table The object that the effect is being applied to.
--- @param context table The context in which the effect is being executed.
function SectorSetMineProperties:__exec(obj, context)
	local sector = gv_Sectors[self.sector_id]
	if self.Depletion ~= "no-change" then
		sector.Depletion = self.Depletion == "enabled"
	end
	
	if self.HasMine ~= "no-change" then
		sector.Mine = self.HasMine == "enabled"
	end
	
	if self.DepletionTime then
		sector.DepletionTime = self.DepletionTime
	end
	
	if self.DailyIncome then
		sector.DailyIncome = self.DailyIncome
	end
end

---
--- Provides a brief description of the `SectorSetMineProperties` effect for the editor UI.
---
--- This function returns a string that describes the `SectorSetMineProperties` effect in a human-readable format for display in the editor UI. It includes information about the sector ID that the effect is being applied to.
---
--- @return string A human-readable description of the `SectorSetMineProperties` effect.
function SectorSetMineProperties:GetEditorView()
	return Untranslated("Set diamond mine related properties on <sector_id>")
end

---
--- Checks if the `sector_id` property has been set for the `SectorSetMineProperties` effect.
---
--- This function is used to validate the input for the `SectorSetMineProperties` effect. If the `sector_id` property has not been set, this function will return an error message indicating that the sector must be specified.
---
--- @return string|nil An error message if the `sector_id` property has not been set, or `nil` if it has been set.
function SectorSetMineProperties:GetError()
	if not self.sector_id then
		return "Specify sector!"
	end
end

DefineClass.SectorSetPort = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "enable", help = "Add/remove port in sector.", 
			editor = "bool", default = true, },
		{ id = "sector_id", help = "Sector id.", 
			editor = "combo", default = false, items = function (self) return GetCampaignSectorsCombo() end, },
	},
	Documentation = "Enable/disable port in specified sector",
	EditorNestedObjCategory = "Sector effects",
}

---
--- Enables or disables a port in the specified sector.
---
--- This function is called when the `SectorSetPort` effect is executed. It sets the `PortLocked` property of the sector to the opposite of the `enable` property, and sets the `Port` property to `true` (for legacy reasons). If the sector's side is "player1" or "player2", it increments the "Port" count in the `gv_PlayerSectorCounts` table. Finally, it sends a "BuildingLockChanged" message with the sector ID.
---
--- @param obj table The object that the effect is being applied to.
--- @param context table The context in which the effect is being executed.
function SectorSetPort:__exec(obj, context)
	local sector = gv_Sectors[self.sector_id]
	sector.PortLocked = not self.enable
	sector.Port = true -- Legacy
	if sector.Side == "player1" or sector.Side == "player2" then
		gv_PlayerSectorCounts["Port"] = gv_PlayerSectorCounts["Port"]  + 1
	end
	Msg("BuildingLockChanged", self.sector_id)
end

---
--- Returns a human-readable description of the `SectorSetPort` effect, indicating whether the port is being enabled or disabled in the specified sector.
---
--- @param self table The `SectorSetPort` effect object.
--- @return string A human-readable description of the `SectorSetPort` effect.
function SectorSetPort:GetEditorView()
	if self.enable then
		return Untranslated("Enable port in sector <u(sector_id)>")
	else
		return Untranslated("Disable port in sector <u(sector_id)>")
	end
end

---
--- Returns an error message if the `sector_id` property is not set.
---
--- This function is called by the `SectorSetPort` effect to validate its input parameters. If the `sector_id` property is not set, this function will return an error message indicating that the sector must be specified.
---
--- @param self table The `SectorSetPort` effect object.
--- @return string An error message if the `sector_id` property is not set, or `nil` if the property is set.
function SectorSetPort:GetError()
	if not self.sector_id then
		return "Specify sector!"
	end
end

DefineClass.SectorSetRAndROperation = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "enable", help = "Set RAndR operation in sector.", 
			editor = "bool", default = true, },
		{ id = "sector_id", help = "Sector id.", 
			editor = "combo", default = false, items = function (self) return GetCampaignSectorsCombo() end, },
	},
	Documentation = "Enable/disable RAndR operation in specified sector",
	EditorNestedObjCategory = "Sector effects",
}

---
--- Enables or disables the RAndR (Repair and Rearm) operation in the specified sector.
---
--- @param obj table The `SectorSetRAndROperation` effect object.
--- @param context table The execution context for the effect.
function SectorSetRAndROperation:__exec(obj, context)
	gv_Sectors[self.sector_id].RAndRAllowed = self.enable
end

---
--- Returns a human-readable description of the `SectorSetRAndROperation` effect, indicating whether the RAndR (Repair and Rearm) operation is being enabled or disabled in the specified sector.
---
--- @param self table The `SectorSetRAndROperation` effect object.
--- @return string A human-readable description of the `SectorSetRAndROperation` effect.
function SectorSetRAndROperation:GetEditorView()
	if self.enable then
		return Untranslated("Enable RAndR  in sector <u(sector_id)>")
	else
		return Untranslated("Disable RAndR in sector <u(sector_id)>")
	end
end

---
--- Returns an error message if the `sector_id` property is not set.
---
--- This function is called by the `SectorSetPort` effect to validate its input parameters. If the `sector_id` property is not set, this function will return an error message indicating that the sector must be specified.
---
--- @param self table The `SectorSetPort` effect object.
--- @return string An error message if the `sector_id` property is not set, or `nil` if the property is set.
function SectorSetRAndROperation:GetError()
	if not self.sector_id then
		return "Specify sector!"
	end
end

DefineClass.SectorSetRepairShopOperation = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "enable", 
			editor = "bool", default = true, },
		{ id = "sector_id", help = "Sector id.", 
			editor = "combo", default = false, items = function (self) return GetCampaignSectorsCombo() end, },
	},
	Documentation = "Enable/Disable Repair Shop operations in the specified sector.",
	EditorNestedObjCategory = "Sector effects",
}

---
--- Enables or disables the Repair Shop operation in the specified sector.
---
--- @param obj table The `SectorSetRepairShopOperation` effect object.
--- @param context table The execution context for the effect.
function SectorSetRepairShopOperation:__exec(obj, context)
	gv_Sectors[self.sector_id].RepairShop = self.enable
end

---
--- Returns a human-readable description of the `SectorSetRepairShopOperation` effect, indicating whether the Repair Shop operation is being enabled or disabled in the specified sector.
---
--- @param self table The `SectorSetRepairShopOperation` effect object.
--- @return string A human-readable description of the `SectorSetRepairShopOperation` effect.
function SectorSetRepairShopOperation:GetEditorView()
	if self.enable then
		return Untranslated("Enable Repair Shop operations in sector <u(sector_id)>")
	else
		return Untranslated("Disable Repair Shop operations in sector <u(sector_id)>")
	end
end

---
--- Returns an error message if the `sector_id` property is not set.
---
--- This function is called by the `SectorSetPort` effect to validate its input parameters. If the `sector_id` property is not set, this function will return an error message indicating that the sector must be specified.
---
--- @param self table The `SectorSetRepairShopOperation` effect object.
--- @return string An error message if the `sector_id` property is not set, or `nil` if the property is set.
function SectorSetRepairShopOperation:GetError()
	if not self.sector_id then
		return "Specify sector!"
	end
end

DefineClass.SectorSetSide = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "sector_id", name = "Sector Id", help = "Sector id.", 
			editor = "combo", default = false, items = function (self) return GetCampaignSectorsCombo() end, },
		{ id = "side", name = "Side", help = "Choose side for sector.", 
			editor = "combo", default = "player1", items = function (self) return table.iappend(table.map(SideDefs, "Id"), {"dont-change"}) end, },
		{ id = "enable_sticky", name = "Enable Sticky Side", help = "This will forcefully set sticky side to true.", 
			editor = "bool", default = false, },
		{ id = "disable_sticky", name = "Disable Sticky Side", help = "This will forcefully set sticky side to false.", 
			editor = "bool", default = false, },
	},
	Documentation = "Change sector side and sticky side option (optional)",
	EditorNestedObjCategory = "Sector effects",
}

---
--- Sets the side and sticky side option for the specified sector.
---
--- If `enable_sticky` is true, the sector's sticky side will be set to true.
--- If `disable_sticky` is true, the sector's sticky side will be set to false.
--- If `side` is not "dont-change", the sector's side will be set to the specified side using `SatelliteSectorSetSide`.
--- If `side` is "dont-change", the sector's control will be updated using `UpdateSectorControl`.
---
--- @param obj table The `SectorSetSide` effect object.
--- @param context table The execution context for the effect.
function SectorSetSide:__exec(obj, context)
	local sector = gv_Sectors[self.sector_id]
	if not sector then return end
	if self.enable_sticky then
		sector.StickySide = true
	elseif self.disable_sticky then
		sector.StickySide = false
	end
	if self.side == "dont-change" then
		if g_StartingCombat then return end
		UpdateSectorControl(self.sector_id)
	else
		SatelliteSectorSetSide(self.sector_id, self.side, "force")
	end
end

---
--- Sets the side and sticky side option for the specified sector.
---
--- If `enable_sticky` is true, the sector's sticky side will be set to true.
--- If `disable_sticky` is true, the sector's sticky side will be set to false.
--- If `side` is not "dont-change", the sector's side will be set to the specified side using `SatelliteSectorSetSide`.
---
--- @param obj table The `SectorSetSide` effect object.
--- @param context table The execution context for the effect.
function SectorSetSide:GetEditorView()
	if self.enable_sticky then
		return Untranslated("Set side <u(side)> and enable sticky side in sector <u(sector_id)>")
	elseif self.disable_sticky then
		return Untranslated("Set side <u(side)> and disable sticky side in sector <u(sector_id)>")
	else
		return Untranslated("Set side <u(side)> in sector <u(sector_id)>")
	end
end

---
--- Checks if the `SectorSetSide` effect object has valid properties.
---
--- If `sector_id` is not set, returns an error message indicating that the sector must be specified.
--- If both `enable_sticky` and `disable_sticky` are set, returns an error message indicating that only one can be chosen.
---
--- @param self table The `SectorSetSide` effect object.
--- @return string|nil An error message if the object has invalid properties, or `nil` if the properties are valid.
---
function SectorSetSide:GetError()
	if not self.sector_id then
		return "Specify sector!"
	elseif self.enable_sticky and self.disable_sticky then
		return "You cannot both enable and disable sticky side, choose one"
	end
end

DefineClass.SectorSpawnSquad = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "sector_id", name = "Sector", help = "Sector id.", 
			editor = "combo", default = false, items = function (self) return GetCampaignSectorsCombo() end, },
		{ id = "squad_def_id", name = "Squad", help = "Pre-defined enemy squad.", 
			editor = "combo", default = false, items = function (self) return EnemySquadsComboItems("exclude test squads") end, },
		{ id = "side", name = "Side", 
			editor = "combo", default = "enemy1", items = function (self) return {"enemy1", "enemy2", "ally"} end, },
	},
	Documentation = "Spawns a predefined squad on the sector",
	EditorView = Untranslated("Spawn a <u(squad_def_id)> squad in sector <u(sector_id)>"),
	EditorNestedObjCategory = "Sector effects",
}

---
--- Spawns a predefined enemy squad in the specified sector.
---
--- @param obj table The SectorSpawnSquad effect object.
--- @param context table The execution context for the effect.
---
function SectorSpawnSquad:__exec(obj, context)
	if not gv_Sectors[self.sector_id] then return end
	GenerateEnemySquad(self.squad_def_id, self.sector_id, "Effect", nil, self.side)
end

---
--- Checks if the `SectorSpawnSquad` effect object has valid properties.
---
--- If `sector_id` is not set, returns an error message indicating that the sector must be specified.
--- If `squad_def_id` is not set, returns an error message indicating that the squad must be specified.
---
--- @param self table The `SectorSpawnSquad` effect object.
--- @return string|nil An error message if the object has invalid properties, or `nil` if the properties are valid.
---
function SectorSpawnSquad:GetError()
	if not self.sector_id then
		return "Specify sector!"
	elseif not self.squad_def_id then
		return "Specify squad!"
	end
end

DefineClass.SectorSquadDespawn = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "sector_id", name = "Sector", help = "Sector id.", 
			editor = "combo", default = false, items = function (self) return GetCampaignSectorsCombo() end, },
		{ id = "Militia", name = "Remove militia", 
			editor = "bool", default = true, },
		{ id = "Enemies", name = "Remove enemies", 
			editor = "bool", default = true, },
	},
	Documentation = "Removes all enemy and militia squads in that sector.",
	EditorView = Untranslated("Removes enemy squads and militia in <u(sector_id)>"),
	EditorNestedObjCategory = "Sector effects",
}

---
--- Removes all enemy and militia squads from the specified sector.
---
--- @param obj table The SectorSquadDespawn effect object.
--- @param context table The execution context for the effect.
---
function SectorSquadDespawn:__exec(obj, context)
	local squads = GetSectorSquads(self.sector_id)
	for i = #squads, 1, -1 do
		local squad = squads[i]
		if self.Enemies and IsEnemySquad(squad.UniqueId) or 
			self.Militia and squad.militia 
		then
			RemoveSquad(squad)
		end
	end
	if not gv_SatelliteView and self.sector_id == gv_CurrentSectorId then
		LocalCheckUnitsMapPresence()
	end
end

---
--- Returns an error message if the SectorSquadDespawn effect object has an invalid `sector_id` property.
---
--- @param self table The `SectorSquadDespawn` effect object.
--- @return string|nil An error message if the `sector_id` property is not set, or `nil` if the property is valid.
---
function SectorSquadDespawn:GetError()
	if not self.sector_id then
		return "Specify sector!"
	end
end

DefineClass.SectorTrainMilitia = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "sector_id", 
			editor = "combo", default = false, items = function (self) return GetCampaignSectorsCombo() end, },
		{ id = "Amount", 
			editor = "number", default = false, 
			default = const.Satellite.MilitiaUnitsPerTraining, min = 1, max = 8, },
	},
	Documentation = "Grants intel for the sector",
	EditorView = Untranslated("Train <u(Amount)> militia on <u(sector_id)>"),
	EditorNestedObjCategory = "Sector effects",
}

---
--- Spawns the specified amount of militia in the given sector.
---
--- @param obj table The SectorTrainMilitia effect object.
--- @param context table The execution context for the effect.
---
function SectorTrainMilitia:__exec(obj, context)
	local sector = gv_Sectors[self.sector_id]
	local _, trained =SpawnMilitia(self.Amount, sector)
	if trained == 0 then return end
	local logText = T{769055535456, "<amount> militia dispatched to <SectorName(sector)>",
		amount = trained,
		sector = sector
	}
	CombatLog("important", logText)
end

---
--- Returns an error message if the `SectorTrainMilitia` effect object has an invalid `sector_id` property.
---
--- @param self table The `SectorTrainMilitia` effect object.
--- @return string|nil An error message if the `sector_id` property is not set, or `nil` if the property is valid.
---
function SectorTrainMilitia:GetError()
	if not self.sector_id then
		return "Specify sector!"
	end
end

---
--- Returns the top rollover text for the SectorTrainMilitia effect.
---
--- @param negative boolean Whether the rollover text is for a negative effect.
--- @param template string The template to use for the rollover text.
--- @param game table The current game object.
--- @return string The top rollover text for the SectorTrainMilitia effect.
---
function SectorTrainMilitia:GetPhraseTopRolloverText(negative, template, game)
	local campaign = CampaignPresets[Game and Game.Campaign or DefaultCampaign]
	local sector = gv_Sectors and gv_Sectors[self.sector_id] or table.find_value(campaign.Sectors, "Id", self.sector_id)
	
	return T{445122419956, "Sent <em>Militia</em> to <em><SectorName(sector)></em>", sector = sector}
end

DefineClass.SectorsGrantIntel = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "sector_id", help = "Sector id.", 
			editor = "string_list", default = {}, item_default = "", items = function (self) return GetCampaignSectorsCombo() end, },
	},
	Documentation = "Grants intel for an array of sectors",
	EditorView = Untranslated("Grant intel for sectors <list(sector_id, ', ')>"),
	EditorNestedObjCategory = "Sector effects",
}

---
--- Executes the SectorsGrantIntel effect, which grants intel for an array of sectors.
---
--- @param obj table The SectorsGrantIntel effect object.
--- @param context table The current game context.
---
function SectorsGrantIntel:__exec(obj, context)
	
	DiscoverIntelForSectors(self.sector_id)
end

---
--- Returns an error message if the `SectorTrainMilitia` effect object has an invalid `sector_id` property.
---
--- @param self table The `SectorTrainMilitia` effect object.
--- @return string|nil An error message if the `sector_id` property is not set, or `nil` if the property is valid.
---
function SectorsGrantIntel:GetError()
	if not self.sector_id then
		return "Specify sector!"
	end
end

---
--- Returns the top rollover text for the SectorsGrantIntel effect, which displays information about the sectors that have gained intel.
---
--- @param negative boolean Whether the rollover text is for a negative effect.
--- @param template string The template to use for the rollover text.
--- @param game table The current game object.
--- @return string The top rollover text for the SectorsGrantIntel effect.
---
function SectorsGrantIntel:GetPhraseTopRolloverText(negative, template, game)
	local campaign = CampaignPresets[Game and Game.Campaign or DefaultCampaign]
	
	local knew = {}
	local new = {}
	for i, s in ipairs(self.sector_id) do
		local sector = gv_Sectors and gv_Sectors[s] or table.find_value(campaign.Sectors, "Id", s)
		if sector then
			if sector.intel_discovered then
				knew[#knew + 1] = T{427357563595, "<em><SectorName></em>", SectorName = sector and sector.display_name or "",}
			else
				new[#new + 1] = T{165345603261, "<em><SectorName></em> (sector <SectorId(sId)>)", SectorName = sector and sector.display_name or "", sId  = s}
			end
		end
	end
	
	local textCombined = false
	
	if #new > 0 then
		textCombined = T{309239191160, "Gained <em>Intel</em> for <sectors>.", sectors = table.concat(new, ", ")}
	end
	
	if #knew > 0 then
		local knewText = T{124400089767, "Intel for <sectors> is already available.", sectors = table.concat(knew, ", ")}
		if textCombined then
			textCombined = textCombined .. T(226690869750, "<newline>") .. knewText
		else
			textCombined = knewText
		end
		
	end
	return textCombined
end

DefineClass.SetBadgeEffect = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Remove", help = "Remove the badge instead.", 
			editor = "bool", default = false, },
		{ id = "BadgeUnit", name = "Badge on Unit", help = "The unit/group to place the badge on, if it exists on the current map.", 
			editor = "combo", default = false, items = function (self) return GridMarkerGroupsCombo() end, },
		{ id = "BadgePreset", name = "Badge Preset", help = "The badge preset to spawn.", 
			editor = "preset_id", default = false, preset_class = "BadgePresetDef", },
		{ id = "Quest", name = "Quest", help = "Which quest to associate this badge with. If the effect is placed on a quest it will attempt to find it itself.", 
			editor = "preset_id", default = false, preset_class = "QuestsDef", },
	},
	EditorView = T(946118376279, --[[EffectDef Effects SetBadgeEffect value]] "Place a badge of preset <u(BadgePreset)> on unit <u(BadgeUnit)>"),
	Documentation = "Place a badge on a unit.",
	EditorNestedObjCategory = "Units",
}

--- Executes the SetBadgeEffect, placing a badge of the specified preset on the specified unit, or removing a badge if the Remove property is set.
---
--- @param obj table The object that the effect is being executed on.
--- @param context table The context in which the effect is being executed.
function SetBadgeEffect:__exec(obj, context)
	local quest = (self.Quest and gv_Quests[self.Quest]) or (IsKindOf(obj, "QuestsDef") and obj) or false
	assert(quest)
	if not quest then return end
	
	if not self.BadgeUnit then return end
	
	local prefix = ""
	if self.Remove then
		prefix = badgeRemoveIdentifier
	end
	quest[badgeParamIdentifier .. self.BadgeUnit] = prefix .. (self.BadgePreset or "")
	UpdateQuestBadges(quest)
end

DefineClass.SetBehaviorVisitAL = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "ActorGroup", name = "Actor Group", help = "Unit group that will exit the map.", 
			editor = "combo", default = "", items = function (self) return GetUnitGroups() end, },
		{ id = "MarkerGroup", name = "Marker Group", help = "Exit marker group.", 
			editor = "combo", default = "", 
			no_edit = function(self) return self.closest end, items = function (self) return GetALMarkersGroups end, },
		{ id = "Kick", name = "Kick", 
			editor = "bool", default = true, },
	},
	EditorView = Untranslated("<u(ActorGroup)> visits <u(MarkerGroup)> marker"),
	Documentation = "Units vists specified Ambient Life marker",
	EditorNestedObjCategory = "Units",
}

--- Executes the SetBehaviorVisitAL effect, which causes a group of units to visit a specified Ambient Life marker.
---
--- @param obj table The object that the effect is being executed on.
--- @param context table The context in which the effect is being executed.
function SetBehaviorVisitAL:__exec(obj, context)
	local group_actors = ValidateUnitGroupForEffectExec(self.ActorGroup, self, obj)
	local actors = table.ifilter(group_actors, function(_, actor)
		return IsKindOf(actor, "Unit") and not actor.perpetual_marker
	end)
	if #actors == 0 then return end
	
	local actor = actors[1]
	if not IsValid(actor) then return end
	
	local visitables = table.ifilter(g_Visitables, function(_, visitable)
		local marker_groups = visitable[1].Groups
		local from_group =  not not table.find(marker_groups, self.MarkerGroup)
		
		return from_group
	end)
	if #visitables == 0 then return end
	
	local marker_visitable = visitables[1]
	if marker_visitable.reserved == actor.handle then
		return		-- same unit already visiting
	end
	
	local marker = marker_visitable[1]
	if marker_visitable.reserved then
		if not self.Kick then
			return	-- can't kick currently visiting unit
		end
		local unit = HandleToObject[marker_visitable.reserved]
		if IsValid(unit) then
			unit:FreeVisitable(marker_visitable)
			unit:SetCommand("Idle")
		end
	end
	actor:ReserveVisitable(marker_visitable)
	if marker:Random(100) < marker.ChanceSpawn then
		marker.perpetual_unit = actor
		actor.perpetual_marker = marker
	end
	if GameState and (GameState.entering_sector or GameState.setpiece_playing)  and marker.Teleport then
		actor.teleport_allowed_once = true
	end
	actor:SetCommand("Visit", marker_visitable)
end

--- Generates the editor view for the SetBehaviorVisitAL effect, which displays the actor group and marker group that the effect will use.
---
--- @return string The editor view string for this effect.
function SetBehaviorVisitAL:GetEditorView()
	return Untranslated("Sets <u(ActorGroup)> to visit <u(MarkerGroup)> marker")
end

DefineClass.SetDeploymentModeEffect = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "DeploymentMode", name = "Deployment Mode", help = "Sector id.", 
			editor = "combo", default = "defend", items = function (self) return {"defend", "attack"} end, },
		{ id = "DeploymentDir", name = "Deployment Direction", help = "Deployment Direction during attack", 
			editor = "combo", default = "North", 
			no_edit = function(self) return self.DeploymentMode == "defend" end, items = function (self) return {"North", "East", "South", "West"} end, },
	},
	Documentation = "Set Deployment Mode(and direction if attacking)r",
	EditorView = Untranslated("Set Deployment Mode"),
}

--- Sets the deployment mode and direction for the game.
---
--- @param obj table The object that the effect is being applied to.
--- @param context table The context in which the effect is being executed.
function SetDeploymentModeEffect:__exec(obj, context)
	SetDeploymentMode(self.DeploymentMode)
	if self.DeploymentMode == "attack" then
		gv_DeploymentDir = self.DeploymentDir
	end
end

DefineClass.SetSectorAutoResolveDefenderBonus = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "autoResolveDefenderBonus", name = "Auto Resolve Defender Bonus", 
			editor = "number", default = 0, },
		{ id = "sector_id", name = "Sector Id", help = "Sector id.", 
			editor = "combo", default = "current", items = function (self) return table.iappend({{text="current",value="current"}}, GetCampaignSectorsCombo()) end, },
	},
	Documentation = "Set a sector's Auto Resolve Defender Bonus.",
	EditorView = Untranslated("Set <u(sector_id)> sector's Auto Resolve Defender Bonus to <u(autoResolveDefenderBonus)>"),
	EditorNestedObjCategory = "Sector effects",
}

--- Sets the auto resolve defender bonus for the specified sector.
---
--- @param obj table The object that the effect is being applied to.
--- @param context table The context in which the effect is being executed.
function SetSectorAutoResolveDefenderBonus:__exec(obj, context)
	local sector_id = self.sector_id == "current" and gv_CurrentSectorId or self.sector_id
	local sector = gv_Sectors[sector_id]
	sector.AutoResolveDefenderBonus = self.autoResolveDefenderBonus
end

DefineClass.SetSectorDiscovered = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "sector_id", name = "Sector Id", help = "Sector id.", 
			editor = "combo", default = false, items = function (self) return GetCampaignSectorsCombo() end, },
	},
	Documentation = "Sets a sector to discovered",
	EditorNestedObjCategory = "Sector effects",
}

--- Sets a sector to discovered.
---
--- @param obj table The object that the effect is being applied to.
--- @param context table The context in which the effect is being executed.
function SetSectorDiscovered:__exec(obj, context)
	local sectorPreset = gv_Sectors[self.sector_id]
	if sectorPreset then
		sectorPreset.discovered = true
		
		if g_SatelliteUI then
			g_SatelliteUI:UpdateSectorVisuals(self.sector_id)
		end
	end
end

--- Returns the editor view for the SetSectorDiscovered effect.
---
--- @return string The editor view for the SetSectorDiscovered effect.
function SetSectorDiscovered:GetEditorView()
	return Untranslated("Set <u(sector_id)> to discovered", self)
end

--- Returns an error message if the `sector_id` property is not set.
---
--- @return string|nil An error message if the `sector_id` property is not set, or `nil` if it is set.
function SetSectorDiscovered:GetError()
	if not self.sector_id then
		return "Specify sector!"
	end
end

DefineClass.SetTimer = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Name", name = "Name", help = "Name of the timer.", 
			editor = "text", default = false, },
		{ id = "Label", name = "Label", help = "The label to display on the timer.", 
			editor = "text", default = false, translate = true, },
		{ id = "Time", name = "Time", help = "Time (in secs) to wait.", 
			editor = "number", default = 60000, scale = "sec", },
	},
	EditorView = Untranslated("Set timer <Name>"),
	Documentation = "The effect set a visual UI timer displayed in the upper center of the screen",
	EditorNestedObjCategory = "UI & Log",
}

--- Executes the SetTimer effect.
---
--- @param quest table The quest object that the effect is being applied to.
--- @param context table The context in which the effect is being executed.
--- @param TCE table The TriggeredConditionalEvent that the effect is part of.
function SetTimer:__exec(quest, context, TCE)
	if not (GameState.Conflict or GameState.ConflictScripted or GameState.Combat) then
		-- NOTE: Combat can be started without going through Conflict first, e.g. Stealth Kill
		StoreErrorSource("once", "SetTimer running in a sector without Conflict/Combat!")
	end
	TimerCreate(self.Name, self.Label, self.Time)
end

--- Executes the SetTimer effect and waits for the timer to complete.
---
--- @param quest table The quest object that the effect is being applied to.
--- @param context table The context in which the effect is being executed.
--- @param TCE table The TriggeredConditionalEvent that the effect is part of.
--- @return boolean True if the timer completed, false otherwise.
function SetTimer:__waitexec(quest, context, TCE)
	self:__exec(quest, context, TCE)
	return TimerWait(self.Name)
end

--- Skips the execution of the SetTimer effect and directly returns the result of executing the effect.
---
--- @param quest table The quest object that the effect is being applied to.
--- @param context table The context in which the effect is being executed.
--- @param TCE table The TriggeredConditionalEvent that the effect is part of.
--- @return boolean True if the timer completed, false otherwise.
function SetTimer:__skip(quest, context, TCE)
	return self:__exec(quest, context, TCE)
end

--- Checks for errors in the SetTimer effect.
---
--- This function checks if the SetTimer effect has a valid name and time specified, and if it is being used in a valid context (within a TriggeredConditionalEvent with Sequential Effects execution).
---
--- @return string|nil The error message if any errors are found, or nil if no errors are found.
function SetTimer:GetError()
	if not self.Name then
		return "SetTimer needs a name!"
	end
	if not self.Time then
		return "SetTimer needs time specified!"
	end
	
	if GetParentTableOfKindNoCheck(self, "TestHarness") then
		return
	end
	
	local container = GetParentTableOfKind(self, "TriggeredConditionalEvent")
	if not container then
		return "SetTimer can only be used in TCEs"
	end
	if not container.SequentialEffects then
		return "SetTimer can be used only in TCEs with Sequential Effects execution!"
	end
end

--- Returns the resume data for the SetTimer effect when the timer completes.
---
--- @param thread table The coroutine thread that the SetTimer effect is running in.
--- @param stack table The call stack of the coroutine thread.
--- @param stack_index number The index of the SetTimer effect in the call stack.
--- @return string, string The resume data for the coroutine, which includes the name of the timer that completed.
function SetTimer:GetResumeData(thread, stack, stack_index)
	return "TimerWait", self.Name
end

DefineClass.ShowGuardpostObjective = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "GuardpostObjective", name = "GuardpostObjective", 
			editor = "preset_id", default = false, preset_class = "GuardpostObjective", },
	},
	EditorView = Untranslated("Make guardpost objective <u(GuardpostObjective)> visible."),
	Documentation = "Make a guardpost objective visible.",
	EditorNestedObjCategory = "Sectors",
}

--- Makes a guardpost objective visible.
---
--- @param obj table The object that the effect is being executed on.
--- @param context table The context in which the effect is being executed.
function ShowGuardpostObjective:__exec(obj, context)
	SetGuardpostObjectiveSeen(self.GuardpostObjective)
end

DefineClass.ShowPopup = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "PopupId", help = "Popup notification preset id.", 
			editor = "preset_id", default = false, preset_class = "PopupNotification", },
	},
	EditorView = Untranslated("Show popup notification <u(PopupId)>"),
	Documentation = "Displays popup notification",
	EditorNestedObjCategory = "UI & Log",
}

--- Returns an error message if the PopupId property is not set.
---
--- @return string The error message, or nil if the PopupId property is set.
function ShowPopup:GetError()
	if not self.PopupId then
		return "No PopupId"
	end
end

--- Executes the ShowPopup effect by displaying a popup notification.
---
--- @param obj table The object that the effect is being executed on.
--- @param context table The context in which the effect is being executed.
function ShowPopup:__exec(obj, context)
	local id = self.PopupId
	local preset = PopupNotifications[id]
	if not preset then
		StoreErrorSource(Presets.PopupNotification[1][1], "Trying to show missing pop-up: " ..  id)
		return
	end
	if preset.OnceOnly and gv_DisabledPopups[id] then
		return
	end
	ShowPopupNotification(id)
end

--- Executes the ShowPopup effect by displaying a popup notification and then sends a message to close the popup.
---
--- @param obj table The object that the effect is being executed on.
--- @param context table The context in which the effect is being executed.
function ShowPopup:__waitexec(obj, context)
	self:__exec(obj, context)
	Msg("ClosePopup" .. self.PopupId)
end

--- Skips the execution of the ShowPopup effect and instead directly executes the __exec method.
---
--- @param quest table The quest object that the effect is being executed on.
--- @param context table The context in which the effect is being executed.
--- @param TCE table The TCE (Trigger Condition Effect) object that the effect is being executed on.
--- @return any The result of executing the __exec method.
function ShowPopup:__skip(quest, context, TCE)
	return self:__exec(quest, context, TCE)
end

--- Returns the resume data for the ShowPopup effect.
---
--- @param thread thread The thread that the effect is being executed on.
--- @param stack table The stack of the thread.
--- @param stack_index number The index of the effect in the stack.
--- @return string, any The resume data for the effect.
function ShowPopup:GetResumeData(thread, stack, stack_index)
	return "ShowPopup", self.PopupId
end

DefineClass.SleepEffect = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Sleep", name = "Sleep", help = "Sleep time in ms.", 
			editor = "number", default = 1000, },
	},
	Documentation = "An effect to delay other effects' execution.",
}

--- Returns the editor view for the SleepEffect.
---
--- @return string The editor view for the SleepEffect.
function SleepEffect:GetEditorView()
	return T(206265192932, "Delay: <u(Sleep)> ms")
end

--- Skips the execution of the SleepEffect and does not perform any action.
---
--- @param obj table The object that the effect is being executed on.
--- @param context table The context in which the effect is being executed.
function SleepEffect:__exec(obj, context)
	return
end

--- Executes the SleepEffect and waits for the specified sleep time before continuing.
---
--- @param obj table The object that the effect is being executed on.
--- @param context table The context in which the effect is being executed.
function SleepEffect:__waitexec(obj, context)
	Sleep(self.Sleep)
end

--- Skips the execution of the SleepEffect and does not perform any action.
---
--- @param quest table The quest that the effect is being executed on.
--- @param context table The context in which the effect is being executed.
--- @param TCE table The TCE (Trigger Condition Effect) object that the effect is being executed on.
--- @return any The result of executing the __exec method.
function SleepEffect:__skip(quest, context, TCE)
	
end

--- Returns the remaining time for the sleep effect.
---
--- @param thread table The thread that the sleep effect is running in.
--- @param stack table The stack of the thread that the sleep effect is running in.
--- @param stack_index number The index of the sleep effect in the stack.
--- @return string, number The resume data for the sleep effect, which includes the string "Sleep" and the remaining time in milliseconds.
function SleepEffect:GetResumeData(thread, stack, stack_index)
	local remainig = GetThreadStatus(thread) - GameTime()
	assert(type(remainig) == "number")
	assert(remainig >= 0)
	return "Sleep", remainig
end

DefineClass.StartDeploymentInCurrentSector = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "WaitClicked", name = "Wait Clicked", help = "Waits for the button to be clicked before continuing to trigger next effects.", 
			editor = "bool", default = false, },
		{ id = "EntranceZone", name = "EntranceZone", help = "Specific entrance zone", 
			editor = "choice", default = "custom", items = function (self) return {"attacker", "defender", "custom"} end, },
	},
	Documentation = "Enter deployment mode if it is valid for the currently loaded sector",
	EditorView = Untranslated("Enter deployment mode"),
}

--- Enters deployment mode for the current sector based on the specified entrance zone.
---
--- @param obj table The object that the effect is being executed on.
--- @param context table The context in which the effect is being executed.
function StartDeploymentInCurrentSector:__exec(obj, context)
	if self.EntranceZone and self.EntranceZone ~= "custom" then
		SetDeploymentMode(self.EntranceZone)
	else
		gv_Deployment = "custom"		
	end
	StartDeployment()
end

--- Enters deployment mode for the current sector based on the specified entrance zone, and waits for the button to be clicked before continuing to trigger next effects.
---
--- @param obj table The object that the effect is being executed on.
--- @param context table The context in which the effect is being executed.
function StartDeploymentInCurrentSector:__waitexec(obj, context)
	self:__exec(obj, context)
	if self.WaitClicked then
		WaitMsg("DeploymentModeDone")
	end
end

--- Skips the execution of the StartDeploymentInCurrentSector effect and directly executes the __exec function.
---
--- @param quest table The quest object that the effect is being executed on.
--- @param context table The context in which the effect is being executed.
--- @param TCE table The TCE (Tactical Combat Engine) object.
--- @return boolean The result of executing the __exec function.
function StartDeploymentInCurrentSector:__skip(quest, context, TCE)
	return self:__exec(quest, context, TCE)
end

--- Gets the resume data for the StartDeploymentInCurrentSector effect.
---
--- @param thread table The thread that the effect is being executed in.
--- @param stack table The stack of the thread.
--- @param stack_index number The index of the effect in the stack.
--- @return string, string The name of the effect and the entrance zone.
function StartDeploymentInCurrentSector:GetResumeData(thread, stack, stack_index)
	return "StartDeploymentInCurrentSector", self.EntranceZone
end

DefineClass.TriggerGuardPostAttack = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "guardpost_sector_id", name = "Guardpost Sector", help = "Sector id.", 
			editor = "combo", default = false, items = function (self) return GetCampaignSectorsCombo() end, },
		{ id = "effect_target_sector_ids", name = "Target Sectors", help = "Attack one of these sectors.", 
			editor = "string_list", default = {}, item_default = "last captured", items = function (self) return GetCampaignSectorsCombo("last captured") end, },
		{ id = "time", name = "Time", help = "Time to pass before spawning the squad.", 
			editor = "number", default = 43200, scale = "h", },
		{ id = "custom_quest_id", name = "Custom Quest Id", help = "This could would be used in quests (ex. to check if the attack squad was defeated - with SquadDefeated condition).", 
			editor = "text", default = false, },
		{ id = "reach_quest_id", name = "Reach Quest Id", help = "Quest to set variables to true when squad reaches it destination sector.", 
			editor = "preset_id", default = false, preset_class = "QuestsDef", },
		{ id = "reach_quest_var", name = "Var to check", help = "Variable in reach quest to set to true when squad reaches it destination sector", 
			editor = "set", default = false, max_items_in_set = 1, items = function (self) return table.keys2(QuestGetVariables(self.reach_quest_id), "sorted") end, },
	},
	Documentation = "Spawns enemy squad from guardpost after time.",
	EditorNestedObjCategory = "Sector effects",
}

---
--- Generates the editor view for the TriggerGuardPostAttack effect.
---
--- @param self TriggerGuardPostAttack The effect instance.
--- @return string The editor view string.
function TriggerGuardPostAttack:GetEditorView()
	local targets = Untranslated(table.concat(self.effect_target_sector_ids, ", "))
	return T{926384305749, "Spawns enemy squad from guardpost on <u(guardpost_sector_id)> to (<targets>) after <CampaignTime(time)>", self, targets = targets}
end

---
--- Executes the TriggerGuardPostAttack effect.
---
--- @param obj table The object that the effect is being executed on.
--- @param context table The context in which the effect is being executed.
---
--- This function checks if the guardpost sector is valid, and if the target sector is the last captured sector. If the conditions are met, it calls the ForceSetNextSpawnTimeAndSector method on the guardpost to trigger an attack.
---
function TriggerGuardPostAttack:__exec(obj, context)
	local gp = g_Guardposts[self.guardpost_sector_id]
	if not gp then
		StoreErrorSource(self, "TriggerGuardPostAttack - guardpost_sector_id should be sector with guardpost.")
	end
	if table.find(self.effect_target_sector_ids, "last captured") and not gv_LastSectorTakenByPlayer then
		return
	end
	if gp then
		gp:ForceSetNextSpawnTimeAndSector(self.time, self.effect_target_sector_ids, self.custom_quest_id, self.reach_quest_id, self.reach_quest_var)
	end
end

---
--- Checks if the TriggerGuardPostAttack effect is properly configured.
---
--- @return string|nil The error message if the effect is not properly configured, or nil if it is.
---
function TriggerGuardPostAttack:GetError()
	if not self.guardpost_sector_id then
		return "Specify Guardpost Sector"
	elseif not self.effect_target_sector_ids[1] or self.effect_target_sector_ids[1] == "" then
		return "Specify Target Sector!"
	end
	
	local sector = gv_Sectors and gv_Sectors[self.guardpost_sector_id]
	if sector and not sector.Guardpost then
		return "Sector should be a guardpost sector!"
	end
end

DefineClass.TriggerSectorWarningState = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	RequiredObjClasses = {
	"Unit",
},
	EditorView = Untranslated("Trigger the current sector's Warning State"),
	Documentation = "Triggers the Warning State for the current sector.",
	EditorNestedObjCategory = "Sector effects",
}

---
--- Executes the TriggerSectorWarningState effect.
---
--- @param obj table The object that the effect is being executed on.
--- @param context table The context in which the effect is being executed.
---
--- This function checks if the satellite view is active, and if not, it gets the current sector, the allied units in that sector, and the enemy units. It then determines the triggering unit, which is either the object passed in or the first allied unit. Finally, it calls the EnterWarningState function with the enemy units, allied units, and triggering unit.
---
function TriggerSectorWarningState:__exec(obj, context)
	if gv_SatelliteView then return end
	
	local sector = gv_Sectors[gv_CurrentSectorId]
	local alliedUnits = GetPlayerSectorUnits(gv_CurrentSectorId, "getUnits")
	local enemyUnits = GetAllEnemyUnits(alliedUnits[1])
	local triggeringUnit
	if IsKindOf(obj, "Unit") and table.find(alliedUnits, obj) then
		triggeringUnit = obj
	else
		triggeringUnit = alliedUnits[1]
	end
	
	EnterWarningState(enemyUnits, alliedUnits, triggeringUnit)
end

DefineClass.TriggerSquadAttack = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "source_sector_id", name = "Source Sector", help = "Source Sector id.", 
			editor = "combo", default = false, items = function (self) return GetCampaignSectorsCombo() end, },
		{ id = "effect_target_sector_ids", name = "Target Sectors", help = "Attack one of these sectors.", 
			editor = "string_list", default = {}, item_default = "last captured", items = function (self) return GetCampaignSectorsCombo("last captured") end, },
		{ id = "reach_quest_id", name = "Reach Quest Id", help = "Quest to set variables to true when squad reaches it destination sector.", 
			editor = "preset_id", default = false, preset_class = "QuestsDef", },
		{ id = "reach_quest_var", name = "Var to check", help = "Variable in reach quest to set to true when squad reaches it destination sector", 
			editor = "set", default = false, max_items_in_set = 1, items = function (self) return table.keys2(QuestGetVariables(self.reach_quest_id), "sorted") end, },
		{ id = "custom_quest_id", name = "Custom Quest Id", help = "This could would be used in quests (ex. to check if the attack squad was defeated - with SquadDefeated condition).", 
			editor = "text", default = false, },
		{ id = "EnemySquadsList", name = "Enemy Squads List", help = "A random squad from the list will be chosen on guardpost spawn time", 
			editor = "preset_id_list", default = {}, 
			no_edit = function(self) return not self.Guardpost end, preset_class = "EnemySquads", preset_filter = function (preset, obj, prop_meta)
	if preset.group ~= "Test Encounters" then return obj end
end, 
item_default = "", },
		{ id = "Squad", name = "Squad", help = "Squad that will be spawned in the sector on campaign start", 
			editor = "combo", default = false, items = function (self) return EnemySquadsComboItems("exclude test squads") end, },
	},
	Documentation = "Spawns specific enemy squad  after time.",
	EditorNestedObjCategory = "Sector effects",
}

---
--- Returns a string representation of the editor view for the TriggerSquadAttack effect.
---
--- @return string The editor view string.
---
function TriggerSquadAttack:GetEditorView()
	local targets = Untranslated(table.concat(self.effect_target_sector_ids, ", "))
	return T{768343821287, "Spawns specific enemy squad to (<targets>)", self, targets = targets}
end

---
--- Executes the TriggerSquadAttack effect.
---
--- This function spawns a specific enemy squad in a target sector after a certain time delay. It checks if the target sector is the "last captured" sector, and if so, it replaces that with the actual last captured sector. It then selects a random target sector from the list of target sectors, generates the enemy squad in the source sector, and sends the squad on a route to the target sector. If the target sector is different from the source sector, it adds a timeline event to trigger the squad attack when the squad reaches the target sector.
---
--- @param obj table The object that the effect is being applied to.
--- @param context table The context in which the effect is being executed.
--- @return string|nil The ID of the generated squad, or nil if the squad could not be generated.
---
function TriggerSquadAttack:__exec(obj, context)
	if table.find(self.effect_target_sector_ids, "last captured") and not gv_LastSectorTakenByPlayer then
		return
	end
	local sector = gv_Sectors[self.source_sector_id]
	if not sector then return end
	
	local sector_ids = self.effect_target_sector_ids
	if gv_LastSectorTakenByPlayer then
		table.replace(sector_ids, "last captured", gv_LastSectorTakenByPlayer)
	end
	local target_sector_id = table.interaction_rand(sector_ids, "TriggerSquadAttack")
	
	--local next_squad = table.interaction_rand(sector.EnemySquadsList or empty_table, "TriggerSquadAttack")
	--local next_squad_units = GenerateRandEnemySquadUnits(next_squad)
	local squad_id = GenerateEnemySquad(self.Squad, self.source_sector_id, "TriggerSquadAttack")
	if squad_id then
		gv_CustomQuestIdToSquadId[self.custom_quest_id or self.Squad] = squad_id
		local squad = gv_Squads[squad_id]
		squad.on_reach_quest = self.reach_quest_id
		squad.on_reach_var = self.reach_quest_var
		
		if target_sector_id ~= self.source_sector_id then
			SendSatelliteSquadOnRoute(squad, target_sector_id)
		
			local timeToReach = GetTotalRouteTravelTime(squad.CurrentSector, squad.route, squad)
			AddTimelineEvent("squad-attack-" .. squad.UniqueId, Game.CampaignTime + timeToReach, "squad-attack", squad.UniqueId)
		end
		
		return squad_id
	end
	
	StoreErrorSource(sector, string.format("Sector '%s' does not have enemy squad '%s'", self.source_sector_id, self.Squad))
end

---
--- Checks if the TriggerSquadAttack effect has the required parameters set.
---
--- This function checks if the `Squad` and `effect_target_sector_ids` properties of the TriggerSquadAttack effect are set. If either of these is missing, it returns an error message indicating which parameter is missing.
---
--- @return string|nil The error message if any required parameter is missing, or `nil` if all required parameters are set.
---
function TriggerSquadAttack:GetError()
	if not self.Squad then
		return "Specify Squad"
	elseif not self.effect_target_sector_ids[1] or self.effect_target_sector_ids[1] == "" then
		return "Specify Target Sector!"
	end
end

DefineClass.UnitAddGrit = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "amount", name = "Amount", 
			editor = "number", default = 30, },
	},
	RequiredObjClasses = {
	"Unit",
	"UnitData",
},
	EditorView = Untranslated("Add grit to the unit."),
	Documentation = "Add grit to the unit.",
	EditorNestedObjCategory = "Units",
}

---
--- Applies a temporary hit point bonus to a unit.
---
--- This function checks if the given object is a `UnitData` instance, and if so, retrieves the corresponding `Unit` instance. It then checks if the unit is not dead, and applies the specified `amount` of temporary hit points to the unit.
---
--- @param obj table The object to apply the effect to.
--- @param context table The context in which the effect is being applied.
---
function UnitAddGrit:__exec(obj, context)
	local unit = obj
		
	if IsKindOf(unit, "UnitData") then
		unit = g_Units[unit.session_id]
	end
	
	if IsKindOf(unit, "Unit") and not unit:IsDead() then
		unit:ApplyTempHitPoints(self.amount)
	end
end

DefineClass.UnitAddStatusEffect = {
	__parents = { "Effect", "UnitTarget", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Status", name = "Status", 
			editor = "preset_id", default = false, preset_class = "CharacterEffectCompositeDef", },
	},
	RequiredObjClasses = {
	"Unit",
},
	EditorView = Untranslated("Add <u(Status)> effect to the unit"),
	Documentation = "Add status effect to a unit",
}

---
--- Applies a status effect to a unit.
---
--- This function first checks if the given object is a `Unit` instance and if the unit is not dead. If the conditions are met, it adds the specified status effect to the unit.
---
--- If a context is provided, the function also tries to match map units based on the context. If target units are found in the context, it applies the status effect to those units as well. If the status effect is "Wounded", it adds 1 wound to the target units instead of applying the status effect.
---
--- @param obj table The object to apply the effect to.
--- @param context table The context in which the effect is being applied.
---
function UnitAddStatusEffect:__exec(obj, context)
	if IsKindOf(obj, "Unit") and not obj:IsDead() then
		obj:AddStatusEffect(self.Status)
	end
	
	if not context then context = {} end
	local units = self:MatchMapUnits(obj, context)
	if units and context.target_units then
		for _, unit in ipairs(context.target_units) do
			if self.Status == "Wounded" then
				obj:AddWounds(1)
			else
				obj:AddStatusEffect(self.Status)
			end
		end
	end
end

---
--- Checks if the given unit is a valid target for the status effect.
---
--- This function checks if the given `unit` is an instance of `Unit` and if the unit is not dead.
---
--- @param unit table The unit to check.
--- @param obj table The object that the status effect is being applied to.
--- @param context table The context in which the status effect is being applied.
--- @return boolean True if the unit is a valid target, false otherwise.
---
function UnitAddStatusEffect:UnitCheck(unit, obj, context)
	return IsKindOf(unit, "Unit") and not unit:IsDead()
end

---
--- Returns the editor view for the UnitAddStatusEffect class.
---
--- The editor view is a string that describes the effect in a human-readable format, with placeholders for dynamic values.
---
--- @return string The editor view string.
---
function UnitAddStatusEffect:GetEditorView()
	return T(237536962390, "Add <u(Status)> to the unit")
end

DefineClass.UnitApplyAppearance = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "TargetUnit", name = "Target Unit", help = "Target unit for match.", 
			editor = "combo", default = false, items = function (self) return GetUnitGroups() end, },
		{ id = "Appearance", name = "Appearance", help = "Appearance to set.", 
			editor = "preset_id", default = false, preset_class = "AppearancePreset", },
	},
	EditorView = Untranslated("<u(TargetUnit)> changes appearance to <Appearance>"),
	Documentation = "Changes the appearance of an unit",
	EditorNestedObjCategory = "Units",
}

---
--- Applies the specified appearance to the first unit in the target group.
---
--- @param obj table The object that the effect is being applied to.
--- @param context table The context in which the effect is being applied.
---
function UnitApplyAppearance:__exec(obj, context)
	local units = Groups[self.TargetUnit] or empty_table
	
	if units[1] then
		units[1]:ApplyAppearance(self.Appearance)
	end
end

---
--- Returns an error message if the TargetUnit property is not set.
---
--- @return string The error message, or nil if the TargetUnit property is set.
---
function UnitApplyAppearance:GetError()
	if not self.TargetUnit then
		return "Choose target unit to die"
	end
end

DefineClass.UnitDie = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "TargetGroup", name = "Target Group", help = "Target group for match.", 
			editor = "combo", default = false, items = function (self) return GetUnitGroups() end, },
		{ id = "skipAnim", name = "Skip Animation", 
			editor = "bool", default = false, },
		{ id = "killImmortal", name = "Kill Immortal", help = "Makes units mortal and then kills them.", 
			editor = "bool", default = false, },
	},
	EditorView = Untranslated("Units from group <u(TargetGroup)> die"),
	Documentation = "Kill units from specified group",
	EditorNestedObjCategory = "Units",
}

---
--- Applies the "Die" command to all units in the specified target group, optionally skipping the animation and making immortal units mortal.
---
--- @param obj table The object that the effect is being applied to.
--- @param context table The context in which the effect is being applied.
---
function UnitDie:__exec(obj, context)
	local group = Groups[self.TargetGroup] or empty_table
	for i, v in ipairs(group) do
		if IsKindOf(v, "Unit") and not v:IsDead() then
			v.villain = false
			if self.killImmortal then
				v.immortal = false
			end
			v:SetCommand("Die", self.skipAnim)
		end
	end
end

---
--- Returns an error message if the TargetGroup property is not set.
---
--- @return string The error message, or nil if the TargetGroup property is set.
---
function UnitDie:GetError()
	if not self.TargetGroup then
		return "Choose target unit to die"
	end
end

DefineClass.UnitEnvEffectTick = {
	__parents = { "UnitTarget", "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "EffectType", 
			editor = "choice", default = "Burning", items = function (self) return {"Burning", "ToxicGas", "TearGas", "Smoke", "Darkness"} end, },
		{ id = "CombatMoment", 
			editor = "choice", default = "n/a", items = function (self) return {"start turn", "end turn", "n/a"} end, },
	},
	EditorView = Untranslated("Trigger <u(EffectType)> tick for <u(TargetUnit)>"),
	Documentation = "Trigger environmental effect tick for target unit",
	EditorNestedObjCategory = "Units",
}

---
--- Executes the UnitEnvEffectTick effect, triggering an environmental effect tick for the target units.
---
--- @param obj table The object that the effect is being applied to.
--- @param context table The context in which the effect is being applied.
---
function UnitEnvEffectTick:__exec(obj, context)
	if not context then context = {} end
	local units = self:MatchMapUnits(obj, context)
	if units and context.target_units then
		local moment = (self.CombatMoment ~= "n/a") and self.CombatMoment or nil
		local func = EnvEffectBurningTick
		if self.EffectType == "ToxicGas" then
			func = EnvEffectToxicGasTick
		elseif self.EffectType == "TearGas" then
			func = EnvEffectTearGasTick
		elseif self.EffectType == "Smoke" then
			func = EnvEffectSmokeTick
		elseif self.EffectType == "Darkness" then
			func = EnvEffectDarknessTick
		end
		for _, unit in ipairs(context.target_units) do
			if IsValid(unit) and IsKindOf(unit, "Unit") and not unit:IsDead() then
				func(unit, nil, moment)
			end
		end
	end
end

---
--- Returns an error message if the target unit is not set.
---
--- @return string The error message.
---
function UnitEnvEffectTick:GetError()
	if not self.TargetUnit then
		return "Choose target unit"
	end
end

---
--- Checks if the given unit is valid for the UnitEnvEffectTick effect.
---
--- @param unit table The unit to check.
--- @param obj table The object that the effect is being applied to.
--- @param context table The context in which the effect is being applied.
--- @return boolean True if the unit is valid, false otherwise.
---
function UnitEnvEffectTick:UnitCheck(unit, obj, context)
	return true
end

DefineClass.UnitGrantAP = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "ap", name = "AP", help = "Action Points to Give", 
			editor = "number", default = 8, },
	},
	RequiredObjClasses = {
	"Unit",
},
	EditorView = Untranslated("Grant <u(ap)> AP to the unit"),
	Documentation = "Modify unit's AP",
	EditorNestedObjCategory = "Units",
}

---
--- Executes the UnitGrantAP effect, granting or consuming action points (AP) for the specified unit.
---
--- @param obj table The unit object to apply the effect to.
--- @param context table The context in which the effect is being applied.
---
function UnitGrantAP:__exec(obj, context)
	if IsKindOf(obj, "Unit") and not obj:IsDead() then
		if self.ap > 0 then
			obj:GainAP(self.ap*const.Scale.AP)
		else
			obj:ConsumeAP(self.ap*const.Scale.AP)
		end
	end
end

DefineClass.UnitGrantItem = {
	__parents = { "Effect", "LootTableFunctionObjectBase", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "ItemId", name = "Item", help = "The id of the item that will be granted.", 
			editor = "preset_id", default = false, preset_class = "InventoryItemCompositeDef", },
		{ id = "Amount", name = "Amount", help = "How many items are granted.", 
			editor = "number", default = 1, min = 1, },
		{ id = "LootTableId", name = "Loot Table Id", help = "Loot table to generate items that will be granted.", 
			editor = "preset_id", default = false, preset_class = "LootDef", },
		{ id = "GrantedItemsTextUI", 
			editor = "text", default = false, dont_save = true, no_edit = true, translate = true, },
		{ id = "GrantedItemsEditorTextUI", 
			editor = "text", default = false, dont_save = true, no_edit = true, translate = true, },
		{ id = "GeneratedItems", 
			editor = "prop_table", default = false, dont_save = true, no_edit = true, },
		{ id = "actor", name = "Log Actor", help = "How to log the received items.", 
			editor = "choice", default = "important", items = function (self) return {"short", "important"} end, },
	},
	Documentation = "Give item to a merc or to any from its squad.",
	EditorNestedObjCategory = "Units",
}

---
--- Returns the editor view text for the UnitGrantItem effect.
---
--- The editor view text will depend on the properties set on the effect:
--- - If both ItemId and LootTableId are set, the text will be "ItemId(Amount) and 'LootTableId' loot table items are given to the merc"
--- - If only ItemId is set, the text will be "ItemId(Amount) given to the merc"
--- - If only LootTableId is set, the text will be "Loot table items 'LootTableId' given to the merc"
--- - If neither ItemId nor LootTableId are set, an empty string will be returned
---
--- @return string The editor view text for the UnitGrantItem effect
---
function UnitGrantItem:GetEditorView()
	if self.ItemId and self.LootTableId then
		return Untranslated("<u(ItemId)>(<Amount>) and \'<u(LootTableId)>\' loot table items are given to the merc")
	end
	if self.ItemId then
		return Untranslated("<u(ItemId)>(<Amount>) given to the merc")
	end
	if self.LootTableId then
		return Untranslated("Loot table items \'<u(LootTableId)>\' given to the merc")
	end
	return ""
end

---
--- Executes the UnitGrantItem effect, granting items to a unit or a squad.
---
--- The function first tries to find a valid squad to grant the items to. If no squad is found, it will try to use the first player squad. If no player squad is found, the function will assert and return without granting any items.
---
--- The function then generates the items to be granted, either from the ItemId property or the LootTableId property. The generated items are then added to the squad's inventory and distributed to the squad members. If the inventory of a squad member is full, the remaining items are dropped on the ground or added to the sector inventory.
---
--- @param obj string|table The unit or the unit session_id to grant the items to.
--- @param context table The context in which the effect is being executed.
---
function UnitGrantItem:__exec(obj, context)
	-- can work with both unit and a unit session_id
	local unit_id = type(obj) == "string" and obj or obj.session_id --please no SelectedObj here, this is sync
	local squad = gv_UnitData[unit_id] and gv_UnitData[unit_id].Squad
	if not squad then
		-- try to give to the first of player squads
		local squads = GetSectorSquadsFromSide(gv_CurrentSectorId, "player1")
		squad = #squads>0 and squads[1].UniqueId
	end
	--to any player squad
	assert(squad, "There is not unit or player squad on the sector")
	if not squad then	
		if g_PlayerSquads and  #g_PlayerSquads>0 then
			squad = g_PlayerSquads[1].UniqueId
		end
	end
	assert(squad, "There is not any  player squad.The item is not given.")
	if not squad then return end
	
	local sector = gv_Squads[squad].CurrentSector
	
	local all_mercs = gv_Squads[squad].units
	if unit_id then
		all_mercs = table.copy(all_mercs)
		table.remove_entry(all_mercs, unit_id)	
		table.insert(all_mercs, 1, unit_id)
	end
	unit_id =  unit_id or all_mercs[1]
	
	-- loot table
	local items = UnitGrantItem.GenerateItems(self, "game") or {}			 
	
	CombatLogActorOverride = self.actor
	
	AddItemsToSquadBag(squad, items)
	for idx, merc in ipairs(all_mercs) do
		if #items<=0 then break end
		local unit = g_Units[merc] or gv_UnitData[merc]
		unit:AddItemsToInventory(items)
	end
	
	if #items > 0 then
		local unit = g_Units[unit_id]	
		if unit then
			unit:DropItemsInContainer(items, 
				function(unit, item, amount)
					CombatLog("important", T{740183432105, "  Inventory full. <amount><em><item></em> dropped by <name>", amount = amount>1 and Untranslated(amount.." x ") or "", item = amount>1 and item.DisplayNamePlural or item.DisplayName,  name = unit:GetDisplayName()})
				end)
		else
			local stash = GetSectorInventory(sector)		
			if stash then 
				AddItemsToInventory(stash, items, true)
			end
		end		
	end
	
	-- items
	if self.ItemId then
		local amount = self.Amount
		local item
		if amount > 0 then
			amount = AddItemToSquadBag(squad, self.ItemId, amount)	
		end
		
		for idx, merc in ipairs(all_mercs) do
			if amount <= 0 then break end
			local unit = g_Units[merc] or gv_UnitData[merc]
			amount = unit:AddToInventory(self.ItemId, amount)
		end
		
		if amount > 0 then
			local unit = g_Units[unit_id]
			if unit then	
				unit:DropItemContainer(self.ItemId, amount, 
					function(unit, item, amount)
						CombatLog("important", T{740183432105, "  Inventory full. <amount><em><item></em> dropped by <name>", amount = amount>1 and Untranslated(amount.." x ") or "", item = amount>1 and item.DisplayNamePlural or item.DisplayName,  name = unit:GetDisplayName()})
					end)
			else
				local stash = GetSectorInventory(sector)		
				if stash then 
					local itm = PlaceInventoryItem(self.ItemId)
					AddItemsToInventory(stash, {itm},true)
				end
			end	
		end
	end
	
	self.GeneratedItems = false
	CombatLogActorOverride = false
end

---
--- Checks if the `UnitGrantItem` instance has a valid `ItemId` or `LootTableId` set.
--- If neither is set, returns an error message.
---
--- @return string|nil The error message if the `ItemId` and `LootTableId` are not set, otherwise `nil`.
---
function UnitGrantItem:GetError()
	if (not self.ItemId or self.ItemId == "") and not self.LootTableId then
		return "Set Item or loot table!"
	end
end

---
--- Returns the top rollover text for the item granted by this `UnitGrantItem` instance.
---
--- @param negative boolean Whether the item was obtained negatively (e.g. lost).
--- @param template string The template to use for the rollover text.
--- @param game boolean Whether this is being called in the game context or the editor.
--- @return string The top rollover text for the granted item.
---
function UnitGrantItem:GetPhraseTopRolloverText(negative, template, game)
	local item = self.ItemId and InventoryItemDefs[self.ItemId]
	if item then
		local item_name = item.DisplayName
		local item_name_pl = item.DisplayNamePlural
		if self.ItemId == "Money" then
			return T{283114521154, "<em><money(Amount)></em> obtained", Amount = self.Amount}
		else
			return T{215465168779, "<Amount> x <em><item></em> obtained", Amount = self.Amount, item =  self.Amount<=1 and item_name or item_name_pl}
		end
	end
	
	self:GenerateItems(game)
	
	if game then
		if self.GrantedItemsTextUI and self.GrantedItemsTextUI ~= "" then
			return T{871249882862, "<items_list> obtained", items_list = self.GrantedItemsTextUI}
		end
	else
		if self.GrantedItemsEditorTextUI and self.GrantedItemsEditorTextUI ~= "" then
			return T{871249882862, "<items_list> obtained", items_list = self.GrantedItemsEditorTextUI}
		end
	end
end

---
--- Generates a list of items based on the `LootTableId` property of the `UnitGrantItem` instance.
---
--- If `game` is true, the generated items are stored in the `GeneratedItems` property and the item names are stored in the `GrantedItemsTextUI` property.
--- If `game` is false, the item names are stored in the `GrantedItemsEditorTextUI` property.
---
--- @param game boolean Whether this is being called in the game context or the editor.
--- @return table The list of generated items.
---
function UnitGrantItem:GenerateItems(game)
	if game and self.GeneratedItems then return self.GeneratedItems end -- items are already generated don't try again.
	if not game and self.GrantedItemsEditorTextUI then return end
	
	local items = {}
	local loot_tbl = LootDefs[self.LootTableId]
	if loot_tbl then
		loot_tbl:GenerateLoot(self, {}, InteractionRand(nil, "Loot"), items)
	end
	
	if #items > 0 then
		if game then
			self.GeneratedItems = items
			self.GrantedItemsTextUI = GetItemsNamesText(items)
		else
			self.GrantedItemsEditorTextUI = GetItemsNamesText(items)
		end
	end
	return items
end

---
--- Returns the phrase FX to be played when a unit gains an item.
---
--- @return string The phrase FX to be played.
---
function UnitGrantItem:GetPhraseFX()
	return "ConversationItemGained"
end

DefineClass.UnitJoinAsMerc = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "TargetUnit", name = "Target Unit", help = "Target unit for match.", 
			editor = "combo", default = false, items = function (self) return GetUnitGroups() end, },
		{ id = "Merc", help = "The Merc to join the team.", 
			editor = "combo", default = false, items = function (self) return MercPresetCombo() end, },
	},
	RequiredObjClasses = {
	"Unit",
},
	EditorView = Untranslated("Make <u(TargetUnit)> join team as <u(Merc)>"),
	Documentation = "Unit joins as a specified merc.",
	EditorNestedObjCategory = "Units",
}

---
--- Executes the UnitJoinAsMerc effect.
---
--- This function is responsible for making a unit join a squad as a specified merc.
---
--- @param obj The object on which the effect is being executed. This can be either a unit or a unit session ID.
--- @param context The context in which the effect is being executed.
---
function UnitJoinAsMerc:__exec(obj, context)
	local units = Groups[self.TargetUnit] or empty_table
	units = table.ifilter(units, function(_, u)
		return IsKindOf(u, "Unit")
	end)
	
	-- can work with both unit and a unit session_id
	local unit_id = type(obj) == "string" and obj or obj.session_id --please no SelectedObj here, this is sync
	local squad = gv_UnitData[unit_id] and gv_UnitData[unit_id].Squad
	squad = squad and gv_Squads[squad]
	if units[1] and squad and self.Merc then
		units[1]:JoinSquadAs(self.Merc, squad)
	end
end

---
--- Returns an error message if the UnitJoinAsMerc effect cannot be executed.
---
--- This function checks if the required properties (TargetUnit and Merc) have been set, and returns an error message if either is missing.
---
--- @return string The error message, or nil if the effect can be executed.
---
function UnitJoinAsMerc:GetError()
	if not self.TargetUnit then
		return "Choose target unit to join"
	end
	if not self.Merc then
		return "Choose merc as which the unit joins"
	end
end

---
--- Returns the UI text for the UnitJoinAsMerc effect.
---
--- This function is responsible for generating the UI text that will be displayed for the UnitJoinAsMerc effect. It retrieves the name of the merc that the unit will join as, and returns a localized string with the merc's name.
---
--- @param context The context in which the effect is being executed.
--- @param template The template to use for the UI text.
--- @param game The game object.
--- @return string The UI text for the UnitJoinAsMerc effect.
---
function UnitJoinAsMerc:GetUIText(context,template, game)
	local merc = gv_UnitData and gv_UnitData[self.Merc]
	local name
	if not merc then
		name = game and "" or Untranslated("[MercName]")
	else
		name = merc.Nick or merc.Name
	end
	return T{246469241790, "Recruit merc (<em><name></em>)", name= name}
end

DefineClass.UnitMakeNonVillain = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "UnitId", 
			editor = "choice", default = false, items = function (self) return GetPersistentSessionIds() end, },
		{ id = "HealHP", help = "whether to also heal the unit to full", 
			editor = "bool", default = false, },
	},
	EditorView = Untranslated("Make <UnitId> non villain."),
	Documentation = "Make all instances of the specified persistant villain unit non-villain (killable)",
	EditorNestedObjCategory = "Units",
}

---
--- Executes the UnitMakeNonVillain effect, which makes all instances of the specified persistent villain unit non-villain (killable).
---
--- This function iterates through all the units with the specified UnitId, and calls the MakeUnitNonVillain function on each one. If the HealHP property is set, it also heals the unit to full health.
---
--- @param obj The object that the effect is being executed on.
--- @param context The context in which the effect is being executed.
---
function UnitMakeNonVillain:__exec(obj, context)
	local units = g_PersistentUnitData[self.UnitId]
	for i, u in ipairs(units) do
		MakeUnitNonVillain(u)
		
		-- Heal unit if enabled and exists, dont use
		-- standard heal logic to make it invisible.
		local mapUnit = g_Units[u.session_id]
		if mapUnit and self.HealHP then
			mapUnit.HitPoints = mapUnit.Health
		end
	end
end

DefineClass.UnitSetConflictIgnore = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "ConflictIgnore", name = "Conflict Ignore", help = "Whether to be afraid in conflicts or not.", 
			editor = "bool", default = true, },
		{ id = "TargetUnit", name = "Target Unit", help = "Target unit for match.", 
			editor = "combo", default = false, items = function (self) return GetUnitGroups() end, },
	},
	EditorView = Untranslated("Set <u(TargetUnit)> ConflictIgnore to <if(ConflictIgnore)>true</if><if(not(ConflictIgnore))>false</if>."),
	Documentation = "Sets units to be affraid(or not) during confict.",
	EditorNestedObjCategory = "Units",
}

---
--- Executes the UnitSetConflictIgnore effect, which sets the conflict_ignore property of all units in the specified target group.
---
--- @param obj The object that the effect is being executed on.
--- @param context The context in which the effect is being executed.
---
function UnitSetConflictIgnore:__exec(obj, context)
	local objects = Groups[self.TargetUnit] or empty_table
	for _, obj in ipairs(objects) do
		if IsKindOf(obj, "Unit") then
			obj.conflict_ignore = self.ConflictIgnore
		end
	end
end

---
--- Checks if the TargetUnit property has been set for the UnitSetConflictIgnore effect. If not, returns an error message.
---
--- @return string|nil An error message if the TargetUnit property is not set, otherwise nil.
---
function UnitSetConflictIgnore:GetError()
	if not self.TargetUnit then
		return "Choose TargetUnit!"
	end
end

DefineClass.UnitSetHireStatus = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Status", name = "Hire Status", help = "The hiring status to set.", 
			editor = "choice", default = "Available", items = function (self) return PresetGroupCombo("MercHireStatus", "Default") end, },
		{ id = "TargetUnit", name = "Target Unit", help = "Target unit for match.", 
			editor = "combo", default = false, items = function (self) return GetTargetUnitCombo() end, },
	},
	EditorView = Untranslated("Set <u(TargetUnit)> to status <u(Status)>"),
	Documentation = "Sets the hiring status of the merc to a specified value.",
	EditorNestedObjCategory = "Units",
}

---
--- Executes the UnitSetHireStatus effect, which sets the hire status of the specified target unit.
---
--- @param obj The object that the effect is being executed on.
--- @param context The context in which the effect is being executed.
---
function UnitSetHireStatus:__exec(obj, context)
	if not self.Status then return false end
	local unit = UnitDataDefs[self.TargetUnit]
	local unitData = gv_UnitData[unit.id]
	if not unitData then return end
	unitData.HireStatus = self.Status
end

---
--- Checks if the Status property has been set for the UnitSetHireStatus effect. If not, returns an error message.
---
--- @return string|nil An error message if the Status property is not set, otherwise nil.
---
function UnitSetHireStatus:GetError()
	if not self.Status then
		return "Choose unit hiring status to set!"
	end
end

DefineClass.UnitSetOnline = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Online", name = "Online", help = "Whether to set it online or offline.", 
			editor = "bool", default = true, },
		{ id = "TargetUnit", name = "Target Unit", help = "Target unit for match.", 
			editor = "combo", default = false, items = function (self) return GetTargetUnitCombo() end, },
	},
	EditorView = Untranslated("Set <u(TargetUnit)> messenger availability to <u(Status)>"),
	Documentation = "Sets a merc's online/offline status in the PDA messenger. When offline mercs cannot be hired.",
	EditorNestedObjCategory = "Units",
}

---
--- Executes the UnitSetOnline effect, which sets the online/offline status of the specified target unit in the PDA messenger.
---
--- @param obj The object that the effect is being executed on.
--- @param context The context in which the effect is being executed.
---
function UnitSetOnline:__exec(obj, context)
	local unit = UnitDataDefs[self.TargetUnit]
	local unitData = gv_UnitData[unit.id]
	if not unitData then return end
	unitData:SetMessengerOnline(self.Online)
end

---
--- Checks if the TargetUnit property has been set for the UnitSetOnline effect. If not, returns an error message.
---
--- @return string|nil An error message if the TargetUnit property is not set, otherwise nil.
---
function UnitSetOnline:GetError()
	if not self.TargetUnit then
		return "Choose targetunit!"
	end
end

DefineClass.UnitSetStatusEffectImmunity = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Status", name = "Status", 
			editor = "preset_id", default = false, preset_class = "CharacterEffectCompositeDef", },
		{ id = "Immune", 
			editor = "bool", default = false, },
		{ id = "Reason", help = "Text label used for keeping track of the different reasons a unit can have for being immune to the specific status effect. All reasons must be cleared in order for the unit to be able to receive the effect again.", 
			editor = "text", default = "script", },
	},
	RequiredObjClasses = {
	"Unit",
},
	ReturnClass = "",
	EditorView = Untranslated(""),
	Documentation = "Add or remove immunity to specified status effect to a target unit",
	EditorNestedObjCategory = "",
}

---
--- Gets the editor view text for the UnitSetStatusEffectImmunity effect.
---
--- If the Immune property is true, returns a string indicating that the unit will be made immune to the specified status effect.
--- If the Immune property is false, returns a string indicating that the immunity to the specified status effect will be cleared from the unit.
---
--- @return string The editor view text for the UnitSetStatusEffectImmunity effect.
---
function UnitSetStatusEffectImmunity:GetEditorView()
	if self.Immune then
		return Untranslated("Make unit immune to <u(Status)>")
	end
	return Untranslated("Clear immunity to <u(Status)> from unit")
end

---
--- Executes the UnitSetStatusEffectImmunity effect.
---
--- If the Immune property is true, the effect will add the specified status effect immunity to the target unit.
--- If the Immune property is false, the effect will remove the specified status effect immunity from the target unit.
---
--- @param obj Unit The target unit for the effect.
--- @param context table The execution context for the effect.
---
function UnitSetStatusEffectImmunity:__exec(obj, context)
	if self.Immune then
		obj:AddStatusEffectImmunity(self.Status, self.Reason)
	else
		obj:RemoveStatusEffectImmunity(self.Status, self.Reason)
	end
end

DefineClass.UnitStartConversation = {
	__parents = { "Effect", "ConversationFunctionObjectBase", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Conversation", name = "Conversation", help = "Conversation to start.", 
			editor = "preset_id", default = false, preset_class = "Conversation", },
	},
	EditorView = Untranslated("Start conversation <u(Conversation)>."),
	Documentation = "Starts a specific conversation - no groups or conditions are checked.",
	EditorNestedObjCategory = "",
	EditorNestedObjCategory = "Interactions",
}

---
--- Executes the UnitStartConversation effect.
---
--- Starts the specified conversation on the target unit.
---
--- @param obj Unit The target unit for the effect.
--- @param context table The execution context for the effect.
---
function UnitStartConversation:__exec(obj, context)
	StartConversationEffect(self.Conversation, context)
end

---
--- Waits for the specified conversation to complete before continuing execution of the effect.
---
--- @param obj Unit The target unit for the effect.
--- @param context table The execution context for the effect.
---
function UnitStartConversation:__waitexec(obj, context)
	StartConversationEffect(self.Conversation, context, "wait")
end

---
--- Checks if the Conversation property is set. If not, returns an error message.
---
--- @return string|nil An error message if the Conversation property is not set, otherwise nil.
---
function UnitStartConversation:GetError()
	if not self.Conversation then
		return "Please specify conversation"
	end
end

---
--- Constructs a new `UnitStartConversation` effect.
---
--- This function is a constructor for the `UnitStartConversation` effect class. It provides backward compatibility by handling the case where the `Group` property is set instead of the `Conversation` property.
---
--- @param ... any Arguments passed to the constructor.
--- @return table The newly constructed `UnitStartConversation` effect.
---
function UnitStartConversation:new(...)
	-- backward compatibility
	local ret = Effect.new(self, ...)
	if rawget(ret, "Group") then
		ret.Conversation = ret.Group
		ret.Group = nil
	end
	return ret
end

---
--- Returns the resume data for the UnitStartConversation effect.
---
--- This function is called when the effect needs to be resumed, such as when a conversation is completed. It returns the effect name and the conversation object that was started.
---
--- @param thread table The coroutine thread that is executing the effect.
--- @param stack table The call stack of the coroutine.
--- @param stack_index number The index of the current frame in the call stack.
--- @return string, any The effect name and the conversation object that was started.
---
function UnitStartConversation:GetResumeData(thread, stack, stack_index)
	return "UnitStartConversation", self.Conversation
end

DefineClass.UnitStatBoost = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Stat", name = "Stat", 
			editor = "combo", default = false, items = function (self) return GetUnitStatsCombo() end, },
		{ id = "Amount", name = "Amount", help = "How much to boost the specified Stat.", 
			editor = "number", default = false, },
		{ id = "source", name = "Source", help = "What kind of source is the thing that provides the stat boost.", 
			editor = "combo", default = "Book", items = function (self) return {"Book", "Other"} end, },
	},
	RequiredObjClasses = {
	"Unit",
},
	EditorView = Untranslated("Boost unit's stat <Stat>"),
	Documentation = "Boosts unit's stat",
	EditorNestedObjCategory = "Units",
}

---
--- Executes the UnitStatBoost effect, which boosts a unit's specified stat by the given amount.
---
--- If the source of the stat boost is a "Book", a unique modifier ID is generated and the stat is gained using the "Studying" modifier type. Otherwise, a generic modifier ID is generated and the stat is gained without a specific modifier type.
---
--- @param obj table The unit object on which the effect is being applied.
--- @param context table The context in which the effect is being executed.
---
function UnitStatBoost:__exec(obj, context)
	if not obj.is_clone then
		local modId
		if self.source == "Book" then
			modId = string.format("StatBoostBook-%s-%s-%d", self.Stat, obj.session_id, GetPreciseTicks())
			GainStat(obj, self.Stat, self.Amount, modId, "Studying")
		else
			modId = string.format("StatBoost-%s-%s-%d", self.Stat, obj.session_id, GetPreciseTicks())
			GainStat(obj, self.Stat, self.Amount, modId)
		end
	end
end

---
--- Checks if the UnitStatBoost effect is valid.
---
--- @return string|nil The error message if the effect is not valid, or nil if it is valid.
---
function UnitStatBoost:GetError()
	if not self.Stat then
		return "Choose stat"
	elseif not self.Amount then
		return "Choose amount"
	end
end

DefineClass.UnitTakeDamage = {
	__parents = { "Effect", "UnitTarget", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Damage", 
			editor = "number", default = 5, min = 0, },
		{ id = "FloatingText", help = "Will only be displayed if the target unit is visible for the player; <Damage> parameter will be provided for the text.", 
			editor = "text", default = T(477545213542, --[[EffectDef Effects UnitTakeDamage default]] "<Damage>"), translate = true, },
		{ id = "LogMessage", help = "<Damage> and <Name> parameters will be provided for the text.", 
			editor = "text", default = T(879191059352, --[[EffectDef Effects UnitTakeDamage default]] "<em><Name></em> takes <em><Damage></em> damage."), translate = true, },
	},
	RequiredObjClasses = {
	"Unit",
},
	EditorView = Untranslated("Deal <Damage> damage to the unit"),
	Documentation = "Deal damage to the unit",
}

---
--- Executes the UnitTakeDamage effect, dealing damage to the target units.
---
--- @param obj table The object on which the effect is being executed.
--- @param context table The context in which the effect is being executed.
---
function UnitTakeDamage:__exec(obj, context)
	if not context then context = {} end
	local units = self:MatchMapUnits(obj, context)
	if units and context.target_units then
		local floating_text = T{self.FloatingText, Damage = self.Damage}
		local pov_team = GetPoVTeam()
		for _, unit in ipairs(context.target_units) do
			if not unit:IsDead() then
				local has_visibility = HasVisibilityTo(pov_team, obj)
				local log_msg = T{self.LogMessage, { Name = unit:GetLogName(), Damage = self.Damage}}
				unit:TakeDirectDamage(self.Damage, has_visibility and floating_text or false, "short", log_msg)
			end
		end
	end
end

---
--- Checks if the given unit is valid for the UnitTakeDamage effect.
---
--- @param unit table The unit to check.
--- @param obj table The object on which the effect is being executed.
--- @param context table The context in which the effect is being executed.
--- @return boolean true if the unit is valid, false otherwise.
---
function UnitTakeDamage:UnitCheck(unit, obj, context)
	return true
end

DefineClass.UnitTakeItem = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "ItemId", name = "Item", help = "The id of the item that will be taken.", 
			editor = "preset_id", default = false, preset_class = "InventoryItemCompositeDef", },
		{ id = "Amount", name = "Amount", help = "How many items to take.", 
			editor = "number", default = 1, min = 1, },
		{ id = "AnySquad", name = "Any player squad", help = "if true: takes item from any player's squad. if false: takes item from current squad", 
			editor = "bool", default = false, },
		{ id = "AddToLogVar", name = "Add to log", help = "Add message to log.", 
			editor = "bool", default = true, },
	},
	EditorView = Untranslated("Take <u(ItemId)>(<Amount>)  from merc(s) in squad."),
	Documentation = "Removes the first given item from the inventory of a merc in the squad.",
	EditorNestedObjCategory = "Units",
}

---
--- Adds a log message when an item is taken from a unit.
---
--- @param unit table|number The unit or squad bag from which the item was taken.
--- @param item table The item that was taken.
--- @param amount number The amount of the item that was taken.
---
function UnitTakeItem:AddToLog(unit, item, amount)
	if self.AddToLogVar then	
		local unit_name 
		if type(unit)=="number" then
			unit_name = g_Classes.SquadBag.DisplayName
		else
			 unit_name = unit:GetDisplayName()
		end	
	   CombatLog("short", T{795253111432, "<amount> x <em><item></em> taken from <name>", amount = amount>=1 and amount or "", item = amount>1 and item.DisplayNamePlural or item.DisplayName,  name = unit_name})
	end
end

---
--- Executes the UnitTakeItem effect, which removes a specified item from the inventory of a unit or squad.
---
--- @param obj table|string The unit or squad bag from which the item will be taken.
--- @param context table The context in which the effect is being executed.
---
function UnitTakeItem:__exec(obj, context)
	-- can work with both unit and a unit session_id
	local unit_id = false
	if type(obj) == "string" then
		unit_id = obj
	elseif IsKindOf(obj, "Unit") then
		unit_id = obj.session_id
	end
	
	local all_mercs = false
	local squad = unit_id and gv_UnitData[unit_id] and gv_UnitData[unit_id].Squad
	if squad then
		all_mercs = table.copy(gv_Squads[squad].units)
		if self.AnySquad then
			local side = gv_Squads[squad].Side
			if side=="player1" then
				 table.iappend(all_mercs,GetAllPlayerUnitsOnMapSessionId())
			end
			for sq_id, sqd in pairs(gv_Squads) do
				if sq_id~=squad and  (sqd.Side ==side) then
					table.iappend(all_mercs, sqd.units )
				end
			end	
			all_mercs = table.get_unique(all_mercs)
		end	
		table.remove_entry(all_mercs, unit_id)
		table.insert(all_mercs, 1, unit_id) -- prioritize unit_id
	else
		all_mercs = GetAllPlayerUnitsOnMapSessionId()
	end
	
	TakeItemFromMercs(all_mercs, self.ItemId, self.Amount,
		function(unit, item, unit_amount, effect)
			effect:AddToLog(unit, item, unit_amount)
		end,
		self)
	InventoryUIRespawn()
end

---
--- Checks if the ItemId property is set. If not, returns an error message.
---
--- @return string|nil An error message if the ItemId property is not set, otherwise nil.
---
function UnitTakeItem:GetError()
	if not self.ItemId then
		return "Set Item!"
	end
end

---
--- Generates the UI text for the UnitTakeItem effect.
---
--- @param context table The context object.
--- @param template string An optional template string.
--- @param game table The game object.
--- @return string The generated UI text.
---
function UnitTakeItem:GetUIText(context, template, game)
	local item_name = InventoryItemDefs[self.ItemId].DisplayName
	local item_name_pl = InventoryItemDefs[self.ItemId].DisplayNamePlural
	
	local unit_id = ConversationGetPlayerMerc()
	
	local has_item = HasItemInSquad(unit_id, self.ItemId, self.Amount)
	
	if self.ItemId=="Money" then
		return has_item and T{304179156341, "Give <em><money(Amount)></em>", Amount =  self.Amount} 
										or T{231000532062, "<em><money(Amount)></em> required", Amount =  self.Amount} 									
	end
	
	if template then
		return T{template, Amount =  self.Amount, item = self.Amount<=1 and item_name or item_name_pl}
	else
		return has_item and T{590581690149, "Give <em><Amount> <item></em>",Amount =self.Amount, item = self.Amount<=1 and item_name or item_name_pl}
									   or T{635806839384, "<em><Amount> <item></em> required",Amount =self.Amount, item = self.Amount<=1 and item_name or item_name_pl}
	end
end

---
--- Generates the top rollover text for the UnitTakeItem effect.
---
--- @param negative boolean Whether to generate the negative text (when the item is not available).
--- @param template string An optional template string.
--- @param game table The game object.
--- @return string The generated top rollover text.
---
function UnitTakeItem:GetPhraseTopRolloverText(negative, template, game)
	local item_name = InventoryItemDefs[self.ItemId].DisplayName
	local item_name_pl = InventoryItemDefs[self.ItemId].DisplayNamePlural
	
	if self.ItemId=="Money" then
		return T{792302629761, "Delivered <em><money(Amount)></em>",Amount = self.Amount}
	else
		return T{652398655206, "Delivered <Amount> x <em><item></em>",Amount = self.Amount, item =  self.Amount<=1 and item_name or item_name_pl}
	end
end

DefineClass.UnitsAddToAmbientLife = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Group", name = "Group", help = "Units Group to add to Ambient Life.", 
			editor = "combo", default = false, items = function (self) return GetUnitGroups() end, },
	},
	EditorView = Untranslated("Add objects of group to Ambient Zone"),
	Documentation = "Add objects of group to Ambient Zone marker's responsibilities.",
}

---
--- Checks if the Units Group property is set for the UnitsAddToAmbientLife effect.
---
--- @return string|nil The error message if the Units Group property is not set, or nil if it is set.
---
function UnitsAddToAmbientLife:GetError()
	if not self.Group then
		return "Choose Units Group!"
	end
end

---
--- Adds units from the specified group to the ambient zone marker.
---
--- @param obj table The object that the effect is being executed on.
--- @param context table The context in which the effect is being executed.
---
function UnitsAddToAmbientLife:__exec(obj, context)
	local group_units = Groups[self.Group] or empty_table
	if #group_units == 0 then return end
	
	local zone
	MapForEach("map", "AmbientZoneMarker", function(marker)
		zone = marker
		return false
	end)
	
	if zone then
		zone:RegisterUnits(table.ifilter(group_units, function(i, u)
			return IsKindOf(u, "Unit")
		end))
	end
end

DefineClass.UnitsDespawnAmbientLife = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Ephemeral", name = "Ephemeral Only", help = "All ambient life units or just ephemeral ones.", 
			editor = "bool", default = true, },
	},
	EditorView = Untranslated("Despawn all Ambient Life Units"),
	Documentation = "Despawn all ambient units - abrupt, don't wait for exit animations.",
}

---
--- Despawns all ambient life units from the ambient zone markers on the map.
---
--- If the `Ephemeral` property is set, only ephemeral units will be despawned.
--- Otherwise, all units in the ambient zone markers will be despawned.
---
--- @param obj table The object that the effect is being executed on.
--- @param context table The context in which the effect is being executed.
---
function UnitsDespawnAmbientLife:__exec(obj, context)
	MapForEach("map", "AmbientZoneMarker", function(zone)
		for _, units in ipairs(zone.units) do
			for idx = #units, 1, -1 do
				local unit = units[idx]
				if not self.Ephemeral  or unit.ephemeral then
					table.remove(units, idx)
					DoneObject(unit)
				end
			end
		end
	end)
end

DefineClass.UnitsKickAmbientLife = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "AL_Group", name = "AL Group", help = "Target unit for match.", 
			editor = "combo", default = false, items = function (self) return GetALMarkerGroups() end, },
	},
	EditorView = Untranslated("Kicks Ambient Life <AL_Group> group from Their Markers"),
	Documentation = "Forces all units in ambient life behavior visiting specific group cancel their visit behavior",
	EditorNestedObjCategory = "Units",
}

---
--- Kicks all ambient life units that are visiting markers in the specified AL_Group from their markers.
---
--- This function iterates through all units in the `g_Units` table, and for each unit that is visiting a marker:
--- - Checks if the unit's last visited marker is in the `AL_Group` specified in the effect's properties.
--- - If so, it sets the unit's behavior to idle and clears the `perpetual_marker` flag.
---
--- @param obj table The object that the effect is being executed on.
--- @param context table The context in which the effect is being executed.
---
function UnitsKickAmbientLife:__exec(obj, context)
	for _, unit in ipairs(g_Units) do
		if IsVisitingUnit(unit) then
			if unit.last_visit:IsInGroup(self.AL_Group) then
				unit:SetBehavior()
				unit:SetCommand("Idle")
				unit.perpetual_marker = false
			end
		end
	end
end

---
--- Checks if the AL_Group property is set, and returns an error message if it is not.
---
--- @return string|nil An error message if the AL_Group property is not set, otherwise nil.
---
function UnitsKickAmbientLife:GetError()
	if not self.AL_Group then
		return "Choose group of AL markers to kick units from"
	end
end

---
--- Returns the UI text for the UnitsKickAmbientLife effect, including the name of the associated merc.
---
--- @param context table The context in which the effect is being executed.
--- @param template string The template to use for the UI text.
--- @param game boolean Whether the game is currently running.
--- @return string The formatted UI text.
---
function UnitsKickAmbientLife:GetUIText(context,template, game)
	local merc = gv_UnitData and gv_UnitData[self.Merc]
	local name
	if not merc then
		name = game and "" or Untranslated("[MercName]")
	else
		name = merc.Nick or merc.Name
	end
	return T{246469241790, "Recruit merc (<em><name></em>)", name= name}
end

DefineClass.UnitsKickFromPerpetualMarkers = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "Ephemeral", name = "Ephemeral Only", help = "All ambient life units or just ephemeral ones.", 
			editor = "bool", default = true, },
	},
	EditorView = Untranslated("Kick Units from Perpetual Markers"),
	Documentation = "Kicks all Ambient Life units which are in perpetual markers",
}

---
--- Kicks all Ambient Life units which are in perpetual markers.
---
--- @param obj table The object on which the effect is being executed.
--- @param context table The context in which the effect is being executed.
---
function UnitsKickFromPerpetualMarkers:__exec(obj, context)
	for _, unit in ipairs(g_Units) do
		if (not self.Ephemeral or unit.ephemeral) and unit.perpetual_marker then
			unit:SetBehavior()
			unit:SetCommand("Idle")
			unit.perpetual_marker = false
		end
	end
end

DefineClass.UnitsStealForPerpetualMarkers = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	EditorView = Untranslated("Steal Units for Perpetual Markers"),
	Documentation = "Steal units for perpetual markers as if the Ambient Life is respawn",
}

---
--- Steals units for perpetual markers as if the Ambient Life is respawning.
---
--- @param obj table The object on which the effect is being executed.
--- @param context table The context in which the effect is being executed.
---
function UnitsStealForPerpetualMarkers:__exec(obj, context)
	AmbientLifePerpetualMarkersSteal()
end

DefineClass.UpdateInteractablesHighlight = {
	__parents = { "Effect", },
	__generated_by_class = "EffectDef",

	Documentation = "Disable interaction markers of a specific group.",
	EditorNestedObjCategory = "Interactable",
}

---
--- Disables interaction markers of a specific group of interactable objects.
---
--- This function iterates through all interactable objects in the current map and disables their
--- interaction markers if the player's UI units cannot interact with them. It also disables the
--- cursor highlight for all interactable objects that are not enabled container markers.
---
--- @param obj table The object on which the effect is being executed.
--- @param context table The context in which the effect is being executed.
---
function UpdateInteractablesHighlight:__exec(obj, context)
	if CurrentMap == "" or IsChangingMap() then return end
	if not g_Units then return end
	
	local ui_units = {}
	for _, unit in ipairs(g_Units) do
		if IsValid(unit) and not unit:IsDead() and unit.team and unit.team.control == "UI" then
			table.insert(ui_units, unit)
		end
	end
	if #ui_units == 0 then return end
	
	MapForEach("map", "Interactable", function(interactable)
		if not IsValid(interactable) then return end
		
		for _, unit in ipairs(ui_units) do
			if not UICanInteractWith(unit, interactable) then
				interactable:HighlightIntensely(false, "unit-nearby")
			end
		end
		if not (IsKindOf(interactable, "ContainerMarker") and interactable:IsMarkerEnabled()) then
			interactable:HighlightIntensely(false, "cursor")
			interactable:HighlightIntensely(false, "unit-nearby")
		end
	end)
end

---
--- Forces update of all highlighted interactables.
---
--- This function is used to force an update of the highlighting for all interactable objects in the current map. It is typically called when the player's UI units or the state of the interactable objects changes, to ensure that the highlighting is correctly applied.
---
--- @param obj table The object on which the effect is being executed.
--- @param context table The context in which the effect is being executed.
---
function UpdateInteractablesHighlight:GetEditorView()
	return T(680362306074, "Forces update of all highlighted interactables")
end

DefineClass.WaitNpcIdle = {
	__parents = { "Effect", "UnitTarget", },
	__generated_by_class = "EffectDef",

	properties = {
		{ id = "TargetUnit", name = "NPC Name", help = "The name of the NPC to associate.", 
			editor = "combo", default = false, items = function (self) return GetUnitGroups() end, },
	},
	EditorView = Untranslated("Wait for the NPC to become idle"),
	Documentation = "Wait for the NPC to become idle (requires sequential execution)",
	EditorNestedObjCategory = "Units",
}

---
--- Marks this effect as requiring sequential execution.
---
--- This function is a placeholder that throws an assertion error, indicating that the `WaitNpcIdle` effect requires sequential execution. This means that the effect must be executed in the order it appears in the sequence of effects, and cannot be executed in parallel with other effects.
---
--- @param obj table The object on which the effect is being executed.
--- @param context table The context in which the effect is being executed.
---
function WaitNpcIdle:__exec(obj, context)
	assert(false) -- This effect requires sequential execution
end

---
--- Waits for the first NPC unit that matches the `TargetUnit` property to become idle.
---
--- This function is called as part of the `WaitNpcIdle` effect. It retrieves the first NPC unit that matches the `TargetUnit` property, and then waits for that unit to become idle before continuing execution.
---
--- @param obj table The object on which the effect is being executed.
--- @param context table The context in which the effect is being executed.
---
function WaitNpcIdle:__waitexec(obj, context)
	local ctx = {}
	local units = self:MatchMapUnits(obj, ctx)
	local firstUnit = units and ctx.target_units
	firstUnit = firstUnit and firstUnit[1]
	if firstUnit then
		WaitIdle(firstUnit)
	end
end

---
--- Returns the resume data for the `WaitNpcIdle` effect.
---
--- This function is called when the `WaitNpcIdle` effect needs to be resumed, such as after a pause or interruption. It returns a table containing the effect name and the target unit, which can be used to resume the effect from the correct state.
---
--- @return string The name of the effect, "WaitNpcIdle".
--- @return string The name of the target unit.
---
function WaitNpcIdle:GetResumeData()
	return "WaitNpcIdle", self.TargetUnit
end

---
--- Returns an error message if the `TargetUnit` property is not set.
---
--- This function is called to retrieve an error message when the `WaitNpcIdle` effect is executed without a valid `TargetUnit` property. It checks if the `TargetUnit` property is set, and if not, returns an error message indicating that no target unit is set.
---
--- @return string The error message, or `nil` if the `TargetUnit` property is set.
---
function WaitNpcIdle:GetError()
	if not self.TargetUnit then
		return "No target unit"
	end
end

